
### lib/collection.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var STATES = require('./connectionstate')",
    "ctx": {
      "type": "declaration",
      "name": "STATES",
      "value": "require('./connectionstate')",
      "string": "STATES"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "collection",
        "description": "name"
      },
      {
        "type": "param",
        "types": [
          "Collection"
        ],
        "name": "connection",
        "description": "object"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "optional",
        "description": "options"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Collection constructor</p>",
      "summary": "<p>Collection constructor</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function Collection (name, conn, opts) {\n  this.name = name;\n  this.conn = conn;\n  this.buffer = true;\n  this.queue = [];\n\n  if ('number' == typeof opts) opts = { size: opts };\n  this.opts = opts || {};\n\n  if (STATES.connected == this.conn.readyState) {\n    this.onOpen();\n  }\n};",
    "ctx": {
      "type": "function",
      "name": "Collection",
      "string": "Collection()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The collection name</p>",
      "summary": "<p>The collection name</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Collection.prototype.name;"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The Connection instance</p>",
      "summary": "<p>The Connection instance</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Collection.prototype.conn;"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Called when the database connects</p>",
      "summary": "<p>Called when the database connects</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Collection.prototype.onOpen = function () {\n  var self = this;\n  this.buffer = false;\n  self.doQueue();\n};",
    "ctx": {
      "type": "method",
      "constructor": "Collection",
      "name": "onOpen",
      "string": "Collection.prototype.onOpen()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Called when the database disconnects</p>",
      "summary": "<p>Called when the database disconnects</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Collection.prototype.onClose = function () {\n  this.buffer = true;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Collection",
      "name": "onClose",
      "string": "Collection.prototype.onClose()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "method",
        "description": "name"
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "arguments",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Adds a callback to the queue</p>",
      "summary": "<p>Adds a callback to the queue</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Collection.prototype.addQueue = function (name, args) {\n  this.queue.push([name, args]);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Collection",
      "name": "addQueue",
      "string": "Collection.prototype.addQueue()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Executes the current queue</p>",
      "summary": "<p>Executes the current queue</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Collection.prototype.doQueue = function () {\n  for (var i = 0, l = this.queue.length; i < l; i++){\n    this[this.queue[i][0]].apply(this, this.queue[i][1]);\n  }\n  this.queue = [];\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Collection",
      "name": "doQueue",
      "string": "Collection.prototype.doQueue()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Ensure index function</p>",
      "summary": "<p>Ensure index function</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Collection.prototype.ensureIndex = function(){\n  throw new Error('Collection#ensureIndex unimplemented by driver');\n};",
    "ctx": {
      "type": "method",
      "constructor": "Collection",
      "name": "ensureIndex",
      "string": "Collection.prototype.ensureIndex()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>FindAndModify command</p>",
      "summary": "<p>FindAndModify command</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Collection.prototype.findAndModify = function(){\n  throw new Error('Collection#findAndModify unimplemented by driver');\n};",
    "ctx": {
      "type": "method",
      "constructor": "Collection",
      "name": "findAndModify",
      "string": "Collection.prototype.findAndModify()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>FindOne command</p>",
      "summary": "<p>FindOne command</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Collection.prototype.findOne = function(){\n  throw new Error('Collection#findOne unimplemented by driver');\n};",
    "ctx": {
      "type": "method",
      "constructor": "Collection",
      "name": "findOne",
      "string": "Collection.prototype.findOne()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Find command</p>",
      "summary": "<p>Find command</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Collection.prototype.find = function(){\n  throw new Error('Collection#find unimplemented by driver');\n};",
    "ctx": {
      "type": "method",
      "constructor": "Collection",
      "name": "find",
      "string": "Collection.prototype.find()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Insert command</p>",
      "summary": "<p>Insert command</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Collection.prototype.insert = function(){\n  throw new Error('Collection#insert unimplemented by driver');\n};",
    "ctx": {
      "type": "method",
      "constructor": "Collection",
      "name": "insert",
      "string": "Collection.prototype.insert()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Update command</p>",
      "summary": "<p>Update command</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Collection.prototype.save = function(){\n  throw new Error('Collection#save unimplemented by driver');\n};",
    "ctx": {
      "type": "method",
      "constructor": "Collection",
      "name": "save",
      "string": "Collection.prototype.save()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Insert command</p>",
      "summary": "<p>Insert command</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Collection.prototype.update = function(){\n  throw new Error('Collection#update unimplemented by driver');\n};",
    "ctx": {
      "type": "method",
      "constructor": "Collection",
      "name": "update",
      "string": "Collection.prototype.update()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>getIndexes command</p>",
      "summary": "<p>getIndexes command</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Collection.prototype.getIndexes = function(){\n  throw new Error('Collection#getIndexes unimplemented by driver');\n};",
    "ctx": {
      "type": "method",
      "constructor": "Collection",
      "name": "getIndexes",
      "string": "Collection.prototype.getIndexes()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>mapReduce</p>",
      "summary": "<p>mapReduce</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Collection.prototype.mapReduce = function(){\n  throw new Error('Collection#mapReduce unimplemented by driver');\n};",
    "ctx": {
      "type": "method",
      "constructor": "Collection",
      "name": "mapReduce",
      "string": "Collection.prototype.mapReduce()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = Collection;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "Collection",
      "string": "module.exports"
    }
  }
]
### lib/connection.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var url = require('url')\n  , utils = require('./utils')\n  , EventEmitter = utils.EventEmitter\n  , driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native'\n  , Model = require('./model')\n  , Schema = require('./schema')\n  , Collection  = require(driver + '/collection')\n  , STATES = require('./connectionstate')\n  , assert =require('assert')",
    "ctx": {
      "type": "declaration",
      "name": "url",
      "value": "require('url')",
      "string": "url"
    }
  },
  {
    "tags": [
      {
        "type": "ignore",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Protocol prefix regexp.</p>",
      "summary": "<p>Protocol prefix regexp.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var rgxProtocol = /^(?:.)+:\\/\\//;",
    "ctx": {
      "type": "declaration",
      "name": "rgxProtocol",
      "value": "/^(?:.)+:\\/\\//",
      "string": "rgxProtocol"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Mongoose"
        ],
        "name": "mongoose",
        "description": "base"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Connection constructor. For practical reasons, a Connection equals a Db</p>",
      "summary": "<p>Connection constructor. For practical reasons, a Connection equals a Db</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function Connection (base) {\n  this.base = base;\n  this.collections = {};\n  this.models = {};\n  this.replica = false;\n  this.host = null;\n  this.port = null;\n  this.user = null;\n  this.pass = null;\n  this.name = null;\n  this.options = null;\n  this._readyState = STATES.disconnected;\n};",
    "ctx": {
      "type": "function",
      "name": "Connection",
      "string": "Connection()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherit from EventEmitter.</p>",
      "summary": "<p>Inherit from EventEmitter.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Connection.prototype.__proto__ = EventEmitter.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "Connection",
      "name": "__proto__",
      "value": "EventEmitter.prototype",
      "string": "Connection.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<h2>Connection ready state</h2>\n\n<p>0 = Disconnected<br /> 1 = Connected<br /> 2 = Connecting<br /> 3 = Disconnecting</p>\n\n<p>Each state change emits its associated event name.</p>",
      "summary": "<h2>Connection ready state</h2>\n\n<p>0 = Disconnected<br /> 1 = Connected<br /> 2 = Connecting<br /> 3 = Disconnecting</p>",
      "body": "<p>Each state change emits its associated event name.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Object.defineProperty(Connection.prototype, 'readyState', {\n    get: function(){ return this._readyState; }\n  , set: function (val) {\n      if (!(val in STATES)) {\n        throw new Error('Invalid connection state: ' + val);\n      }\n\n      this._readyState = val;\n      this.emit(STATES[val]);\n    }\n});"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>A hash of the collections associated with this connection</p>",
      "summary": "<p>A hash of the collections associated with this connection</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Connection.prototype.collections;"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>The mongodb.Db instance, set when the connection is opened</p>",
      "summary": "<p>The mongodb.Db instance, set when the connection is opened</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Connection.prototype.db;"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "mongodb://uri",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Connection"
        ],
        "description": "self"
      },
      {
        "type": "see",
        "title": "",
        "url": "https://github.com/christkv/node-mongodb-native",
        "visibility": "https://github.com/christkv/node-mongodb-native"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Establishes the connection</p>\n\n<p><code>options</code> is a hash with the following optional properties:</p>\n\n<p>options.db      - passed to the connection db instance<br />  options.server  - passed to the connection server instance(s)<br />  options.replset - passed to the connection ReplSetServer instance<br />  options.user    - username for authentication<br />  options.pass    - password for authentication</p>\n\n<p>Notes:</p>\n\n<p>Mongoose forces the db option <code>forceServerObjectId</code> false and cannot<br />  be overridden.</p>\n\n<p>Mongoose defaults the server <code>auto_reconnect</code> options to true which<br />  can be overridden.</p>\n\n<p>See the node-mongodb-native driver instance for options that it<br />  understands.</p>",
      "summary": "<p>Establishes the connection</p>",
      "body": "<p><code>options</code> is a hash with the following optional properties:</p>\n\n<p>options.db      - passed to the connection db instance<br />  options.server  - passed to the connection server instance(s)<br />  options.replset - passed to the connection ReplSetServer instance<br />  options.user    - username for authentication<br />  options.pass    - password for authentication</p>\n\n<p>Notes:</p>\n\n<p>Mongoose forces the db option <code>forceServerObjectId</code> false and cannot<br />  be overridden.</p>\n\n<p>Mongoose defaults the server <code>auto_reconnect</code> options to true which<br />  can be overridden.</p>\n\n<p>See the node-mongodb-native driver instance for options that it<br />  understands.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Connection.prototype.open = function (host, database, port, options, callback) {\n  var self = this\n    , uri;\n\n  if ('string' === typeof database) {\n    switch (arguments.length) {\n      case 2:\n        port = 27017;\n      case 3:\n        switch (typeof port) {\n          case 'function':\n            callback = port, port = 27017;\n            break;\n          case 'object':\n            options = port, port = 27017;\n            break;\n        }\n        break;\n      case 4:\n        if ('function' === typeof options)\n          callback = options, options = {};\n    }\n  } else {\n    switch (typeof database) {\n      case 'function':\n        callback = database, database = undefined;\n        break;\n      case 'object':\n        options = database;\n        database = undefined;\n        callback = port;\n        break;\n    }\n\n    if (!rgxProtocol.test(host)) {\n      host = 'mongodb://' + host;\n    }\n\n    uri = url.parse(host);\n    host = uri.hostname;\n    port = uri.port || 27017;\n    database = uri.pathname && uri.pathname.replace(/\\//g, '');\n  }\n\n  this.options = this.defaultOptions(options);\n\n  // make sure we can open\n  if (STATES.disconnected !== this.readyState) {\n    var err = new Error('Trying to open unclosed connection.');\n    err.state = this.readyState;\n    this.error(err, callback);\n    return this;\n  }\n\n  if (!host) {\n    this.error(new Error('Missing connection hostname.'), callback);\n    return this;\n  }\n\n  if (!database) {\n    this.error(new Error('Missing connection database.'), callback);\n    return this;\n  }\n\n  // handle authentication\n  if (uri && uri.auth) {\n    var auth = uri.auth.split(':');\n    this.user = auth[0];\n    this.pass = auth[1];\n\n  // Check hostname for user/pass\n  } else if (/@/.test(host) && /:/.test(host.split('@')[0])) {\n    host = host.split('@');\n    var auth = host.shift().split(':');\n    host = host.pop();\n    this.user = auth[0];\n    this.pass = auth[1];\n\n  // user/pass options\n  } else if (options && options.user && options.pass) {\n    this.user = options.user;\n    this.pass = options.pass;\n\n  } else {\n    this.user = this.pass = undefined;\n  }\n\n  this.name = database;\n  this.host = host;\n  this.port = port;\n\n  this._open(callback);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Connection",
      "name": "open",
      "string": "Connection.prototype.open()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "comma-separated",
        "description": "mongodb:// URIs"
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "optional",
        "description": "database name"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "optional",
        "description": "options"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "optional",
        "description": "callback"
      }
    ],
    "description": {
      "full": "<p>Connects to a replica set.</p>\n\n<p>Supply a comma-separted list of mongodb:// URIs. You only need to specify<br />the database name and/or auth to one of them.</p>\n\n<p>The options parameter is passed to the low level connection. See the<br />node-mongodb-native driver instance for detail.</p>",
      "summary": "<p>Connects to a replica set.</p>",
      "body": "<p>Supply a comma-separted list of mongodb:// URIs. You only need to specify<br />the database name and/or auth to one of them.</p>\n\n<p>The options parameter is passed to the low level connection. See the<br />node-mongodb-native driver instance for detail.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Connection.prototype.openSet = function (uris, database, options, callback) {\n  var uris = uris.split(',')\n    , self = this;\n\n  switch (arguments.length) {\n    case 3:\n      this.name = database;\n      if ('function' === typeof options) callback = options, options = {};\n      break;\n    case 2:\n      switch (typeof database) {\n        case 'string':\n          this.name = database;\n        case 'function':\n          callback = database, database = null;\n          break;\n        case 'object':\n          options = database, database = null;\n          break;\n      }\n  }\n\n  this.options = options = this.defaultOptions(options);\n\n  if (uris.length < 2) {\n    this.error(new Error('Please provide comma-separated URIs'), callback);\n    return this;\n  }\n\n  this.replica = true;\n  this.host = [];\n  this.port = [];\n\n  uris.forEach(function (uri) {\n    // handle missing protocols\n    if (!rgxProtocol.test(uri))\n      uri = 'mongodb://' + uri;\n\n    var uri = url.parse(uri);\n\n    self.host.push(uri.hostname);\n    self.port.push(uri.port || 27017);\n\n    if (!self.name && uri.pathname && uri.pathname.replace(/\\//g, ''))\n      self.name = uri.pathname.replace(/\\//g, '');\n\n    if (!self.user && uri.auth) {\n      var auth = uri.auth.split(':');\n      self.user = auth[0];\n      self.pass = auth[1];\n    }\n  });\n\n  if (!this.name) {\n    this.error(new Error('No database name provided for replica set'), callback);\n    return this;\n  }\n\n  this._open(callback);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Connection",
      "name": "openSet",
      "string": "Connection.prototype.openSet()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Error"
        ],
        "name": "err",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": "(optional)"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>error</p>\n\n<p>Graceful error handling, passes error to callback<br />if available, else emits error on the connection.</p>",
      "summary": "<p>error</p>",
      "body": "<p>Graceful error handling, passes error to callback<br />if available, else emits error on the connection.</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Connection.prototype.error = function (err, callback) {\n  if (callback) return callback(err);\n  this.emit('error', err);\n}",
    "ctx": {
      "type": "method",
      "constructor": "Connection",
      "name": "error",
      "string": "Connection.prototype.error()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>_open</p>\n\n<p>Handles opening the connection with the appropriate<br />method based on connection type.</p>",
      "summary": "<p>_open</p>",
      "body": "<p>Handles opening the connection with the appropriate<br />method based on connection type.</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Connection.prototype._open = function (callback) {\n  this.readyState = STATES.connecting;\n\n  var self = this;\n\n  var method = this.replica\n    ? 'doOpenSet'\n    : 'doOpen';\n\n  // open connection\n  this[method](function (err) {\n    if (err) {\n      self.readyState = STATES.disconnected;\n      self.error(err, callback);\n      return;\n    }\n\n    self.onOpen();\n    callback && callback();\n  });\n}",
    "ctx": {
      "type": "method",
      "constructor": "Connection",
      "name": "_open",
      "string": "Connection.prototype._open()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Called when the connection is opened</p>",
      "summary": "<p>Called when the connection is opened</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Connection.prototype.onOpen = function () {\n  var self = this;\n\n  function open () {\n    self.readyState = STATES.connected;\n\n    // avoid having the collection subscribe to our event emitter\n    // to prevent 0.3 warning\n    for (var i in self.collections)\n      self.collections[i].onOpen();\n\n    self.emit('open');\n  };\n\n  // re-authenticate\n  if (self.user && self.pass)\n    self.db.authenticate(self.user, self.pass, open);\n  else\n    open();\n};",
    "ctx": {
      "type": "method",
      "constructor": "Connection",
      "name": "onOpen",
      "string": "Connection.prototype.onOpen()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "optional",
        "description": "callback"
      },
      {
        "type": "return",
        "types": [
          "Connection"
        ],
        "description": "self"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Closes the connection</p>",
      "summary": "<p>Closes the connection</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Connection.prototype.close = function (callback) {\n  var self = this;\n\n  switch (this.readyState){\n    case 0: // disconnected\n      callback && callback();\n      break;\n\n    case 1: // connected\n      this.readyState = STATES.disconnecting;\n      this.doClose(function(err){\n        if (err){\n          self.error(err, callback);\n        } else {\n          self.onClose();\n          callback && callback();\n        }\n      });\n      break;\n\n    case 2: // connecting\n      this.once('open', function(){\n        self.close(callback);\n      });\n      break;\n\n    case 3: // disconnecting\n      if (!callback) break;\n      this.once('close', function () {\n        callback();\n      });\n      break;\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Connection",
      "name": "close",
      "string": "Connection.prototype.close()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Called when the connection closes</p>",
      "summary": "<p>Called when the connection closes</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Connection.prototype.onClose = function () {\n  this.readyState = STATES.disconnected;\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (var i in this.collections)\n    this.collections[i].onClose();\n\n  this.emit('close');\n};",
    "ctx": {
      "type": "method",
      "constructor": "Connection",
      "name": "onClose",
      "string": "Connection.prototype.onClose()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "collection",
        "description": "name"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "optional",
        "description": "options"
      },
      {
        "type": "return",
        "types": [
          "Collection"
        ],
        "description": "collection instance"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Retrieves a collection, creating it if not cached.</p>",
      "summary": "<p>Retrieves a collection, creating it if not cached.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Connection.prototype.collection = function (name, options) {\n  if (!(name in this.collections))\n    this.collections[name] = new Collection(name, this, options);\n  return this.collections[name];\n};",
    "ctx": {
      "type": "method",
      "constructor": "Connection",
      "name": "collection",
      "string": "Connection.prototype.collection()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "model",
        "description": "name"
      },
      {
        "type": "param",
        "types": [
          "Schema"
        ],
        "name": "schema",
        "description": "object"
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "collection",
        "description": "name (optional, induced from model name)"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Defines a model or retrieves it</p>",
      "summary": "<p>Defines a model or retrieves it</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Connection.prototype.model = function (name, schema, collection) {\n  if (!this.models[name]) {\n    var model = this.base.model(name, schema, collection, true)\n      , Model\n\n    if (this != model.prototype.db) {\n      // subclass model using this connection and collection name\n      Model = function Model (doc, fields, skipId) {\n        if (!(this instanceof Model))\n          return new Model(doc, fields, skipId);\n        model.call(this, doc, fields, skipId);\n      };\n\n      Model.__proto__ = model;\n      Model.prototype.__proto__ = model.prototype;\n      Model.db = Model.prototype.db = this;\n\n      // collection name discovery\n      if ('string' === typeof schema) {\n        collection = schema;\n      }\n\n      if (!collection) {\n        collection = model.prototype.schema.set('collection') || utils.toCollectionName(name);\n      }\n\n      var s = 'string' != typeof schema\n        ? schema\n        : model.prototype.schema;\n\n      Model.prototype.collection = this.collection(collection, s && s.options.capped);\n      Model.collection = Model.prototype.collection;\n      Model.init();\n    }\n\n    this.models[name] = Model || model;\n  }\n\n  return this.models[name];\n};",
    "ctx": {
      "type": "method",
      "constructor": "Connection",
      "name": "model",
      "string": "Connection.prototype.model()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Int",
          "String"
        ],
        "name": "level",
        "description": "- Either off (0), slow (1), or all (2)"
      },
      {
        "type": "param",
        "types": [
          "Int"
        ],
        "name": "[ms]",
        "description": "If profiling `level` is set to 1, this determines"
      },
      {
        "type": "",
        "string": "the threshold in milliseconds above which queries"
      },
      {
        "type": "",
        "string": "will be logged. Defaults to 100. (optional)"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Set profiling level.</p>",
      "summary": "<p>Set profiling level.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Connection.prototype.setProfiling = function (level, ms, callback) {\n  if (STATES.connected !== this.readyState) {\n    return this.on('open', this.setProfiling.bind(this, level, ms, callback));\n  }\n\n  if (!callback) callback = ms, ms = 100;\n\n  var cmd = {};\n\n  switch (level) {\n    case 0:\n    case 'off':\n      cmd.profile = 0;\n      break;\n    case 1:\n    case 'slow':\n      cmd.profile = 1;\n      if ('number' !== typeof ms) {\n        ms = parseInt(ms, 10);\n        if (isNaN(ms)) ms = 100;\n      }\n      cmd.slowms = ms;\n      break;\n    case 2:\n    case 'all':\n      cmd.profile = 2;\n      break;\n    default:\n      return callback(new Error('Invalid profiling level: '+ level));\n  }\n\n  this.db.executeDbCommand(cmd, function (err, resp) {\n    if (err) return callback(err);\n\n    var doc = resp.documents[0];\n\n    err = 1 === doc.ok\n      ? null\n      : new Error('Could not set profiling level to: '+ level)\n\n    callback(err, doc);\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "Connection",
      "name": "setProfiling",
      "string": "Connection.prototype.setProfiling()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Prepares default connection options.</p>",
      "summary": "<p>Prepares default connection options.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Connection.prototype.defaultOptions = function (options) {\n  var o = options || {};\n\n  o.server = o.server || {};\n\n  if (!('auto_reconnect' in o.server)) {\n    o.server.auto_reconnect = true;\n  }\n\n  o.db = o.db || {};\n  o.db.forceServerObjectId = false;\n\n  return o;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Connection",
      "name": "defaultOptions",
      "string": "Connection.prototype.defaultOptions()"
    }
  },
  {
    "tags": [
      {
        "type": "ignore",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Noop.</p>",
      "summary": "<p>Noop.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function noop () {}",
    "ctx": {
      "type": "function",
      "name": "noop",
      "string": "noop()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Connection.STATES = STATES;\nmodule.exports = Connection;",
    "ctx": {
      "type": "property",
      "receiver": "Connection",
      "name": "STATES",
      "value": "STATES",
      "string": "Connection.STATES"
    }
  }
]
### lib/connectionstate.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Connection states</p>",
      "summary": "<p>Connection states</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var STATES = module.exports = exports = Object.create(null);\n\nvar disconnected = 'disconnected';\nvar connected = 'connected';\nvar connecting = 'connecting';\nvar disconnecting = 'disconnecting';\nvar uninitialized = 'uninitialized';\n\nSTATES[0] = disconnected;\nSTATES[1] = connected;\nSTATES[2] = connecting;\nSTATES[3] = disconnecting;\nSTATES[99] = uninitialized;\n\nSTATES[disconnected] = 0;\nSTATES[connected] = 1;\nSTATES[connecting] = 2;\nSTATES[disconnecting] = 3;\nSTATES[uninitialized] = 99;",
    "ctx": {
      "type": "declaration",
      "name": "STATES",
      "value": "module.exports = exports = Object.create(null)",
      "string": "STATES"
    }
  }
]
### lib/document.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var EventEmitter = require('events').EventEmitter\n  , MongooseError = require('./error')\n  , MixedSchema = require('./schema/mixed')\n  , Schema = require('./schema')\n  , ValidatorError = require('./schematype').ValidatorError\n  , utils = require('./utils')\n  , clone = utils.clone\n  , isMongooseObject = utils.isMongooseObject\n  , inspect = require('util').inspect\n  , StateMachine = require('./statemachine')\n  , ActiveRoster = StateMachine.ctor('require', 'modify', 'init', 'default')\n  , ValidationError = require('./errors/validation')\n  , DocumentError = require('./errors/document')\n  , deepEqual = utils.deepEqual\n  , hooks = require('hooks')\n  , DocumentArray",
    "ctx": {
      "type": "declaration",
      "name": "EventEmitter",
      "value": "require('events').EventEmitter",
      "string": "EventEmitter"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "- values to set"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "fields",
        "description": "- which were selected in the query returning this document"
      },
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "skipId",
        "description": "- flag if we should auto create an ObjectId _id"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Document constructor.</p>",
      "summary": "<p>Document constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function Document (obj, fields, skipId) {\n  // node <0.4.3 bug\n  if (!this._events) this._events = {};\n  this.setMaxListeners(0);\n\n  if ('boolean' === typeof fields) {\n    this._strictMode = fields;\n    this._selected = fields = undefined;\n  } else {\n    this._strictMode = this.schema.options && this.schema.options.strict;\n    this._selected = fields;\n  }\n\n  this.isNew = true;\n  this.errors = undefined;\n  this._shardval = undefined;\n  this._saveError = undefined;\n  this._validationError = undefined;\n  this._adhocPaths = undefined;\n  this._removing = undefined;\n  this._inserting = undefined;\n  this.__version = undefined;\n  this.__getters = {};\n  this.__id = undefined;\n\n  this._activePaths = new ActiveRoster;\n\n  var required = this.schema.requiredPaths();\n  for (var i = 0; i < required.length; ++i) {\n    this._activePaths.require(required[i]);\n  }\n\n  this._doc = this._buildDoc(obj, fields, skipId);\n  if (obj) this.set(obj, undefined, true);\n  this._registerHooks();\n};",
    "ctx": {
      "type": "function",
      "name": "Document",
      "string": "Document()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherit from EventEmitter.</p>",
      "summary": "<p>Inherit from EventEmitter.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Document.prototype.__proto__ = EventEmitter.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "Document",
      "name": "__proto__",
      "value": "EventEmitter.prototype",
      "string": "Document.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Document schema as a nested structure.</p>",
      "summary": "<p>Document schema as a nested structure.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.schema;"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Whether the document is new.</p>",
      "summary": "<p>Whether the document is new.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.isNew;"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Validation errors.</p>",
      "summary": "<p>Validation errors.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.errors;"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Builds the default doc structure</p>",
      "summary": "<p>Builds the default doc structure</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Document.prototype._buildDoc = function (obj, fields, skipId) {\n  var doc = {}\n    , self = this\n    , exclude\n    , keys\n    , key\n    , ki\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n  if (fields && 'Object' === fields.constructor.name) {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    while (ki--) {\n      if ('_id' !== keys[ki]) {\n        exclude = 0 === fields[keys[ki]];\n        break;\n      }\n    }\n  }\n\n  var paths = Object.keys(this.schema.paths)\n    , plen = paths.length\n    , ii = 0\n\n  for (; ii < plen; ++ii) {\n    var p = paths[ii];\n\n    if ('_id' == p) {\n      if (skipId) continue;\n      if (obj && '_id' in obj) continue;\n    }\n\n    var type = this.schema.paths[p]\n      , path = p.split('.')\n      , len = path.length\n      , last = len-1\n      , doc_ = doc\n      , i = 0\n\n    for (; i < len; ++i) {\n      var piece = path[i]\n        , def\n\n      if (i === last) {\n        if (fields) {\n          if (exclude) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) continue;\n\n            def = type.getDefault(self, true);\n            if ('undefined' !== typeof def) {\n              doc_[piece] = def;\n              self._activePaths.default(p);\n            }\n\n          } else if (p in fields) {\n            // selected field\n            def = type.getDefault(self, true);\n            if ('undefined' !== typeof def) {\n              doc_[piece] = def;\n              self._activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(self, true);\n          if ('undefined' !== typeof def) {\n            doc_[piece] = def;\n            self._activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  };\n\n  return doc;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "_buildDoc",
      "string": "Document.prototype._buildDoc()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "document",
        "description": "returned by mongo"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>init</p>\n\n<p>Initializes the document without setters or<br />marking modified. Called internally after a<br />document is returned from mongodb.</p>",
      "summary": "<p>init</p>",
      "body": "<p>Initializes the document without setters or<br />marking modified. Called internally after a<br />document is returned from mongodb.</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Document.prototype.init = function (doc, fn) {\n  this.isNew = false;\n\n  init(this, doc, this._doc);\n  this._storeShard();\n\n  this.emit('init');\n  if (fn) fn(null);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "init",
      "string": "Document.prototype.init()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "instance",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "- raw mongodb doc"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "doc",
        "description": "- object we are initializing"
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Init helper.</p>",
      "summary": "<p>Init helper.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function init (self, obj, doc, prefix) {\n  prefix = prefix || '';\n\n  var keys = Object.keys(obj)\n    , len = keys.length\n    , schema\n    , path\n    , i;\n\n  while (len--) {\n    i = keys[len];\n    path = prefix + i;\n    schema = self.schema.path(path);\n\n    if (!schema && obj[i] && 'Object' === obj[i].constructor.name) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n      }\n      init(self, obj[i], doc[i], path + '.');\n    } else {\n      if (obj[i] === null) {\n        doc[i] = null;\n      } else if (obj[i] !== undefined) {\n        if (schema) {\n          self.try(function(){\n            doc[i] = schema.cast(obj[i], self, true);\n          });\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      self._activePaths.init(path);\n    }\n  }\n};",
    "ctx": {
      "type": "function",
      "name": "init",
      "string": "init()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "document",
        "description": ""
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>_storeShard</p>\n\n<p>Stores the current values of the shard keys<br />for use later in the doc.save() where clause.</p>\n\n<p>Shard key values do not / are not allowed to change.</p>",
      "summary": "<p>_storeShard</p>",
      "body": "<p>Stores the current values of the shard keys<br />for use later in the doc.save() where clause.</p>\n\n<p>Shard key values do not / are not allowed to change.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype._storeShard = function _storeShard () {\n  var key = this.schema.options.shardkey;\n  if (!(key && 'Object' == key.constructor.name)) return;\n\n  var orig = this._shardval = {}\n    , paths = Object.keys(key)\n    , len = paths.length\n    , val\n\n  for (var i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({ depopulate: true })\n    } else if (null != val && val.valueOf) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "_storeShard",
      "string": "Document.prototype._storeShard()"
    }
  },
  {
    "tags": [
      {
        "type": "ignore",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Set up middleware support</p>",
      "summary": "<p>Set up middleware support</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "for (var k in hooks) {\n  Document.prototype[k] = Document[k] = hooks[k];\n}"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "doc",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Query"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>update</p>\n\n<p>Sends an update command with this document _id as<br />the query selector.</p>\n\n<h2>Example</h2>\n\n<pre><code>weirdCar.update({$inc: {wheels:1}, fn);\n</code></pre>\n\n<h2>Valid options</h2>\n\n<ul>\n<li>safe (boolean) safe mode (defaults to value set in schema (true))</li>\n<li>upsert (boolean) whether to create the doc if it doesn't match (false)</li>\n</ul>",
      "summary": "<p>update</p>",
      "body": "<p>Sends an update command with this document _id as<br />the query selector.</p>\n\n<h2>Example</h2>\n\n<pre><code>weirdCar.update({$inc: {wheels:1}, fn);\n</code></pre>\n\n<h2>Valid options</h2>\n\n<ul>\n<li>safe (boolean) safe mode (defaults to value set in schema (true))</li>\n<li>upsert (boolean) whether to create the doc if it doesn't match (false)</li>\n</ul>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.update = function update () {\n  var args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  this.constructor.update.apply(this.constructor, args);\n}",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "update",
      "string": "Document.prototype.update()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "Object"
        ],
        "name": "path",
        "description": "or object of key/vals"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value,",
        "description": "or undefined"
      },
      {
        "type": "param",
        "types": [
          "@optional"
        ],
        "name": "{Schema|String|...}",
        "description": "specify a type for \"on-the-fly\" attributes"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>set</p>\n\n<p>Sets the value of a path, or many paths.</p>\n\n<h2>Examples</h2>\n\n<pre><code>// path, value\ndoc.set(path, value)\n\n// object\ndoc.set({\n    path  : value\n  , path2 : {\n       path  : value\n    }\n})\n\n// only-the-fly cast to number\ndoc.set(path, value, Number)\n\n// only-the-fly cast to string\ndoc.set(path, value, String)\n</code></pre>",
      "summary": "<p>set</p>",
      "body": "<p>Sets the value of a path, or many paths.</p>\n\n<h2>Examples</h2>\n\n<pre><code>// path, value\ndoc.set(path, value)\n\n// object\ndoc.set({\n    path  : value\n  , path2 : {\n       path  : value\n    }\n})\n\n// only-the-fly cast to number\ndoc.set(path, value, Number)\n\n// only-the-fly cast to string\ndoc.set(path, value, String)\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.set = function (path, val, type) {\n  var constructing = true === type\n    , adhoc = type && true !== type\n    , adhocs\n\n  if (adhoc) {\n    adhocs = this._adhocPaths || (this._adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type);\n  }\n\n  if ('string' !== typeof path) {\n    // new Document({ key: val })\n\n    if (null === path || undefined === path) {\n      var _ = path;\n      path = val;\n      val = _;\n\n    } else {\n      var prefix = val\n        ? val + '.'\n        : '';\n\n      if (path instanceof Document) path = path._doc;\n\n      var keys = Object.keys(path)\n        , i = keys.length\n        , pathtype\n        , key\n\n      while (i--) {\n        key = keys[i];\n        if (null != path[key] && 'Object' === path[key].constructor.name\n          && !(this._path(prefix + key) instanceof MixedSchema)) {\n          this.set(path[key], prefix + key, constructing);\n        } else if (this._strictMode) {\n          pathtype = this.schema.pathType(prefix + key);\n          if ('real' === pathtype || 'virtual' === pathtype) {\n            this.set(prefix + key, path[key], constructing);\n          } else if ('throw' == this._strictMode) {\n            throw new Error(\"Field `\" + key + \"` is not in schema.\");\n          }\n        } else if (undefined !== path[key]) {\n          this.set(prefix + key, path[key], constructing);\n        }\n      }\n\n      return this;\n    }\n  }\n\n  // ensure _strict is honored for obj props\n  // docschema = new Schema({ path: { nest: 'string' }})\n  // doc.set('path', obj);\n  var pathType = this.schema.pathType(path);\n  if ('nested' == pathType && val && 'Object' == val.constructor.name) {\n    this.set(val, path, constructing);\n    return this;\n  }\n\n  var schema;\n  if ('adhocOrUndefined' == pathType && this._strictMode) {\n    return this;\n  } else if ('virtual' == pathType) {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this._path(path);\n  }\n\n  var parts = path.split('.')\n    , pathToMark\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (var i = 0; i < parts.length; ++i) {\n      var part = parts[i];\n      var subpath = parts.slice(0, i).concat(part).join('.');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n                                         // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) pathToMark = path;\n  }\n\n  if (!schema || null === val || undefined === val) {\n    this._set(pathToMark, path, constructing, parts, schema, val);\n    return this;\n  }\n\n  var self = this;\n\n  // if this doc is being constructed we should not\n  // trigger getters.\n  var priorVal = constructing\n    ? undefined\n    : this.get(path);\n\n  var shouldSet = this.try(function(){\n    var casted = schema.cast(val, self, false, priorVal);\n    val = schema.applySetters(casted, self);\n  });\n\n  if (shouldSet) {\n    this._set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  return this;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "set",
      "string": "Document.prototype.set()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>_set</p>\n\n<p>Handles the actual setting of the value and marking<br />the path modified if appropriate.</p>",
      "summary": "<p>_set</p>",
      "body": "<p>Handles the actual setting of the value and marking<br />the path modified if appropriate.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype._set = function (pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    this.markModified(pathToMark);\n  } else {\n\n    priorVal || (priorVal = this.get(path));\n\n    if (!this.isDirectModified(pathToMark)) {\n      if (undefined === val && !this.isSelected(path)) {\n        // special case:\n        // when a path is not selected in a query its initial\n        // value will be undefined.\n        this.markModified(pathToMark, priorVal);\n      } else if (!deepEqual(val, priorVal)) {\n        this.markModified(pathToMark, priorVal);\n      } else if (!constructing &&\n                 null != val &&\n                 path in this._activePaths.states.default &&\n                 deepEqual(val, schema.getDefault(this, constructing))) {\n        // special case:\n        // a path with a default was $unset on the server\n        // and the user is setting it to the same value again\n        this.markModified(pathToMark, priorVal);\n      }\n    }\n  }\n\n  var obj = this._doc\n    , i = 0\n    , l = parts.length\n\n  for (; i < l; i++) {\n    var next = i + 1\n      , last = next === l;\n\n    if (last) {\n      obj[parts[i]] = val;\n    } else {\n      if (obj[parts[i]] && 'Object' === obj[parts[i]].constructor.name) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        obj = obj[parts[i]] = {};\n      }\n    }\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "_set",
      "string": "Document.prototype._set()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Gets a raw value from a path (no getters)</p>",
      "summary": "<p>Gets a raw value from a path (no getters)</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Document.prototype.getValue = function (path) {\n  var parts = path.split('.')\n    , obj = this._doc\n    , part;\n\n  for (var i = 0, l = parts.length; i < l; i++) {\n    part = parts[i];\n    obj = obj.getValue\n        ? obj.getValue(part) // If we have an embedded array document member\n        : obj[part];\n    if (!obj) return obj;\n  }\n\n  return obj;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "getValue",
      "string": "Document.prototype.getValue()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Sets a raw value for a path (no casting, setters, transformations)</p>",
      "summary": "<p>Sets a raw value for a path (no casting, setters, transformations)</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Document.prototype.setValue = function (path, val) {\n  var parts = path.split('.')\n    , obj = this._doc;\n\n  for (var i = 0, len = parts.length-1; i < len; i++) {\n    obj = obj[parts[i]];\n  }\n\n  obj[parts[len]] = val;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "setValue",
      "string": "Document.prototype.setValue()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "@optional"
        ],
        "name": "{Schema|String|...}",
        "description": "specify a type for on-the-fly attributes"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>get</p>\n\n<p>Returns the value of a path.</p>\n\n<h2>Example</h2>\n\n<pre><code>// path\ndoc.get('age') // 47\n\n// dynamic casting to a string\ndoc.get('age', String) // \"47\"\n</code></pre>",
      "summary": "<p>get</p>",
      "body": "<p>Returns the value of a path.</p>\n\n<h2>Example</h2>\n\n<pre><code>// path\ndoc.get('age') // 47\n\n// dynamic casting to a string\ndoc.get('age', String) // \"47\"\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.get = function (path, type) {\n  var adhocs;\n  if (type) {\n    adhocs = this._adhocPaths || (this._adhocPaths = {});\n    adhocs[path] = Schema.interpretAsType(path, type);\n  }\n\n  var schema = this._path(path) || this.schema.virtualpath(path)\n    , pieces = path.split('.')\n    , obj = this._doc;\n\n  for (var i = 0, l = pieces.length; i < l; i++) {\n    obj = null == obj ? null : obj[pieces[i]];\n  }\n\n  if (schema) {\n    obj = schema.applyGetters(obj, this);\n  }\n\n  return obj;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "get",
      "string": "Document.prototype.get()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>_path</p>\n\n<p>Finds the path in the ad hoc type schema list or<br />in the schema's list of type schemas</p>",
      "summary": "<p>_path</p>",
      "body": "<p>Finds the path in the ad hoc type schema list or<br />in the schema's list of type schemas</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Document.prototype._path = function (path) {\n  var adhocs = this._adhocPaths\n    , adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  } else {\n    return this.schema.path(path);\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "_path",
      "string": "Document.prototype._path()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>markModified</p>\n\n<p>Marks that the path has pending changes to be written<br />to the db. Very helpful when using Mixed types.</p>\n\n<pre><code>doc.markModified('mixed.type');\n</code></pre>",
      "summary": "<p>markModified</p>",
      "body": "<p>Marks that the path has pending changes to be written<br />to the db. Very helpful when using Mixed types.</p>\n\n<pre><code>doc.markModified('mixed.type');\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.markModified = function (path) {\n  this._activePaths.modify(path);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "markModified",
      "string": "Document.prototype.markModified()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "function",
        "description": "to execute"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "scope",
        "description": "- in which to call fn"
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>try</p>\n\n<p>Catches errors that occur during execution of fn and<br />stores them to later be passed when save() is executed.</p>",
      "summary": "<p>try</p>",
      "body": "<p>Catches errors that occur during execution of fn and<br />stores them to later be passed when save() is executed.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.try = function (fn, scope) {\n  var res;\n  try {\n    fn.call(scope);\n    res = true;\n  } catch (e) {\n    this._error(e);\n    res = false;\n  }\n  return res;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "try",
      "string": "Document.prototype.try()"
    }
  },
  {
    "tags": [
      {
        "type": "returns",
        "string": "Boolean"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>modifiedPaths</p>\n\n<p>Returns the list of paths that have been modified.</p>\n\n<p>If we set <code>documents.0.title</code> to 'newTitle'<br />then <code>documents</code>, <code>documents.0</code>, and <code>documents.0.title</code><br />are modified.</p>",
      "summary": "<p>modifiedPaths</p>",
      "body": "<p>Returns the list of paths that have been modified.</p>\n\n<p>If we set <code>documents.0.title</code> to 'newTitle'<br />then <code>documents</code>, <code>documents.0</code>, and <code>documents.0.title</code><br />are modified.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.modifiedPaths = function () {\n  var directModifiedPaths = Object.keys(this._activePaths.states.modify);\n\n  return directModifiedPaths.reduce(function (list, path) {\n    var parts = path.split('.');\n    return list.concat(parts.reduce(function (chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join('.'));\n    }, []));\n  }, []);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "modifiedPaths",
      "string": "Document.prototype.modifiedPaths()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "returns",
        "string": "Boolean"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>isModified</p>\n\n<p>If no path is given, returns is this document was modified.</p>\n\n<p>If a path is given, checks if a path or any full path<br />containing path as part of its path chain has been<br />directly modified.</p>\n\n<p>e.g., if we set <code>documents.0.title</code> to 'newTitle'<br />      then we have directly modified <code>documents.0.title</code><br />      but not directly modified <code>documents</code> or <code>documents.0</code>.<br />      Nonetheless, we still say <code>documents</code> and <code>documents.0</code><br />      are modified. They just are not considered direct modified.<br />      The distinction is important because we need to distinguish<br />      between what has been directly modified and what hasn't so<br />      that we can determine the MINIMUM set of dirty data<br />      that we want to send to MongoDB on a Document save.</p>",
      "summary": "<p>isModified</p>",
      "body": "<p>If no path is given, returns is this document was modified.</p>\n\n<p>If a path is given, checks if a path or any full path<br />containing path as part of its path chain has been<br />directly modified.</p>\n\n<p>e.g., if we set <code>documents.0.title</code> to 'newTitle'<br />      then we have directly modified <code>documents.0.title</code><br />      but not directly modified <code>documents</code> or <code>documents.0</code>.<br />      Nonetheless, we still say <code>documents</code> and <code>documents.0</code><br />      are modified. They just are not considered direct modified.<br />      The distinction is important because we need to distinguish<br />      between what has been directly modified and what hasn't so<br />      that we can determine the MINIMUM set of dirty data<br />      that we want to send to MongoDB on a Document save.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.isModified = function (path) {\n  return path\n    ? !!~this.modifiedPaths().indexOf(path)\n    : this._activePaths.some('modify');\n  // TODO remove use of some()\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "isModified",
      "string": "Document.prototype.isModified()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "returns",
        "string": "Boolean"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>isDirectModified</p>\n\n<p>Checks if a path has been directly set and modified. False if<br />the path is only part of a larger path that was directly set.</p>\n\n<p>e.g., if we set <code>documents.0.title</code> to 'newTitle'<br />      then we have directly modified <code>documents.0.title</code><br />      but not directly modified <code>documents</code> or <code>documents.0</code>.<br />      Nonetheless, we still say <code>documents</code> and <code>documents.0</code><br />      are modified. They just are not considered direct modified.<br />      The distinction is important because we need to distinguish<br />      between what has been directly modified and what hasn't so<br />      that we can determine the MINIMUM set of dirty data<br />      that we want to send to MongoDB on a Document save.</p>",
      "summary": "<p>isDirectModified</p>",
      "body": "<p>Checks if a path has been directly set and modified. False if<br />the path is only part of a larger path that was directly set.</p>\n\n<p>e.g., if we set <code>documents.0.title</code> to 'newTitle'<br />      then we have directly modified <code>documents.0.title</code><br />      but not directly modified <code>documents</code> or <code>documents.0</code>.<br />      Nonetheless, we still say <code>documents</code> and <code>documents.0</code><br />      are modified. They just are not considered direct modified.<br />      The distinction is important because we need to distinguish<br />      between what has been directly modified and what hasn't so<br />      that we can determine the MINIMUM set of dirty data<br />      that we want to send to MongoDB on a Document save.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.isDirectModified = function (path) {\n  return (path in this._activePaths.states.modify);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "isDirectModified",
      "string": "Document.prototype.isDirectModified()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "returns",
        "string": "Boolean"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>isInit</p>\n\n<p>Checks if a certain path was initialized</p>",
      "summary": "<p>isInit</p>",
      "body": "<p>Checks if a certain path was initialized</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.isInit = function (path) {\n  return (path in this._activePaths.states.init);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "isInit",
      "string": "Document.prototype.isInit()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>isSelected</p>\n\n<p>Checks if a path was selected in the source query which<br />initialize this document.</p>\n\n<pre><code>Thing.findOne().select('name').exec(function (err, doc) {\n   doc.isSelected('age') // false\n   doc.isSelected('name') //true\n</code></pre>",
      "summary": "<p>isSelected</p>",
      "body": "<p>Checks if a path was selected in the source query which<br />initialize this document.</p>\n\n<pre><code>Thing.findOne().select('name').exec(function (err, doc) {\n   doc.isSelected('age') // false\n   doc.isSelected('name') //true\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.isSelected = function isSelected (path) {\n  if (this._selected) {\n\n    if ('_id' === path) {\n      return 0 !== this._selected._id;\n    }\n\n    var paths = Object.keys(this._selected)\n      , i = paths.length\n      , inclusive = false\n      , cur\n\n    if (1 === i && '_id' === paths[0]) {\n      // only _id was selected.\n      return 0 === this._selected._id;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if ('_id' == cur) continue;\n      inclusive = !! this._selected[cur];\n      break;\n    }\n\n    if (path in this._selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    var pathDot = path + '.';\n\n    while (i--) {\n      cur = paths[i];\n      if ('_id' == cur) continue;\n\n      if (0 === cur.indexOf(pathDot)) {\n        return inclusive;\n      }\n\n      if (0 === pathDot.indexOf(cur)) {\n        return inclusive;\n      }\n    }\n\n    return ! inclusive;\n  }\n\n  return true;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "isSelected",
      "string": "Document.prototype.isSelected()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "next",
        "description": "- will be called after validation is complete"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>validate</p>\n\n<p>Executes appropriate validation rules for this document.</p>",
      "summary": "<p>validate</p>",
      "body": "<p>Executes appropriate validation rules for this document.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.validate = function (next) {\n  var self = this\n\n  // only validate required fields when necessary\n  var paths = Object.keys(this._activePaths.states.require).filter(function (path) {\n    if (!self.isSelected(path) && !self.isModified(path)) return false;\n    return true;\n  });\n\n  paths = paths.concat(Object.keys(this._activePaths.states.init));\n  paths = paths.concat(Object.keys(this._activePaths.states.modify));\n\n  if (0 === paths.length) {\n    complete();\n    return this;\n  }\n\n  var validating = {}\n    , total = 0;\n\n  paths.forEach(validatePath);\n  return this;\n\n  function validatePath (path) {\n    if (validating[path]) return;\n\n    validating[path] = true;\n    total++;\n\n    process.nextTick(function(){\n      var p = self.schema.path(path);\n      if (!p) return --total || complete();\n\n      p.doValidate(self.getValue(path), function (err) {\n        if (err) self.invalidate(path, err);\n        --total || complete();\n      }, self);\n    });\n  }\n\n  function complete () {\n    next(self._validationError);\n    self._validationError = null;\n  }\n\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "validate",
      "string": "Document.prototype.validate()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "of the field to invalidate"
      },
      {
        "type": "param",
        "types": [
          "String",
          "Error"
        ],
        "name": "error",
        "description": "of the path."
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>invalidate</p>\n\n<p>Marks a path as invalid, causing validation to fail.</p>",
      "summary": "<p>invalidate</p>",
      "body": "<p>Marks a path as invalid, causing validation to fail.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.invalidate = function (path, err) {\n  if (!this._validationError) {\n    this._validationError = new ValidationError(this);\n  }\n\n  if (!err || 'string' === typeof err) {\n    err = new ValidatorError(path, err);\n  }\n\n  this._validationError.errors[path] = err;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "invalidate",
      "string": "Document.prototype.invalidate()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      },
      {
        "type": "return",
        "types": [
          "this"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>_reset</p>\n\n<p>Resets the internal atomics and modified state of this document.</p>",
      "summary": "<p>_reset</p>",
      "body": "<p>Resets the internal atomics and modified state of this document.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype._reset = function reset () {\n  var self = this;\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  this._activePaths\n  .map('init', 'modify', function (i) {\n    return self.getValue(i);\n  })\n  .filter(function (val) {\n    return (val && val instanceof DocumentArray && val.length);\n  })\n  .forEach(function (array) {\n    array.forEach(function (doc) {\n      doc._reset();\n    });\n  });\n\n  // clear atomics\n  this._dirty().forEach(function (dirt) {\n    var type = dirt.value;\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear 'modify'('dirty') cache\n  this._activePaths.clear('modify');\n  var self = this;\n  this.schema.requiredPaths().forEach(function (path) {\n    self._activePaths.require(path);\n  });\n\n  return this;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "_reset",
      "string": "Document.prototype._reset()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>_dirty</p>\n\n<p>Returns this documents dirty paths / vals.</p>",
      "summary": "<p>_dirty</p>",
      "body": "<p>Returns this documents dirty paths / vals.</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Document.prototype._dirty = function _dirty () {\n  var self = this;\n\n  var all = this._activePaths.map('modify', function (path) {\n    return { path: path\n           , value: self.getValue(path)\n           , schema: self._path(path) };\n  });\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function (a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  var minimal = []\n    , lastPath\n    , top;\n\n  all.forEach(function (item, i) {\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + '.';\n      minimal.push(item);\n      top = item;\n    } else {\n      if (!(item.value && top.value)) return;\n\n      // special case for top level MongooseArrays\n      if (top.value._atomics && top.value.hasAtomics()) {\n        // and the item is not a MongooseArray\n        if (!(item.value._atomics && item.value.hasAtomics())) {\n          // theres a sub path of top being explicitly set.\n          // the only way to honor all of their modifications\n          // is through a $set of entire array.\n          // change top to a $set op\n          top.value._atomics = {};\n          top.value._atomics.$set = top.value;\n        }\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "_dirty",
      "string": "Document.prototype._dirty()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Compiles schemas.</p>",
      "summary": "<p>Compiles schemas.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function compile (tree, proto, prefix) {\n  var keys = Object.keys(tree)\n    , i = keys.length\n    , limb\n    , key;\n\n  while (i--) {\n    key = keys[i];\n    limb = tree[key];\n\n    define(key\n        , (('Object' === limb.constructor.name\n               && Object.keys(limb).length)\n               && (!limb.type || limb.type.type)\n               ? limb\n               : null)\n        , proto\n        , prefix\n        , keys);\n  }\n};",
    "ctx": {
      "type": "function",
      "name": "compile",
      "string": "compile()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Defines the accessor named prop on the incoming prototype.</p>",
      "summary": "<p>Defines the accessor named prop on the incoming prototype.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function define (prop, subprops, prototype, prefix, keys) {\n  var prefix = prefix || ''\n    , path = (prefix ? prefix + '.' : '') + prop;\n\n  if (subprops) {\n\n    Object.defineProperty(prototype, prop, {\n        enumerable: true\n      , get: function () {\n          if (!this.__getters)\n            this.__getters = {};\n\n          if (!this.__getters[path]) {\n            var nested = Object.create(this);\n\n            // save scope for nested getters/setters\n            if (!prefix) nested._scope = this;\n\n            // shadow inherited getters from sub-objects so\n            // thing.nested.nested.nested... doesn't occur (gh-366)\n            var i = 0\n              , len = keys.length;\n\n            for (; i < len; ++i) {\n              // over-write the parents getter without triggering it\n              Object.defineProperty(nested, keys[i], {\n                  enumerable: false   // It doesn't show up.\n                , writable: true      // We can set it later.\n                , configurable: true  // We can Object.defineProperty again.\n                , value: undefined    // It shadows its parent.\n              });\n            }\n\n            nested.toObject = function () {\n              return this.get(path);\n            };\n\n            compile(subprops, nested, path);\n            this.__getters[path] = nested;\n          }\n\n          return this.__getters[path];\n        }\n      , set: function (v) {\n          return this.set(v, path);\n        }\n    });\n\n  } else {\n\n    Object.defineProperty(prototype, prop, {\n        enumerable: true\n      , get: function ( ) { return this.get.call(this._scope || this, path); }\n      , set: function (v) { return this.set.call(this._scope || this, path, v); }\n    });\n  }\n};",
    "ctx": {
      "type": "function",
      "name": "define",
      "string": "define()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>_setSchema</p>\n\n<p>Assigns/compiles <code>schema</code> into this documents<br />prototype.</p>",
      "summary": "<p>_setSchema</p>",
      "body": "<p>Assigns/compiles <code>schema</code> into this documents<br />prototype.</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Document.prototype._setSchema = function (schema) {\n  compile(schema.tree, this);\n  this.schema = schema;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "_setSchema",
      "string": "Document.prototype._setSchema()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>_registerHooks</p>\n\n<p>Register default hooks</p>",
      "summary": "<p>_registerHooks</p>",
      "body": "<p>Register default hooks</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Document.prototype._registerHooks = function _registerHooks () {\n  if (!this.save) return;\n\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  this.pre('save', function (next) {\n    // we keep the error semaphore to make sure we don't\n    // call `save` unnecessarily (we only need 1 error)\n    var subdocs = 0\n      , error = false\n      , self = this;\n\n    // check for DocumentArrays\n    var arrays = this._activePaths\n    .map('init', 'modify', function (i) {\n      return self.getValue(i);\n    })\n    .filter(function (val) {\n      return (val && val instanceof DocumentArray && val.length);\n    });\n\n    if (!arrays.length)\n      return next();\n\n    arrays.forEach(function (array) {\n      subdocs += array.length;\n      array.forEach(function (value) {\n        if (!error)\n          value.save(function (err) {\n            if (!error) {\n              if (err) {\n                error = true;\n                next(err);\n              } else\n                --subdocs || next();\n            }\n          });\n      });\n    });\n  }, function (err) {\n    this.db.emit('error', err);\n  }).pre('save', function checkForExistingErrors (next) {\n    // if any doc.set() calls failed\n    if (this._saveError) {\n      next(this._saveError);\n      this._saveError = null;\n    } else {\n      next();\n    }\n  }).pre('save', function validation (next) {\n    return this.validate(next);\n  });\n\n  // add user defined queues\n  this._doQueue();\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "_registerHooks",
      "string": "Document.prototype._registerHooks()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Error"
        ],
        "name": "error",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>_error</p>\n\n<p>Registers an error</p>",
      "summary": "<p>_error</p>",
      "body": "<p>Registers an error</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Document.prototype._error = function (err) {\n  this._saveError = err;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "_error",
      "string": "Document.prototype._error()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>_doQueue</p>\n\n<p>Executes methods queued from the Schema definition</p>",
      "summary": "<p>_doQueue</p>",
      "body": "<p>Executes methods queued from the Schema definition</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Document.prototype._doQueue = function () {\n  var q = this.schema && this.schema.callQueue;\n  if (q) {\n    for (var i = 0, l = q.length; i < l; i++) {\n      this[q[i][0]].apply(this, q[i][1]);\n    }\n  }\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "_doQueue",
      "string": "Document.prototype._doQueue()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "optional",
        "description": "options"
      },
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": "plain object"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>toObject</p>\n\n<p>Converts this document into a plain javascript object<br />representation.</p>\n\n<h2>Available options</h2>\n\n<ul>\n<li>getters: apply all getters (path and virtual getters)</li>\n<li>virtuals: apply virtual getters (can override <code>getters</code> option)</li>\n<li>minimize: remove empty objects (defaults to true)</li>\n</ul>\n\n<h2>Example of only applying path getters</h2>\n\n<pre><code>doc.toObject({ getters: true, virtuals: false })\n</code></pre>\n\n<h2>Example of only applying virtual getters</h2>\n\n<pre><code>doc.toObject({ virtuals: true })\n</code></pre>\n\n<h2>Example of applying both path and virtual getters</h2>\n\n<pre><code>doc.toObject({ getters: true })\n</code></pre>",
      "summary": "<p>toObject</p>",
      "body": "<p>Converts this document into a plain javascript object<br />representation.</p>\n\n<h2>Available options</h2>\n\n<ul>\n<li>getters: apply all getters (path and virtual getters)</li>\n<li>virtuals: apply virtual getters (can override <code>getters</code> option)</li>\n<li>minimize: remove empty objects (defaults to true)</li>\n</ul>\n\n<h2>Example of only applying path getters</h2>\n\n<pre><code>doc.toObject({ getters: true, virtuals: false })\n</code></pre>\n\n<h2>Example of only applying virtual getters</h2>\n\n<pre><code>doc.toObject({ virtuals: true })\n</code></pre>\n\n<h2>Example of applying both path and virtual getters</h2>\n\n<pre><code>doc.toObject({ getters: true })\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.toObject = function (options) {\n  // When internally saving this document we always pass options,\n  // bypassing the custom schema options.\n  if (!(options && 'Object' == options.constructor.name)) {\n    options = this.schema.options.toObject\n      ? clone(this.schema.options.toObject)\n      : {};\n  }\n\n  ;('minimize' in options) || (options.minimize = this.schema.options.minimize);\n\n  var ret = clone(this._doc, options);\n\n  if (options.virtuals || options.getters && false !== options.virtuals) {\n    applyGetters(this, ret, 'virtuals', options);\n  }\n\n  if (options.getters) {\n    applyGetters(this, ret, 'paths', options);\n  }\n\n  return ret;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "toObject",
      "string": "Document.prototype.toObject()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "self",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "json",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "either",
        "description": "`virtuals` or `paths`"
      },
      {
        "type": "return",
        "types": [
          "json"
        ],
        "description": ""
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Applies virtuals properties to <code>json</code>.</p>",
      "summary": "<p>Applies virtuals properties to <code>json</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function applyGetters (self, json, type, options) {\n  var schema = self.schema\n    , paths = Object.keys(schema[type])\n    , i = paths.length\n    , path\n\n  while (i--) {\n    path = paths[i];\n\n    var parts = path.split('.')\n      , plen = parts.length\n      , last = plen - 1\n      , branch = json\n      , part\n\n    for (var ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      if (ii === last) {\n        branch[part] = clone(self.get(path), options);\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n    }\n  }\n\n  return json;\n}",
    "ctx": {
      "type": "function",
      "name": "applyGetters",
      "string": "applyGetters()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>toJSON</p>\n\n<p>The return value of this method is used in calls<br />to JSON.stringify(doc).</p>",
      "summary": "<p>toJSON</p>",
      "body": "<p>The return value of this method is used in calls<br />to JSON.stringify(doc).</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.toJSON = function (options) {\n  // check for object type since an array of documents\n  // being stringified passes array indexes instead\n  // of options objects. JSON.stringify([doc, doc])\n  if (!(options && 'Object' == options.constructor.name)) {\n    options = this.schema.options.toJSON\n      ? clone(this.schema.options.toJSON)\n      : {};\n  }\n  options.json = true;\n  return this.toObject(options);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "toJSON",
      "string": "Document.prototype.toJSON()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Helpers for console.log</p>",
      "summary": "<p>Helpers for console.log</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.toString =\nDocument.prototype.inspect = function (options) {\n  var opts = options && 'Object' == options.constructor.name\n    ? options\n    : undefined\n  return inspect(this.toObject(opts));\n};"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "doc",
        "description": "to compare to"
      },
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>equals</p>\n\n<p>Returns true if the Document stores the same data as doc.</p>",
      "summary": "<p>equals</p>",
      "body": "<p>Returns true if the Document stores the same data as doc.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Document.prototype.equals = function (doc) {\n  var tid = this.get('_id');\n  var docid = doc.get('_id');\n  return tid.equals\n    ? tid.equals(docid)\n    : tid === docid;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Document",
      "name": "equals",
      "string": "Document.prototype.equals()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Document.ValidationError = ValidationError;\nmodule.exports = exports = Document;\nexports.Error = DocumentError;",
    "ctx": {
      "type": "property",
      "receiver": "Document",
      "name": "ValidationError",
      "value": "ValidationError",
      "string": "Document.ValidationError"
    }
  }
]
### lib/drivers/node-mongodb-native/binary.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var Binary = require('mongodb').BSONPure.Binary;\n\nmodule.exports = exports = Binary;",
    "ctx": {
      "type": "declaration",
      "name": "Binary",
      "value": "require('mongodb').BSONPure.Binary",
      "string": "Binary"
    }
  }
]
### lib/drivers/node-mongodb-native/collection.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var Collection = require('../../collection')\n  , NativeCollection = require('mongodb').Collection\n  , STATES = require('../../connectionstate')\n  , utils = require('../../utils')\n  , assert = require('assert')",
    "ctx": {
      "type": "declaration",
      "name": "Collection",
      "value": "require('../../collection')",
      "string": "Collection"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Native collection</p>",
      "summary": "<p>Native collection</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function MongooseCollection () {\n  this.collection = null;\n  Collection.apply(this, arguments);\n};",
    "ctx": {
      "type": "function",
      "name": "MongooseCollection",
      "string": "MongooseCollection()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherit from abstract Collection.</p>",
      "summary": "<p>Inherit from abstract Collection.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "MongooseCollection.prototype.__proto__ = Collection.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "MongooseCollection",
      "name": "__proto__",
      "value": "Collection.prototype",
      "string": "MongooseCollection.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>onOpen</p>\n\n<p>Called when the connection opens.</p>",
      "summary": "<p>onOpen</p>",
      "body": "<p>Called when the connection opens.</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "MongooseCollection.prototype.onOpen = function () {\n  var self = this;\n\n  if (this.collection) {\n    return Collection.prototype.onOpen.call(self);\n  }\n\n  if (!self.opts.size) {\n    // non-capped\n    return self.conn.db.collection(self.name, callback);\n  }\n\n  // capped\n  return self.conn.db.collection(self.name, function (err, c) {\n    if (err) return callback(err);\n\n    // discover if this collection exists and if it is capped\n    c.options(function (err, exists) {\n      if (err) return callback(err);\n\n      if (exists) {\n        if (exists.capped) {\n          callback(null, c);\n        } else {\n          var msg = 'A non-capped collection exists with this name.\\n\\n'\n                  + ' To use this collection as a capped collection, please '\n                  + 'first convert it.\\n'\n                  + ' http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-Convertingacollectiontocapped'\n          err = new Error(msg);\n          callback(err);\n        }\n      } else {\n        // create\n        var opts = utils.clone(self.opts);\n        opts.capped = true;\n        self.conn.db.createCollection(self.name, opts, callback);\n      }\n    });\n  });\n\n  function callback (err, collection) {\n    if (err) {\n      // likely a strict mode error\n      self.conn.emit('error', err);\n    } else {\n      self.collection = collection;\n      Collection.prototype.onOpen.call(self);\n    }\n  };\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseCollection",
      "name": "onOpen",
      "string": "MongooseCollection.prototype.onOpen()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>onClose</p>\n\n<p>Called when the connection closes</p>",
      "summary": "<p>onClose</p>",
      "body": "<p>Called when the connection closes</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "MongooseCollection.prototype.onClose = function () {\n  Collection.prototype.onClose.call(this);\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseCollection",
      "name": "onClose",
      "string": "MongooseCollection.prototype.onClose()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Copy the collection methods and make them subject to queues</p>",
      "summary": "<p>Copy the collection methods and make them subject to queues</p>",
      "body": ""
    },
    "ignore": true,
    "code": "for (var i in NativeCollection.prototype)\n  (function(i){\n    MongooseCollection.prototype[i] = function () {\n      if (this.buffer) {\n        this.addQueue(i, arguments);\n        return;\n      }\n\n      var collection = this.collection\n        , args = arguments\n        , self = this\n        , debug = self.conn.base.options.debug;\n\n      if (debug) {\n        if ('function' === typeof debug) {\n          debug.apply(debug\n            , [self.name, i].concat(utils.args(args, 0, args.length-1)));\n        } else {\n          console.error('\\x1B[0;36mMongoose:\\x1B[0m %s.%s(%s) %s %s %s'\n            , self.name\n            , i\n            , print(args[0])\n            , print(args[1])\n            , print(args[2])\n            , print(args[3]))\n        }\n      }\n\n      collection[i].apply(collection, args);\n    };\n  })(i);"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Debug print helper</p>",
      "summary": "<p>Debug print helper</p>",
      "body": ""
    },
    "ignore": true,
    "code": "function print (arg) {\n  var type = typeof arg;\n  if ('function' === type || 'undefined' === type) return '';\n  return format(arg);\n}",
    "ctx": {
      "type": "function",
      "name": "print",
      "string": "print()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Debug print helper</p>",
      "summary": "<p>Debug print helper</p>",
      "body": ""
    },
    "ignore": true,
    "code": "function format (obj, sub) {\n  var x = utils.clone(obj);\n  if (x) {\n    if ('Binary' === x.constructor.name) {\n      x = '[object Buffer]';\n    } else if ('Object' === x.constructor.name) {\n      var keys = Object.keys(x)\n        , i = keys.length\n        , key\n      while (i--) {\n        key = keys[i];\n        if (x[key]) {\n          if ('Binary' === x[key].constructor.name) {\n            x[key] = '[object Buffer]';\n          } else if ('Object' === x[key].constructor.name) {\n            x[key] = format(x[key], true);\n          } else if (Array.isArray(x[key])) {\n            x[key] = x[key].map(function (o) {\n              return format(o, true)\n            });\n          }\n        }\n      }\n    }\n    if (sub) return x;\n  }\n\n  return require('util')\n    .inspect(x, false, 10, true)\n    .replace(/\\n/g, '')\n    .replace(/\\s{2,}/g, ' ')\n}",
    "ctx": {
      "type": "function",
      "name": "format",
      "string": "format()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      }
    ],
    "description": {
      "full": "<p>getIndexes</p>\n\n<p>Retreives information about this collections<br />indexes.</p>",
      "summary": "<p>getIndexes</p>",
      "body": "<p>Retreives information about this collections<br />indexes.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseCollection.prototype.getIndexes =\nMongooseCollection.prototype.indexInformation;"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = MongooseCollection;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "MongooseCollection",
      "string": "module.exports"
    }
  }
]
### lib/drivers/node-mongodb-native/connection.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var Connection = require('../../connection')\n  , mongo = require('mongodb')\n  , Server = mongo.Server\n  , ReplSetServers = mongo.ReplSetServers;",
    "ctx": {
      "type": "declaration",
      "name": "Connection",
      "value": "require('../../connection')",
      "string": "Connection"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Connection for mongodb-native driver</p>",
      "summary": "<p>Connection for mongodb-native driver</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function NativeConnection() {\n  Connection.apply(this, arguments);\n};",
    "ctx": {
      "type": "function",
      "name": "NativeConnection",
      "string": "NativeConnection()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from Connection.</p>",
      "summary": "<p>Inherits from Connection.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "NativeConnection.prototype.__proto__ = Connection.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "NativeConnection",
      "name": "__proto__",
      "value": "Connection.prototype",
      "string": "NativeConnection.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>doOpen</p>\n\n<p>Opens the connection.</p>\n\n<h2>Example server options</h2>\n\n<p>auto_reconnect (default: false)<br />   poolSize (default: 1)</p>\n\n<h2>Example db options</h2>\n\n<p>pk - custom primary key factory to generate <code>_id</code> values</p>\n\n<p>Some of these options may break Mongoose.<br />Use at your own risk. You have been warned.</p>",
      "summary": "<p>doOpen</p>",
      "body": "<p>Opens the connection.</p>\n\n<h2>Example server options</h2>\n\n<p>auto_reconnect (default: false)<br />   poolSize (default: 1)</p>\n\n<h2>Example db options</h2>\n\n<p>pk - custom primary key factory to generate <code>_id</code> values</p>\n\n<p>Some of these options may break Mongoose.<br />Use at your own risk. You have been warned.</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "NativeConnection.prototype.doOpen = function (fn) {\n  var server;\n\n  if (!this.db) {\n    server = new mongo.Server(this.host, Number(this.port), this.options.server);\n    this.db = new mongo.Db(this.name, server, this.options.db);\n  }\n\n  this.db.open(fn);\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "NativeConnection",
      "name": "doOpen",
      "string": "NativeConnection.prototype.doOpen()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>doOpenSet</p>\n\n<p>Opens a set connection</p>\n\n<p>See description of doOpen for server options. In this case options.replset<br />is also passed to ReplSetServers. Some additional options there are</p>\n\n<pre><code>reconnectWait (default: 1000)\nretries (default: 30)\nrs_name (default: false)\nread_secondary (default: false) Are reads allowed from secondaries?\n</code></pre>",
      "summary": "<p>doOpenSet</p>",
      "body": "<p>Opens a set connection</p>\n\n<p>See description of doOpen for server options. In this case options.replset<br />is also passed to ReplSetServers. Some additional options there are</p>\n\n<pre><code>reconnectWait (default: 1000)\nretries (default: 30)\nrs_name (default: false)\nread_secondary (default: false) Are reads allowed from secondaries?\n</code></pre>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "NativeConnection.prototype.doOpenSet = function (fn) {\n  if (!this.db) {\n    var servers = []\n      , ports = this.port\n      , self = this\n\n    this.host.forEach(function (host, i) {\n      servers.push(new mongo.Server(host, Number(ports[i]), self.options.server));\n    });\n\n    var server = new ReplSetServers(servers, this.options.replset);\n    this.db = new mongo.Db(this.name, server, this.options.db);\n  }\n\n  this.db.open(fn);\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "NativeConnection",
      "name": "doOpenSet",
      "string": "NativeConnection.prototype.doOpenSet()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>doClose</p>\n\n<p>Closes the connection</p>",
      "summary": "<p>doClose</p>",
      "body": "<p>Closes the connection</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "NativeConnection.prototype.doClose = function (fn) {\n  this.db.close();\n  if (fn) fn();\n  return this;\n}",
    "ctx": {
      "type": "method",
      "constructor": "NativeConnection",
      "name": "doClose",
      "string": "NativeConnection.prototype.doClose()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "module.exports = NativeConnection;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "NativeConnection",
      "string": "module.exports"
    }
  }
]
### lib/drivers/node-mongodb-native/objectid.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var ObjectId = require('mongodb').BSONPure.ObjectID;",
    "ctx": {
      "type": "declaration",
      "name": "ObjectId",
      "value": "require('mongodb').BSONPure.ObjectID",
      "string": "ObjectId"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Constructor export</p>",
      "summary": "<p>Constructor export</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var ObjectIdToString = ObjectId.toString.bind(ObjectId);\n\nmodule.exports = exports = ObjectId;",
    "ctx": {
      "type": "declaration",
      "name": "ObjectIdToString",
      "value": "ObjectId.toString.bind(ObjectId)",
      "string": "ObjectIdToString"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "hex",
        "description": "string or ObjectId"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Creates an ObjectID for this driver</p>",
      "summary": "<p>Creates an ObjectID for this driver</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "exports.fromString = function(str){\n  // patch native driver bug in V0.9.6.4\n  if (!('string' === typeof str && 24 === str.length)) {\n    throw new Error(\"Invalid ObjectId\");\n  }\n\n  return ObjectId.createFromHexString(str);\n};",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "fromString",
      "string": "exports.fromString()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "ObjectId"
        ],
        "name": "-native",
        "description": "objectid"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Gets an ObjectId and converts it to string.</p>",
      "summary": "<p>Gets an ObjectId and converts it to string.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "exports.toString = function(oid){\n  if (!arguments.length) return ObjectIdToString();\n  return oid.toHexString();\n};",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "toString",
      "string": "exports.toString()"
    }
  }
]
### lib/error.js
[
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Mongoose error</p>",
      "summary": "<p>Mongoose error</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function MongooseError (msg) {\n  Error.call(this);\n  Error.captureStackTrace(this, arguments.callee);\n  this.message = msg;\n  this.name = 'MongooseError';\n};",
    "ctx": {
      "type": "function",
      "name": "MongooseError",
      "string": "MongooseError()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from Error.</p>",
      "summary": "<p>Inherits from Error.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "MongooseError.prototype.__proto__ = Error.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "MongooseError",
      "name": "__proto__",
      "value": "Error.prototype",
      "string": "MongooseError.prototype__proto__"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = MongooseError;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "MongooseError",
      "string": "module.exports"
    }
  }
]
### lib/errors/document.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module requirements</p>",
      "summary": "<p>Module requirements</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var MongooseError = require('../error')",
    "ctx": {
      "type": "declaration",
      "name": "MongooseError",
      "value": "require('../error')",
      "string": "MongooseError"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "text"
        ],
        "name": "",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Document Error</p>",
      "summary": "<p>Document Error</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function DocumentError () {\n  MongooseError.call(this, msg);\n  Error.captureStackTrace(this, arguments.callee);\n  this.name = 'DocumentError';\n};",
    "ctx": {
      "type": "function",
      "name": "DocumentError",
      "string": "DocumentError()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from MongooseError.</p>",
      "summary": "<p>Inherits from MongooseError.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "DocumentError.prototype.__proto__ = MongooseError.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "DocumentError",
      "name": "__proto__",
      "value": "MongooseError.prototype",
      "string": "DocumentError.prototype__proto__"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = exports = DocumentError;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "exports = DocumentError",
      "string": "module.exports"
    }
  }
]
### lib/errors/validation.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module requirements</p>",
      "summary": "<p>Module requirements</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var MongooseError = require('../error')",
    "ctx": {
      "type": "declaration",
      "name": "MongooseError",
      "value": "require('../error')",
      "string": "MongooseError"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Document Validation Error</p>",
      "summary": "<p>Document Validation Error</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function ValidationError (instance) {\n  MongooseError.call(this, \"Validation failed\");\n  Error.captureStackTrace(this, arguments.callee);\n  this.name = 'ValidationError';\n  this.errors = instance.errors = {};\n};\n\nValidationError.prototype.toString = function () {\n  return this.name + ': ' + Object.keys(this.errors).map(function (key) {\n    return String(this.errors[key]);\n  }, this).join(', ');\n};",
    "ctx": {
      "type": "function",
      "name": "ValidationError",
      "string": "ValidationError()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from MongooseError.</p>",
      "summary": "<p>Inherits from MongooseError.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "ValidationError.prototype.__proto__ = MongooseError.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "ValidationError",
      "name": "__proto__",
      "value": "MongooseError.prototype",
      "string": "ValidationError.prototype__proto__"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports</p>",
      "summary": "<p>Module exports</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = exports = ValidationError;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "exports = ValidationError",
      "string": "module.exports"
    }
  }
]
### lib/index.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var Schema = require('./schema')\n  , SchemaType = require('./schematype')\n  , VirtualType = require('./virtualtype')\n  , SchemaTypes = Schema.Types\n  , SchemaDefaults = require('./schemadefault')\n  , Types = require('./types')\n  , Query = require('./query')\n  , Promise = require('./promise')\n  , Model = require('./model')\n  , Document = require('./document')\n  , utils = require('./utils')\n  , format = utils.toCollectionName;",
    "ctx": {
      "type": "declaration",
      "name": "Schema",
      "value": "require('./schema')",
      "string": "Schema"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Mongoose constructor. Most apps will only use one instance.</p>",
      "summary": "<p>Mongoose constructor. Most apps will only use one instance.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function Mongoose () {\n  this.connections = [];\n  this.plugins = [];\n  this.models = {};\n  this.modelSchemas = {};\n  this.options = {};\n  this.createConnection(); // default connection\n};",
    "ctx": {
      "type": "function",
      "name": "Mongoose",
      "string": "Mongoose()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "value",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets/gets mongoose options</p>\n\n<h2>Examples</h2>\n\n<p>mongoose.set('test') // returns the 'test' value<br />   mongoose.set('test', value) // sets the 'test' value</p>",
      "summary": "<p>Sets/gets mongoose options</p>",
      "body": "<h2>Examples</h2>\n\n<p>mongoose.set('test') // returns the 'test' value<br />   mongoose.set('test', value) // sets the 'test' value</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Mongoose.prototype.set =\nMongoose.prototype.get = function (key, value) {\n  if (arguments.length == 1)\n    return this.options[key];\n  this.options[key] = value;\n  return this;\n};"
  },
  {
    "tags": [
      {
        "type": "ignore",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>ReplSet connection string check.</p>",
      "summary": "<p>ReplSet connection string check.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var rgxReplSet = /^.+,.+$/;",
    "ctx": {
      "type": "declaration",
      "name": "rgxReplSet",
      "value": "/^.+,.+$/",
      "string": "rgxReplSet"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "mongodb://",
        "description": "URI"
      },
      {
        "type": "return",
        "types": [
          "Connection"
        ],
        "description": "the created Connection object"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Creates a Connection instance.</p>\n\n<h2>Examples</h2>\n\n<p>// with mongodb:// URI<br />   db = mongoose.createConnection('mongodb://localhost:port/database');</p>\n\n<p>// with [host, database_name[, port] signature <br />   db = mongoose.createConnection('localhost', 'database', port)</p>\n\n<p>// initialize now, connect later<br />   db = mongoose.createConnection();<br />   db.open('localhost', 'database', port);</p>",
      "summary": "<p>Creates a Connection instance.</p>",
      "body": "<h2>Examples</h2>\n\n<p>// with mongodb:// URI<br />   db = mongoose.createConnection('mongodb://localhost:port/database');</p>\n\n<p>// with [host, database_name[, port] signature <br />   db = mongoose.createConnection('localhost', 'database', port)</p>\n\n<p>// initialize now, connect later<br />   db = mongoose.createConnection();<br />   db.open('localhost', 'database', port);</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Mongoose.prototype.createConnection = function () {\n  var conn = new Connection(this);\n  this.connections.push(conn);\n\n  if (arguments.length) {\n    if (rgxReplSet.test(arguments[0])) {\n      conn.openSet.apply(conn, arguments);\n    } else {\n      conn.open.apply(conn, arguments);\n    }\n  }\n\n  return conn;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Mongoose",
      "name": "createConnection",
      "string": "Mongoose.prototype.createConnection()"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "local": "{Mongoose#createConnection}",
        "visibility": "{Mongoose#createConnection}"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Connects the default mongoose connection</p>",
      "summary": "<p>Connects the default mongoose connection</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Mongoose.prototype.connect = function () {\n  var conn = this.connection;\n\n  if (rgxReplSet.test(arguments[0])) {\n    conn.openSet.apply(conn, arguments);\n  } else {\n    conn.open.apply(conn, arguments);\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Mongoose",
      "name": "connect",
      "string": "Mongoose.prototype.connect()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "optional",
        "description": "callback"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Disconnects from all connections.</p>",
      "summary": "<p>Disconnects from all connections.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Mongoose.prototype.disconnect = function (fn) {\n  var count = this.connections.length\n    , error\n\n  this.connections.forEach(function(conn){\n    conn.close(function(err){\n      if (error) return;\n\n      if (err) {\n        error = err;\n        if (fn) return fn(err);\n        throw err;\n      }\n\n      if (fn)\n        --count || fn();\n    });\n  });\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Mongoose",
      "name": "disconnect",
      "string": "Mongoose.prototype.disconnect()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "model",
        "description": "name"
      },
      {
        "type": "param",
        "types": [
          "Schema"
        ],
        "name": "schema",
        "description": "object"
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "collection",
        "description": "name (optional, induced from model name)"
      },
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "whether",
        "description": "to skip initialization (defaults to false)"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Defines a model or retrieves it</p>",
      "summary": "<p>Defines a model or retrieves it</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Mongoose.prototype.model = function (name, schema, collection, skipInit) {\n  // normalize collection\n  if (!(schema instanceof Schema)) {\n    collection = schema;\n    schema = false;\n  }\n\n  if ('boolean' === typeof collection) {\n    skipInit = collection;\n    collection = null;\n  }\n\n  // look up models for the collection\n  if (!this.modelSchemas[name]) {\n    if (!schema && name in SchemaDefaults) {\n      schema = SchemaDefaults[name];\n    }\n\n    if (schema) {\n      this.modelSchemas[name] = schema;\n      for (var i = 0, l = this.plugins.length; i < l; i++) {\n        schema.plugin(this.plugins[i][0], this.plugins[i][1]);\n      }\n    } else {\n      throw new Error('Schema hasn\\'t been registered for model \"' + name + '\".\\n'\n                    + 'Use mongoose.model(name, schema)');\n    }\n  }\n\n  if (!this.models[name]) {\n    schema || (schema = this.modelSchemas[name]);\n    collection || (collection = schema.set('collection') || format(name));\n\n    var model = Model.compile(name\n                        , this.modelSchemas[name]\n                        , collection\n                        , this.connection\n                        , this);\n\n    if (!skipInit) model.init();\n\n    this.models[name] = model;\n  }\n\n  return this.models[name];\n};",
    "ctx": {
      "type": "method",
      "constructor": "Mongoose",
      "name": "model",
      "string": "Mongoose.prototype.model()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "plugin",
        "description": "callback"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Declares a plugin executed on Schemas. Equivalent to calling <code>.plugin(fn)</code><br />on each Schema you create.</p>",
      "summary": "<p>Declares a plugin executed on Schemas. Equivalent to calling <code>.plugin(fn)</code><br />on each Schema you create.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Mongoose.prototype.plugin = function (fn, opts) {\n  this.plugins.push([fn, opts]);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Mongoose",
      "name": "plugin",
      "string": "Mongoose.prototype.plugin()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Default connection</p>",
      "summary": "<p>Default connection</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Mongoose.prototype.__defineGetter__('connection', function(){\n  return this.connections[0];\n});"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Driver depentend APIs</p>",
      "summary": "<p>Driver depentend APIs</p>",
      "body": ""
    },
    "ignore": false,
    "code": "var driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native';",
    "ctx": {
      "type": "declaration",
      "name": "driver",
      "value": "global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native'",
      "string": "driver"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Connection</p>",
      "summary": "<p>Connection</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var Connection = require(driver + '/connection');",
    "ctx": {
      "type": "declaration",
      "name": "Connection",
      "value": "require(driver + '/connection')",
      "string": "Connection"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Collection</p>",
      "summary": "<p>Collection</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var Collection = require(driver + '/collection');",
    "ctx": {
      "type": "declaration",
      "name": "Collection",
      "value": "require(driver + '/collection')",
      "string": "Collection"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Export default singleton.</p>",
      "summary": "<p>Export default singleton.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "module.exports = exports = new Mongoose();",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "exports = new Mongoose()",
      "string": "module.exports"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Collection</p>",
      "summary": "<p>Collection</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.Collection = Collection;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "Collection",
      "value": "Collection",
      "string": "exports.Collection"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Connection</p>",
      "summary": "<p>Connection</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.Connection = Connection;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "Connection",
      "value": "Connection",
      "string": "exports.Connection"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Exports Mongoose version</p>",
      "summary": "<p>Exports Mongoose version</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.version = JSON.parse(\n  require('fs').readFileSync(__dirname + '/../package.json', 'utf8')\n).version;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "version",
      "value": "JSON.parse(",
      "string": "exports.version"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Export Mongoose constructor</p>",
      "summary": "<p>Export Mongoose constructor</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.Mongoose = Mongoose;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "Mongoose",
      "value": "Mongoose",
      "string": "exports.Mongoose"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Export Schema constructor</p>",
      "summary": "<p>Export Schema constructor</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.Schema = Schema;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "Schema",
      "value": "Schema",
      "string": "exports.Schema"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Export SchemaType constructor.</p>",
      "summary": "<p>Export SchemaType constructor.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.SchemaType = SchemaType;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "SchemaType",
      "value": "SchemaType",
      "string": "exports.SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Export VirtualType constructor.</p>",
      "summary": "<p>Export VirtualType constructor.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.VirtualType = VirtualType;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "VirtualType",
      "value": "VirtualType",
      "string": "exports.VirtualType"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Export Schema types</p>",
      "summary": "<p>Export Schema types</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.SchemaTypes = SchemaTypes;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "SchemaTypes",
      "value": "SchemaTypes",
      "string": "exports.SchemaTypes"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Export types</p>",
      "summary": "<p>Export types</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.Types = Types;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "Types",
      "value": "Types",
      "string": "exports.Types"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Export Query</p>",
      "summary": "<p>Export Query</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.Query = Query;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "Query",
      "value": "Query",
      "string": "exports.Query"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Export Promise</p>",
      "summary": "<p>Export Promise</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.Promise = Promise;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "Promise",
      "value": "Promise",
      "string": "exports.Promise"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Export Model constructor</p>",
      "summary": "<p>Export Model constructor</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.Model = Model;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "Model",
      "value": "Model",
      "string": "exports.Model"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Export Document constructor</p>",
      "summary": "<p>Export Document constructor</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.Document = Document;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "Document",
      "value": "Document",
      "string": "exports.Document"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Export MongooseError</p>",
      "summary": "<p>Export MongooseError</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.Error = require('./error');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "Error",
      "value": "require('./error')",
      "string": "exports.Error"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Export driver</p>",
      "summary": "<p>Export driver</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.mongo = require('mongodb');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "mongo",
      "value": "require('mongodb')",
      "string": "exports.mongo"
    }
  }
]
### lib/model.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var Document = require('./document')\n  , MongooseArray = require('./types/array')\n  , MongooseBuffer = require('./types/buffer')\n  , MongooseError = require('./error')\n  , Query = require('./query')\n  , Schema = require('./schema')\n  , utils = require('./utils')\n  , isMongooseObject = utils.isMongooseObject\n  , EventEmitter = utils.EventEmitter\n  , merge = utils.merge\n  , Promise = require('./promise')\n  , tick = utils.tick\n\nvar VERSION_WHERE = 1\n  , VERSION_INC = 2\n  , VERSION_ALL = VERSION_WHERE | VERSION_INC;",
    "ctx": {
      "type": "declaration",
      "name": "Document",
      "value": "require('./document')",
      "string": "Document"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "values",
        "description": "to set"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Model constructor</p>",
      "summary": "<p>Model constructor</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function Model (doc, fields, skipId) {\n  Document.call(this, doc, fields, skipId);\n};",
    "ctx": {
      "type": "function",
      "name": "Model",
      "string": "Model()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from Document.</p>",
      "summary": "<p>Inherits from Document.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Model.prototype.__proto__ = Document.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "Model",
      "name": "__proto__",
      "value": "Document.prototype",
      "string": "Model.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Connection the model uses. Set by the Connection or if absent set to the<br />default mongoose connection;</p>",
      "summary": "<p>Connection the model uses. Set by the Connection or if absent set to the<br />default mongoose connection;</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.prototype.db;"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Collection the model uses. Set by Mongoose instance</p>",
      "summary": "<p>Collection the model uses. Set by Mongoose instance</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.prototype.collection;"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Model name.</p>",
      "summary": "<p>Model name.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.prototype.modelName;"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "query"
        ],
        "name": "query",
        "description": "object"
      },
      {
        "type": "return",
        "types": [
          "Object]"
        ],
        "description": "population paths"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Returns what paths can be populated</p>",
      "summary": "<p>Returns what paths can be populated</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Model.prototype._getPopulationKeys = function getPopulationKeys (query) {\n  if (!(query && query.options.populate)) return;\n\n  var names = Object.keys(query.options.populate)\n    , n = names.length\n    , name\n    , paths = {}\n    , hasKeys\n    , schema\n\n  while (n--) {\n    name = names[n];\n    schema = this.schema.path(name);\n    hasKeys = true;\n\n    if (!schema) {\n      // if the path is not recognized, it's potentially embedded docs\n      // walk path atoms from right to left to find a matching path\n      var pieces = name.split('.')\n        , i = pieces.length;\n\n      while (i--) {\n        var path = pieces.slice(0, i).join('.')\n          , pathSchema = this.schema.path(path);\n\n        // loop until we find an array schema\n        if (pathSchema && pathSchema.caster) {\n          if (!paths[path]) {\n            paths[path] = { sub: {} };\n          }\n\n          paths[path].sub[pieces.slice(i).join('.')] = query.options.populate[name];\n          hasKeys || (hasKeys = true);\n          break;\n        }\n      }\n    } else {\n      paths[name] = query.options.populate[name];\n      hasKeys || (hasKeys = true);\n    }\n  }\n\n  return hasKeys && paths;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Model",
      "name": "_getPopulationKeys",
      "string": "Model.prototype._getPopulationKeys()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "SchemaType"
        ],
        "name": "schema",
        "description": "type for the oid"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "object",
        "description": "id or array of object ids"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "object",
        "description": "specifying query conditions, fields, and options"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Populates an object</p>",
      "summary": "<p>Populates an object</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Model.prototype._populate = function populate (schema, oid, query, fn) {\n  if (!Array.isArray(oid)) {\n    var conditions = query.conditions || {};\n    conditions._id = oid;\n\n    return this\n    .model(query.model || schema.options.ref)\n    .findOne(conditions, query.fields, query.options, fn);\n  }\n\n  if (!oid.length) {\n    return fn(null, oid);\n  }\n\n  var model = this.model(query.model || schema.caster.options.ref)\n    , conditions = query && query.conditions || {};\n  conditions._id || (conditions._id = { $in: oid });\n\n  model.find(conditions, query.fields, query.options, function (err, docs) {\n    if (err) return fn(err);\n\n    // user specified sort order?\n    if (query.options && query.options.sort) {\n      return fn(null, docs);\n    }\n\n    // put back in original id order (using a hash reduces complexity from n*n to 2n)\n    var docHash = {};\n    docs.forEach(function (doc) {\n      docHash[doc._id] = doc;\n    });\n\n    var arr = [];\n    oid.forEach(function (id) {\n      if (id in docHash) arr.push(docHash[id]);\n    });\n\n    fn(null, arr);\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "Model",
      "name": "_populate",
      "string": "Model.prototype._populate()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "document",
        "description": "returned by mongo"
      },
      {
        "type": "param",
        "types": [
          "Query"
        ],
        "name": "query",
        "description": "that originated the initialization"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Performs auto-population of relations.</p>",
      "summary": "<p>Performs auto-population of relations.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Model.prototype.init = function init (doc, query, fn) {\n  if ('function' == typeof query) {\n    fn = query;\n    query = null;\n  }\n\n  var populate = this._getPopulationKeys(query);\n\n  if (!populate) {\n    return Document.prototype.init.call(this, doc, fn);\n  }\n\n  // population from other models is necessary\n  var self = this;\n\n  init(doc, '', function (err) {\n    if (err) return fn(err);\n    Document.prototype.init.call(self, doc, fn);\n  });\n\n  return this;\n\n  function init (obj, prefix, fn) {\n    prefix = prefix || '';\n\n    var keys = Object.keys(obj)\n      , len = keys.length;\n\n    function next () {\n      if (--len < 0) return fn();\n\n      var i = keys[len]\n        , path = prefix + i\n        , schema = self.schema.path(path)\n        , total = 0\n        , poppath\n\n      if (!schema && obj[i] && 'Object' === obj[i].constructor.name) {\n        // assume nested object\n        return init(obj[i], path + '.', next);\n      }\n\n      if (!(obj[i] && schema && populate[path])) return next();\n\n      // this query object is re-used and passed around. we clone\n      // it to prevent query condition contamination between\n      // one populate call to the next.\n      poppath = utils.clone(populate[path]);\n\n      if (poppath.sub) {\n        obj[i].forEach(function (subobj) {\n          var pkeys = Object.keys(poppath.sub)\n            , pi = pkeys.length\n            , key\n\n          while (pi--) {\n            key = pkeys[pi];\n\n            if (subobj[key]) (function (key) {\n\n              total++;\n              self._populate(schema.schema.path(key), subobj[key], poppath.sub[key], done);\n              function done (err, doc) {\n                if (err) return error(err);\n                subobj[key] = doc;\n                --total || next();\n              }\n            })(key);\n          }\n        });\n\n        if (0 === total) return next();\n\n      } else {\n        self._populate(schema, obj[i], poppath, function (err, doc) {\n          if (err) return error(err);\n          obj[i] = doc;\n          next();\n        });\n      }\n    };\n\n    next();\n  };\n\n  function error (err) {\n    if (error.err) return;\n    fn(error.err = err);\n  }\n};\n\nfunction handleSave (promise, self) {\n  return tick(function handleSave (err, result) {\n    if (err) {\n      // If the initial insert fails provide a second chance.\n      // (If we did this all the time we would break updates)\n      if (self._inserting) {\n        self.isNew = true;\n        self.emit('isNew', true);\n      }\n      promise.error(err);\n      promise = self = null;\n      return;\n    }\n\n    self._storeShard();\n\n    var numAffected;\n    if (result) {\n      // when inserting, the array of created docs is returned\n      numAffected = result.length\n        ? result.length\n        : result;\n    } else {\n      numAffected = 0;\n    }\n\n    // was this an update that required a version bump?\n    if (self.__version && !self._inserting) {\n      self.__version = undefined;\n\n      // increment version if was successful\n      if (numAffected > 0) {\n        var key = self.schema.options.versionKey;\n        var version = self.getValue(key) | 0;\n        self.setValue(key, version + 1);\n      } else {\n        // the update failed. pass an error back\n        promise.error(new Error('No matching document found.'));\n        promise = self = null;\n        return;\n      }\n    }\n\n    self.emit('save', self, numAffected);\n    promise.complete(self, numAffected);\n    promise = self = null;\n  });\n}",
    "ctx": {
      "type": "method",
      "constructor": "Model",
      "name": "init",
      "string": "Model.prototype.init()"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "local": "Model#registerHooks",
        "visibility": "Model#registerHooks"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Saves this document.</p>",
      "summary": "<p>Saves this document.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.prototype.save = function save (fn) {\n  var promise = new Promise(fn)\n    , complete = handleSave(promise, this)\n    , options = {}\n\n  if (this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    var obj = this.toObject({ depopulate: 1 });\n    this._version(true, obj);\n    this.collection.insert(obj, options, complete);\n    this._reset();\n    this.isNew = false;\n    this.emit('isNew', false);\n    // Make it possible to retry the insert\n    this._inserting = true;\n\n  } else {\n    // Make sure we don't treat it as a new object on error,\n    // since it already exists\n    this._inserting = false;\n\n    var delta = this._delta();\n    if (delta) {\n      var where = this._where(delta[0]);\n      this.collection.update(where, delta[1], options, complete);\n    } else {\n      complete(null);\n    }\n\n    this._reset();\n    this.emit('isNew', false);\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Model",
      "name": "save",
      "string": "Model.prototype.save()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "self",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "where",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "delta",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "data",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Mixed"
        ],
        "name": "val",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[operation]",
        "description": ""
      },
      {
        "type": "ignore",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>operand</p>\n\n<p>Apply the operation to the delta (update) clause as<br />well as track versioning for our where clause.</p>",
      "summary": "<p>operand</p>",
      "body": "<p>Apply the operation to the delta (update) clause as<br />well as track versioning for our where clause.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function operand (self, where, delta, data, val, op) {\n  // delta\n  op || (op = '$set');\n  if (!delta[op]) delta[op] = {};\n  delta[op][data.path] = val;\n\n  // disabled versioning?\n  if (false === self.schema.options.versionKey) return;\n\n  // already marked for versioning?\n  if (VERSION_ALL === (VERSION_ALL & self.__version)) return;\n\n  switch (op) {\n    case '$set':\n    case '$unset':\n    case '$pop':\n    case '$pull':\n    case '$pullAll':\n    case '$push':\n    case '$pushAll':\n    case '$addToSet':\n      break;\n    default:\n      // nothing to do\n      return;\n  }\n\n  // ensure updates sent with positional notation are\n  // editing the correct array element.\n  // only increment the version if an array position changes.\n  // modifying elements of an array is ok if position does not change.\n\n  if ('$push' == op || '$pushAll' == op || '$addToSet' == op) {\n    self.__version = VERSION_INC;\n  }\n  else if (/^\\$p/.test(op)) {\n    // potentially changing array positions\n    self.increment();\n  }\n  else if (Array.isArray(val)) {\n    // $set an array\n    self.increment();\n  }\n  // now handling $set, $unset\n  else if (/\\.\\d+/.test(data.path)) {\n    // subpath of array\n    self.__version = VERSION_WHERE;\n  }\n}",
    "ctx": {
      "type": "function",
      "name": "operand",
      "string": "operand()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "self",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "where",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "delta",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "data",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "arr",
        "description": ""
      },
      {
        "type": "ignore",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>handleMongooseArray</p>\n\n<p>Compiles an update and where clause for an array.</p>",
      "summary": "<p>handleMongooseArray</p>",
      "body": "<p>Compiles an update and where clause for an array.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function handleMongooseArray (self, where, delta, data, arr) {\n  if (delta.$set && delta.$set[data.path]) {\n    // $set has precedence over other atomics\n    return;\n  }\n\n  var atomics = arr._atomics\n    , ops = Object.keys(atomics)\n    , schema = data.schema\n    , path = data.path\n    , i = ops.length\n    , val\n    , op;\n\n  if (0 === i) {\n    // $set\n    arr = arr.toObject({ depopulate: 1 });\n    return operand(self, where, delta, data, arr);\n  }\n\n  while (i--) {\n    op = ops[i];\n    val = atomics[op];\n    if (isMongooseObject(val)) {\n      val = val.toObject({ depopulate: 1 })\n    } else if (Array.isArray(val)) {\n      val = val.map(function (mem) {\n        return isMongooseObject(mem)\n          ? mem.toObject({ depopulate: 1 })\n          : mem;\n      })\n    }\n\n    if ('$addToSet' === op)\n      val = { $each: val };\n\n    operand(self, where, delta, data, val, op);\n  }\n}",
    "ctx": {
      "type": "function",
      "name": "handleMongooseArray",
      "string": "handleMongooseArray()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>_delta</p>\n\n<p>Produces a special query document of the modified properties<br />used in updates.</p>",
      "summary": "<p>_delta</p>",
      "body": "<p>Produces a special query document of the modified properties<br />used in updates.</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Model.prototype._delta = function _delta () {\n  var dirty = this._dirty();\n  if (!dirty.length) return;\n\n  var self = this\n    , where = {}\n    , delta = {}\n    , len = dirty.length\n    , d = 0\n    , val\n    , obj\n\n  for (; d < len; ++d) {\n    var data = dirty[d]\n    var value = data.value\n    var schema = data.schema\n\n    if (undefined === value) {\n      operand(self, where, delta, data, 1, '$unset');\n\n    } else if (null === value) {\n      operand(self, where, delta, data, null);\n\n    } else if (value._path && value._registerAtomic) {\n      handleMongooseArray(self, where, delta, data, value);\n\n    } else if (value._path && value.write && value.toObject) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(self, where, delta, data, value);\n\n    } else {\n      // nested object literal\n      value = utils.clone(value);\n      operand(self, where, delta, data, value);\n    }\n  }\n\n  if (this.__version) {\n    this._version(where, delta);\n  }\n\n  return [where, delta];\n}",
    "ctx": {
      "type": "method",
      "constructor": "Model",
      "name": "_delta",
      "string": "Model.prototype._delta()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>_version</p>\n\n<p>Appends versioning to the where and update clauses.</p>",
      "summary": "<p>_version</p>",
      "body": "<p>Appends versioning to the where and update clauses.</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Model.prototype._version = function _version (where, delta) {\n  var key = this.schema.options.versionKey;\n\n  if (true === where) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  // TODO fail fast option?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don't need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.__version)) {\n    where[key] = this.getValue(key);\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.__version)) {\n    delta.$inc || (delta.$inc = {});\n    delta.$inc[key] = 1;\n  }\n}",
    "ctx": {
      "type": "method",
      "constructor": "Model",
      "name": "_version",
      "string": "Model.prototype._version()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>increment</p>\n\n<p>Signal that we desire an increment of<br />this documents version.</p>",
      "summary": "<p>increment</p>",
      "body": "<p>Signal that we desire an increment of<br />this documents version.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.prototype.increment = function increment () {\n  this.__version = VERSION_ALL;\n  return this;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Model",
      "name": "increment",
      "string": "Model.prototype.increment()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>_where</p>\n\n<p>Returns a query object which applies shardkeys if<br />they exist.</p>",
      "summary": "<p>_where</p>",
      "body": "<p>Returns a query object which applies shardkeys if<br />they exist.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.prototype._where = function _where (where) {\n  where || (where = {});\n\n  var paths\n    , len\n\n  if (this._shardval) {\n    paths = Object.keys(this._shardval)\n    len = paths.length\n\n    for (var i = 0; i < len; ++i) {\n      where[paths[i]] = this._shardval[paths[i]];\n    }\n  }\n\n  where._id = this._doc._id;\n  return where;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Model",
      "name": "_where",
      "string": "Model.prototype._where()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Remove the document</p>",
      "summary": "<p>Remove the document</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.prototype.remove = function remove (fn) {\n  if (this._removing) return this;\n\n  var promise = this._removing = new Promise(fn)\n    , where = this._where()\n    , self = this\n    , options = {}\n\n  if (this.schema.options.safe) {\n    options.safe = this.schema.options.safe;\n  }\n\n  this.collection.remove(where, options, tick(function (err) {\n    if (err) {\n      promise.error(err);\n      promise = self = self._removing = where = options = null;\n      return;\n    }\n    promise.complete();\n    self.emit('remove', self);\n    promise = self = where = options = null;\n  }));\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Model",
      "name": "remove",
      "string": "Model.prototype.remove()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Register hooks override</p>",
      "summary": "<p>Register hooks override</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Model.prototype._registerHooks = function registerHooks () {\n  Document.prototype._registerHooks.call(this);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Model",
      "name": "_registerHooks",
      "string": "Model.prototype._registerHooks()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "model",
        "description": "name"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Shortcut to access another model.</p>",
      "summary": "<p>Shortcut to access another model.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.prototype.model = function model (name) {\n  return this.db.model(name);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Model",
      "name": "model",
      "string": "Model.prototype.model()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Give the constructor the ability to emit events.</p>",
      "summary": "<p>Give the constructor the ability to emit events.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "for (var i in EventEmitter.prototype)\n  Model[i] = EventEmitter.prototype[i];"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Called when the model compiles</p>",
      "summary": "<p>Called when the model compiles</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Model.init = function init () {\n  if (this.schema.options.autoIndex)\n    this.ensureIndexes();\n\n  this.schema.emit('init', this);\n};",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "init",
      "string": "Model.init()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "cb",
        "description": "(optional)"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>ensureIndexes</p>\n\n<p>Sends <code>ensureIndex</code> commands to mongo for<br />each index declared in the schema.</p>",
      "summary": "<p>ensureIndexes</p>",
      "body": "<p>Sends <code>ensureIndex</code> commands to mongo for<br />each index declared in the schema.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.ensureIndexes = function ensureIndexes (cb) {\n  var indexes = this.schema.indexes();\n  if (!indexes.length) {\n    return cb && cb();\n  }\n\n  var self = this\n    , safe = self.schema.options.safe\n    , count = indexes.length\n    , error\n\n  indexes.forEach(function (index) {\n    var options = index[1];\n    options.safe = safe;\n    self.collection.ensureIndex(index[0], options, tick(function (err) {\n      if (err) error = err;\n      if (--count) return;\n\n      self.emit('index', error);\n      cb && cb(error);\n    }));\n  });\n}",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "ensureIndexes",
      "string": "Model.ensureIndexes()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Document schema</p>",
      "summary": "<p>Document schema</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.schema;"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Database instance the model uses.</p>",
      "summary": "<p>Database instance the model uses.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.db;"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Collection the model uses.</p>",
      "summary": "<p>Collection the model uses.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.collection;"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Base Mongoose instance for the model.</p>",
      "summary": "<p>Base Mongoose instance for the model.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.base;"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = exports = Model;\n\nModel.remove = function remove (conditions, callback) {\n  if ('function' === typeof conditions) {\n    callback = conditions;\n    conditions = {};\n  }\n\n  var query = new Query(conditions).bind(this, 'remove');\n\n  if ('undefined' === typeof callback)\n    return query;\n\n  this._applyNamedScope(query);\n  return query.remove(callback);\n};",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "exports = Model",
      "string": "module.exports"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "conditions",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object",
          "Function"
        ],
        "name": "(optional)",
        "description": "fields to hydrate or callback"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Finds documents</p>\n\n<h2>Examples</h2>\n\n<p>// retrieve only certain keys<br />   MyModel.find({ name: /john/i }, 'name friends', function () { })</p>\n\n<p>// pass options<br />   MyModel.find({ name: /john/i }, null, { skip: 10 } )</p>",
      "summary": "<p>Finds documents</p>",
      "body": "<h2>Examples</h2>\n\n<p>// retrieve only certain keys<br />   MyModel.find({ name: /john/i }, 'name friends', function () { })</p>\n\n<p>// pass options<br />   MyModel.find({ name: /john/i }, null, { skip: 10 } )</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.find = function find (conditions, fields, options, callback) {\n  if ('function' == typeof conditions) {\n    callback = conditions;\n    conditions = {};\n    fields = null;\n    options = null;\n  } else if ('function' == typeof fields) {\n    callback = fields;\n    fields = null;\n    options = null;\n  } else if ('function' == typeof options) {\n    callback = options;\n    options = null;\n  }\n\n  var query = new Query(conditions, options);\n  query.bind(this, 'find');\n  query.select(fields);\n\n  if ('undefined' === typeof callback)\n    return query;\n\n  this._applyNamedScope(query);\n  return query.find(callback);\n};",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "find",
      "string": "Model.find()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Query"
        ],
        "name": "query",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Merges the current named scope query into <code>query</code>.</p>",
      "summary": "<p>Merges the current named scope query into <code>query</code>.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Model._applyNamedScope = function _applyNamedScope (query) {\n  var cQuery = this._cumulativeQuery;\n\n  if (cQuery) {\n    merge(query._conditions, cQuery._conditions);\n    if (query._fields && cQuery._fields)\n      merge(query._fields, cQuery._fields);\n    if (query.options && cQuery.options)\n      merge(query.options, cQuery.options);\n    delete this._cumulativeQuery;\n  }\n\n  return query;\n}",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "_applyNamedScope",
      "string": "Model._applyNamedScope()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "ObjectId",
          "Object"
        ],
        "name": "objectid,",
        "description": "or a value that can be casted to it"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Finds by id</p>",
      "summary": "<p>Finds by id</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.findById = function findById (id, fields, options, callback) {\n  return this.findOne({ _id: id }, fields, options, callback);\n};",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "findById",
      "string": "Model.findById()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "conditions",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object",
          "Function"
        ],
        "name": "(optional)",
        "description": "fields to hydrate or callback"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Finds one document</p>",
      "summary": "<p>Finds one document</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.findOne = function findOne (conditions, fields, options, callback) {\n  if ('function' == typeof options) {\n    // TODO Handle all 3 of the following scenarios\n    // Hint: Only some of these scenarios are possible if cQuery is present\n    // Scenario: findOne(conditions, fields, callback);\n    // Scenario: findOne(fields, options, callback);\n    // Scenario: findOne(conditions, options, callback);\n    callback = options;\n    options = null;\n  } else if ('function' == typeof fields) {\n    // TODO Handle all 2 of the following scenarios\n    // Scenario: findOne(conditions, callback)\n    // Scenario: findOne(fields, callback)\n    // Scenario: findOne(options, callback);\n    callback = fields;\n    fields = null;\n    options = null;\n  } else if ('function' == typeof conditions) {\n    callback = conditions;\n    conditions = {};\n    fields = null;\n    options = null;\n  }\n\n  var query = new Query(conditions, options).select(fields).bind(this, 'findOne');\n\n  if ('undefined' == typeof callback)\n    return query;\n\n  this._applyNamedScope(query);\n  return query.findOne(callback);\n};",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "findOne",
      "string": "Model.findOne()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "conditions",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "optional",
        "description": "callback"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Counts documents</p>",
      "summary": "<p>Counts documents</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.count = function count (conditions, callback) {\n  if ('function' === typeof conditions)\n    callback = conditions, conditions = {};\n\n  var query = new Query(conditions).bind(this, 'count');\n  if ('undefined' == typeof callback)\n    return query;\n\n  this._applyNamedScope(query);\n  return query.count(callback);\n};\n\nModel.distinct = function distinct (field, conditions, callback) {\n  var query = new Query(conditions).bind(this, 'distinct');\n  if ('undefined' == typeof callback) {\n    query._distinctArg = field;\n    return query;\n  }\n\n  this._applyNamedScope(query);\n  return query.distinct(field, callback);\n};",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "count",
      "string": "Model.count()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "val",
        "description": "(optional)"
      },
      {
        "type": "return",
        "types": [
          "Query"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>where</p>\n\n<p>Creates a Query, applies the passed conditions, and<br />returns the Query.</p>\n\n<p>For example, instead of writing:</p>\n\n<pre><code>User.find({age: {$gte: 21, $lte: 65}}, callback);\n</code></pre>\n\n<p>we can instead write:</p>\n\n<pre><code>User.where('age').gte(21).lte(65).exec(callback);\n</code></pre>\n\n<p>Since the Query class also supports <code>where</code> you can<br />continue chaining:</p>\n\n<pre><code>User\n</code></pre>\n\n<p>.where('age').gte(21).lte(65)<br />   .where('name', /^b/i)<br />   ... etc</p>",
      "summary": "<p>where</p>",
      "body": "<p>Creates a Query, applies the passed conditions, and<br />returns the Query.</p>\n\n<p>For example, instead of writing:</p>\n\n<pre><code>User.find({age: {$gte: 21, $lte: 65}}, callback);\n</code></pre>\n\n<p>we can instead write:</p>\n\n<pre><code>User.where('age').gte(21).lte(65).exec(callback);\n</code></pre>\n\n<p>Since the Query class also supports <code>where</code> you can<br />continue chaining:</p>\n\n<pre><code>User\n</code></pre>\n\n<p>.where('age').gte(21).lte(65)<br />   .where('name', /^b/i)<br />   ... etc</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.where = function where (path, val) {\n  var q = new Query().bind(this, 'find');\n  return q.where.apply(q, arguments);\n};",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "where",
      "string": "Model.where()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "Function"
        ],
        "name": "js",
        "description": "is a javascript string or anonymous function"
      },
      {
        "type": "return",
        "types": [
          "Query"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sometimes you need to query for things in mongodb using a JavaScript<br />expression. You can do so via find({$where: javascript}), or you can<br />use the mongoose shortcut method $where via a Query chain or from<br />your mongoose Model.</p>",
      "summary": "<p>Sometimes you need to query for things in mongodb using a JavaScript<br />expression. You can do so via find({$where: javascript}), or you can<br />use the mongoose shortcut method $where via a Query chain or from<br />your mongoose Model.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.$where = function $where () {\n  var q = new Query().bind(this, 'find');\n  return q.$where.apply(q, arguments);\n};"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "conditions",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "update",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>findOneAndUpdate</p>\n\n<p>Issues a mongodb findAndModify update command.</p>\n\n<p>Finds a matching document, updates it according to the <code>update</code><br />arg, passing any <code>options</code>, and returns the found document<br />(if any) to the callback. The query executes immediately if<br /><code>callback</code> is passed else a Query object is returned.</p>\n\n<h2>Available options</h2>\n\n<p><code>new</code>: bool - true to return the modified document rather than the original. defaults to true<br />  <code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.<br />  <code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</p>\n\n<h2>Examples</h2>\n\n<pre><code>A.findOneAndUpdate(conditions, update, options, callback) // executes\nA.findOneAndUpdate(conditions, update, options)  // returns Query\nA.findOneAndUpdate(conditions, update, callback) // executes\nA.findOneAndUpdate(conditions, update)           // returns Query\nA.findOneAndUpdate()                             // returns Query\n</code></pre>",
      "summary": "<p>findOneAndUpdate</p>",
      "body": "<p>Issues a mongodb findAndModify update command.</p>\n\n<p>Finds a matching document, updates it according to the <code>update</code><br />arg, passing any <code>options</code>, and returns the found document<br />(if any) to the callback. The query executes immediately if<br /><code>callback</code> is passed else a Query object is returned.</p>\n\n<h2>Available options</h2>\n\n<p><code>new</code>: bool - true to return the modified document rather than the original. defaults to true<br />  <code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.<br />  <code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</p>\n\n<h2>Examples</h2>\n\n<pre><code>A.findOneAndUpdate(conditions, update, options, callback) // executes\nA.findOneAndUpdate(conditions, update, options)  // returns Query\nA.findOneAndUpdate(conditions, update, callback) // executes\nA.findOneAndUpdate(conditions, update)           // returns Query\nA.findOneAndUpdate()                             // returns Query\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.findOneAndUpdate = function (conditions, update, options, callback) {\n  if ('function' == typeof options) {\n    callback = options;\n    options = null;\n  }\n  else if (1 === arguments.length) {\n    if ('function' == typeof conditions) {\n      var msg = 'Model.findOneAndUpdate(): First argument must not be a function.\\n\\n'\n              + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options, callback)\\n'\n              + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options)\\n'\n              + '  ' + this.modelName + '.findOneAndUpdate(conditions, update)\\n'\n              + '  ' + this.modelName + '.findOneAndUpdate(update)\\n'\n              + '  ' + this.modelName + '.findOneAndUpdate()\\n';\n      throw new TypeError(msg)\n    }\n    update = conditions;\n    conditions = undefined;\n  }\n\n  var fields;\n  if (options && options.fields) {\n    fields = options.fields;\n    options.fields = undefined;\n  }\n\n  var query = new Query(conditions, options);\n  query.select(fields);\n  query.bind(this, 'findOneAndUpdate', update);\n\n  if ('undefined' == typeof callback)\n    return query;\n\n  this._applyNamedScope(query);\n  return query.findOneAndUpdate(callback);\n}",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "findOneAndUpdate",
      "string": "Model.findOneAndUpdate()"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "local": "findOneAndUpdate for details.",
        "visibility": "findOneAndUpdate"
      }
    ],
    "description": {
      "full": "<p>findByIdAndUpdate</p>\n\n<p>Issue a mongodb findAndModify update command by a documents id.</p>",
      "summary": "<p>findByIdAndUpdate</p>",
      "body": "<p>Issue a mongodb findAndModify update command by a documents id.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.findByIdAndUpdate = function (id, update, options, callback) {\n  var args;\n\n  if (1 === arguments.length) {\n    if ('function' == typeof id) {\n      var msg = 'Model.findByIdAndUpdate(): First argument must not be a function.\\n\\n'\n                + '  ' + this.modelName + '.findByIdAndUpdate(id, callback)\\n'\n                + '  ' + this.modelName + '.findByIdAndUpdate(id)\\n'\n                + '  ' + this.modelName + '.findByIdAndUpdate()\\n';\n      throw new TypeError(msg)\n    }\n    return this.findOneAndUpdate({_id: id }, undefined);\n  }\n\n  args = utils.args(arguments, 1);\n  args.unshift({ _id: id });\n  return this.findOneAndUpdate.apply(this, args);\n}",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "findByIdAndUpdate",
      "string": "Model.findByIdAndUpdate()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "conditions",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>findOneAndRemove</p>\n\n<p>Issue a mongodb findAndModify remove command.</p>\n\n<p>Finds a matching document, removes it, passing the found<br />document (if any) to the callback. Executes immediately if <code>callback</code><br />is passed else a Query object is returned.</p>\n\n<h2>Available options</h2>\n\n<p><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</p>\n\n<h2>Examples</h2>\n\n<pre><code>A.findOneAndRemove(conditions, options, callback) // executes\nA.findOneAndRemove(conditions, options)  // return Query\nA.findOneAndRemove(conditions, callback) // executes\nA.findOneAndRemove(conditions) // returns Query\nA.findOneAndRemove()           // returns Query\n</code></pre>",
      "summary": "<p>findOneAndRemove</p>",
      "body": "<p>Issue a mongodb findAndModify remove command.</p>\n\n<p>Finds a matching document, removes it, passing the found<br />document (if any) to the callback. Executes immediately if <code>callback</code><br />is passed else a Query object is returned.</p>\n\n<h2>Available options</h2>\n\n<p><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</p>\n\n<h2>Examples</h2>\n\n<pre><code>A.findOneAndRemove(conditions, options, callback) // executes\nA.findOneAndRemove(conditions, options)  // return Query\nA.findOneAndRemove(conditions, callback) // executes\nA.findOneAndRemove(conditions) // returns Query\nA.findOneAndRemove()           // returns Query\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.findOneAndRemove = function (conditions, options, callback) {\n  if (1 === arguments.length && 'function' == typeof conditions) {\n    var msg = 'Model.findOneAndRemove(): First argument must not be a function.\\n\\n'\n              + '  ' + this.modelName + '.findOneAndRemove(conditions, callback)\\n'\n              + '  ' + this.modelName + '.findOneAndRemove(conditions)\\n'\n              + '  ' + this.modelName + '.findOneAndRemove()\\n';\n    throw new TypeError(msg)\n  }\n\n  if ('function' == typeof options) {\n    callback = options;\n    options = undefined;\n  }\n\n  var fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  var query = new Query(conditions, options);\n  query.bind(this, 'findOneAndRemove');\n  query.select(fields);\n\n  if ('undefined' == typeof callback)\n    return query;\n\n  this._applyNamedScope(query);\n  return query.findOneAndRemove(callback);\n}",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "findOneAndRemove",
      "string": "Model.findOneAndRemove()"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "local": "findOneAndRemove for details.",
        "visibility": "findOneAndRemove"
      }
    ],
    "description": {
      "full": "<p>findByIdAndRemove</p>\n\n<p>Issue a mongodb findAndModify remove command by a documents id.</p>",
      "summary": "<p>findByIdAndRemove</p>",
      "body": "<p>Issue a mongodb findAndModify remove command by a documents id.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.findByIdAndRemove = function (id, options, callback) {\n  if (1 === arguments.length && 'function' == typeof id) {\n    var msg = 'Model.findByIdAndRemove(): First argument must not be a function.\\n\\n'\n              + '  ' + this.modelName + '.findByIdAndRemove(id, callback)\\n'\n              + '  ' + this.modelName + '.findByIdAndRemove(id)\\n'\n              + '  ' + this.modelName + '.findByIdAndRemove()\\n';\n    throw new TypeError(msg)\n  }\n\n  return this.findOneAndRemove({ _id: id }, options, callback);\n}",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "findByIdAndRemove",
      "string": "Model.findByIdAndRemove()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "doc",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Shortcut for creating a new Document that is automatically saved<br />to the db if valid.</p>",
      "summary": "<p>Shortcut for creating a new Document that is automatically saved<br />to the db if valid.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.create = function create (doc, fn) {\n  if (1 === arguments.length) {\n    return 'function' === typeof doc && doc(null);\n  }\n\n  var self = this\n    , docs = [null]\n    , promise\n    , count\n    , args\n\n  if (Array.isArray(doc)) {\n    args = doc;\n  } else {\n    args = utils.args(arguments, 0, arguments.length - 1);\n    fn = arguments[arguments.length - 1];\n  }\n\n  if (0 === args.length) return fn(null);\n\n  promise = new Promise(fn);\n  count = args.length;\n\n  args.forEach(function (arg, i) {\n    var doc = new self(arg);\n    docs[i+1] = doc;\n    doc.save(function (err) {\n      if (err) return promise.error(err);\n      --count || fn.apply(null, docs);\n    });\n  });\n\n  // TODO\n  // utilize collection.insertAll for batch processing?\n};",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "create",
      "string": "Model.create()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "conditions",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "doc",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Query"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Updates documents.</p>\n\n<h2>Examples</h2>\n\n<pre><code>MyModel.update({ age: { $gt: 18 } }, { oldEnough: true }, fn);\nMyModel.update({ name: 'Tobi' }, { ferret: true }, { multi: true }, fn);\n</code></pre>\n\n<h2>Valid options</h2>\n\n<ul>\n<li>safe (boolean) safe mode (defaults to value set in schema (true))</li>\n<li>upsert (boolean) whether to create the doc if it doesn't match (false)</li>\n<li>multi (boolean) whether multiple documents should be updated (false)</li>\n</ul>",
      "summary": "<p>Updates documents.</p>",
      "body": "<h2>Examples</h2>\n\n<pre><code>MyModel.update({ age: { $gt: 18 } }, { oldEnough: true }, fn);\nMyModel.update({ name: 'Tobi' }, { ferret: true }, { multi: true }, fn);\n</code></pre>\n\n<h2>Valid options</h2>\n\n<ul>\n<li>safe (boolean) safe mode (defaults to value set in schema (true))</li>\n<li>upsert (boolean) whether to create the doc if it doesn't match (false)</li>\n<li>multi (boolean) whether multiple documents should be updated (false)</li>\n</ul>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.update = function update (conditions, doc, options, callback) {\n  if (arguments.length < 4) {\n    if ('function' === typeof options) {\n      // Scenario: update(conditions, doc, callback)\n      callback = options;\n      options = null;\n    } else if ('function' === typeof doc) {\n      // Scenario: update(doc, callback);\n      callback = doc;\n      doc = conditions;\n      conditions = {};\n      options = null;\n    }\n  }\n\n  var query = new Query(conditions, options).bind(this, 'update', doc);\n\n  if ('undefined' == typeof callback)\n    return query;\n\n  this._applyNamedScope(query);\n  return query.update(doc, callback);\n};",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "update",
      "string": "Model.update()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "o",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>mapReduce</p>\n\n<p>Executes a mapReduce command. <code>o</code> is an object specifying<br />all mapReduce options as well as the map and reduce functions.<br />All options are delegated to the driver implementation.</p>\n\n<h2>Example</h2>\n\n<pre><code>var o = {};\no.map = function () { emit(this.name, 1) }\no.reduce = function (k, vals) { return vals.length }\nUser.mapReduce(o, function (err, results) {\n  console.log(results)\n})\n</code></pre>\n\n<h2>Other options</h2>\n\n<p>(@see <a href='http://www.mongodb.org/display/DOCS/MapReduce'>http://www.mongodb.org/display/DOCS/MapReduce</a> for more details)<br />  - query {Object} query filter object.<br />  - limit {Number} max number of documents<br />  - keeptemp {Boolean, default:false} keep temporary data<br />  - finalize {Function} finalize function<br />  - scope {Object} scope variables exposed to map/reduce/finalize during execution<br />  - jsMode {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X<br />  - verbose {Boolean, default:false} provide statistics on job execution time.<br />  - out {Object, default: {inline:1}} sets the output target for the map reduce job.<br />     {inline:1} the results are returned in an array<br />     {replace: 'collectionName'} add the results to collectionName: the results replace the collection<br />     {reduce: 'collectionName'} add the results to collectionName: if dups are detected, uses the reducer / finalize functions<br />     {merge: 'collectionName'} add the results to collectionName: if dups exist the new docs overwrite the old</p>\n\n<p>If options.out is set to replace, merge, or reduce, a Model<br />instance is returned that can be used for further querying.<br />Queries run against this model are all executed with the <code>lean</code><br />option: meaning only the js object is returned and no<br />Mongoose magic is applied (getters, setters, etc).</p>\n\n<h2>Example</h2>\n\n<pre><code>var o = {};\no.map = function () { emit(this.name, 1) }\no.reduce = function (k, vals) { return vals.length }\no.out = { replace: 'createdCollectionNameForResults' }\no.verbose = true;\nUser.mapReduce(o, function (err, model, stats) {\n  console.log('map reduce took %d ms', stats.processtime)\n  model.find().where('value').gt(10).exec(function (err, docs) {\n    console.log(docs);\n  });\n})\n</code></pre>",
      "summary": "<p>mapReduce</p>",
      "body": "<p>Executes a mapReduce command. <code>o</code> is an object specifying<br />all mapReduce options as well as the map and reduce functions.<br />All options are delegated to the driver implementation.</p>\n\n<h2>Example</h2>\n\n<pre><code>var o = {};\no.map = function () { emit(this.name, 1) }\no.reduce = function (k, vals) { return vals.length }\nUser.mapReduce(o, function (err, results) {\n  console.log(results)\n})\n</code></pre>\n\n<h2>Other options</h2>\n\n<p>(@see <a href='http://www.mongodb.org/display/DOCS/MapReduce'>http://www.mongodb.org/display/DOCS/MapReduce</a> for more details)<br />  - query {Object} query filter object.<br />  - limit {Number} max number of documents<br />  - keeptemp {Boolean, default:false} keep temporary data<br />  - finalize {Function} finalize function<br />  - scope {Object} scope variables exposed to map/reduce/finalize during execution<br />  - jsMode {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X<br />  - verbose {Boolean, default:false} provide statistics on job execution time.<br />  - out {Object, default: {inline:1}} sets the output target for the map reduce job.<br />     {inline:1} the results are returned in an array<br />     {replace: 'collectionName'} add the results to collectionName: the results replace the collection<br />     {reduce: 'collectionName'} add the results to collectionName: if dups are detected, uses the reducer / finalize functions<br />     {merge: 'collectionName'} add the results to collectionName: if dups exist the new docs overwrite the old</p>\n\n<p>If options.out is set to replace, merge, or reduce, a Model<br />instance is returned that can be used for further querying.<br />Queries run against this model are all executed with the <code>lean</code><br />option: meaning only the js object is returned and no<br />Mongoose magic is applied (getters, setters, etc).</p>\n\n<h2>Example</h2>\n\n<pre><code>var o = {};\no.map = function () { emit(this.name, 1) }\no.reduce = function (k, vals) { return vals.length }\no.out = { replace: 'createdCollectionNameForResults' }\no.verbose = true;\nUser.mapReduce(o, function (err, model, stats) {\n  console.log('map reduce took %d ms', stats.processtime)\n  model.find().where('value').gt(10).exec(function (err, docs) {\n    console.log(docs);\n  });\n})\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Model.mapReduce = function mapReduce (o, callback) {\n  if ('function' != typeof callback) throw new Error('missing callback');\n\n  var self = this;\n\n  if (!Model.mapReduce.schema) {\n    var opts = { noId: true, noVirtualId: true, strict: false }\n    Model.mapReduce.schema = new Schema({}, opts);\n  }\n\n  if (!o.out) o.out = { inline: 1 };\n\n  o.map = String(o.map);\n  o.reduce = String(o.reduce);\n\n  this.collection.mapReduce(null, null, o, function (err, ret, stats) {\n    if (err) return callback(err);\n\n    if (ret.findOne && ret.mapReduce) {\n      // returned a collection, convert to Model\n      var model = Model.compile(\n          '_mapreduce_' + ret.collectionName\n        , Model.mapReduce.schema\n        , ret.collectionName\n        , self.db\n        , self.base);\n\n      model._mapreduce = true;\n\n      return callback(err, model, stats);\n    }\n\n    callback(err, ret, stats);\n  });\n}",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "mapReduce",
      "string": "Model.mapReduce()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "model",
        "description": "name"
      },
      {
        "type": "param",
        "types": [
          "Schema"
        ],
        "name": "schema",
        "description": "object"
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "collection",
        "description": "name"
      },
      {
        "type": "param",
        "types": [
          "Connection"
        ],
        "name": "connection",
        "description": "to use"
      },
      {
        "type": "param",
        "types": [
          "Mongoose"
        ],
        "name": "mongoose",
        "description": "instance"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Compiler utility.</p>",
      "summary": "<p>Compiler utility.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Model.compile = function compile (name, schema, collectionName, connection, base) {\n  // generate new class\n  function model (doc, fields, skipId) {\n    if (!(this instanceof model))\n      return new model(doc, fields, skipId);\n    Model.call(this, doc, fields, skipId);\n  };\n\n  model.modelName = name;\n  model.__proto__ = Model;\n  model.prototype.__proto__ = Model.prototype;\n  model.prototype.db = connection;\n  model.prototype._setSchema(schema);\n  model.prototype.collection = connection.collection(\n      collectionName\n    , schema.options.capped\n  );\n\n  // apply methods\n  for (var i in schema.methods)\n    model.prototype[i] = schema.methods[i];\n\n  // apply statics\n  for (var i in schema.statics)\n    model[i] = schema.statics[i];\n\n  // apply named scopes\n  if (schema.namedScopes) schema.namedScopes.compile(model);\n\n  model.model = model.prototype.model;\n  model.options = model.prototype.options;\n  model.db = model.prototype.db;\n  model.schema = model.prototype.schema;\n  model.collection = model.prototype.collection;\n  model.base = base;\n\n  return model;\n};",
    "ctx": {
      "type": "method",
      "receiver": "Model",
      "name": "compile",
      "string": "Model.compile()"
    }
  }
]
### lib/namedscope.js
[
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "NamedScope"
        ],
        "name": "target",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "getters",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Decorate</p>",
      "summary": "<p>Decorate</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "NamedScope.prototype.decorate = function (target, getters) {\n  var name = this.name\n    , block = this.block\n    , query = this.query;\n  if (block) {\n    if (block.length === 0) {\n      Object.defineProperty(target, name, {\n        get: getters.block0(block)\n      });\n    } else {\n      target[name] = getters.blockN(block);\n    }\n  } else {\n    Object.defineProperty(target, name, {\n      get: getters.basic(query)\n    });\n  }\n};\n\nNamedScope.prototype.compile = function (model) {\n  var allScopes = this.scopesByName\n    , scope;\n  for (var k in allScopes) {\n    scope = allScopes[k];\n    scope.decorate(model, {\n      block0: function (block) {\n        return function () {\n          var cquery = this._cumulativeQuery || (this._cumulativeQuery = new Query().bind(this));\n          block.call(cquery);\n          return this;\n        };\n      },\n      blockN: function (block) {\n        return function () {\n          var cquery = this._cumulativeQuery || (this._cumulativeQuery = new Query().bind(this));\n          block.apply(cquery, arguments);\n          return this;\n        };\n      },\n      basic: function (query) {\n        return function () {\n          var cquery = this._cumulativeQuery || (this._cumulativeQuery = new Query().bind(this));\n          cquery.find(query);\n          return this;\n        };\n      }\n    });\n  }\n};\n\nmodule.exports = NamedScope;",
    "ctx": {
      "type": "method",
      "constructor": "NamedScope",
      "name": "decorate",
      "string": "NamedScope.prototype.decorate()"
    }
  }
]
### lib/promise.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var util = require('./utils');\nvar EventEmitter = util.EventEmitter;",
    "ctx": {
      "type": "declaration",
      "name": "util",
      "value": "require('./utils')",
      "string": "util"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "a",
        "description": "callback+errback that takes err, ... as signature"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Promise constructor.</p>",
      "summary": "<p>Promise constructor.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function Promise (back) {\n  this.emitted = {};\n  if ('function' == typeof back)\n    this.addBack(back);\n};",
    "ctx": {
      "type": "function",
      "name": "Promise",
      "string": "Promise()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from EventEmitter.</p>",
      "summary": "<p>Inherits from EventEmitter.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Promise.prototype.__proto__ = EventEmitter.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "Promise",
      "name": "__proto__",
      "value": "EventEmitter.prototype",
      "string": "Promise.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "promise"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds an event or fires the callback right away.</p>",
      "summary": "<p>Adds an event or fires the callback right away.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Promise.prototype.on = function (event, callback) {\n  if (this.emitted[event])\n    callback.apply(this, this.emitted[event]);\n  else\n    EventEmitter.prototype.on.call(this, event, callback);\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Promise",
      "name": "on",
      "string": "Promise.prototype.on()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Keeps track of emitted events to run them on <code>on</code></p>",
      "summary": "<p>Keeps track of emitted events to run them on <code>on</code></p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Promise.prototype.emit = function (event) {\n  // ensures a promise can't be complete() or error() twice\n  if (event == 'err' || event == 'complete'){\n    if (this.emitted.err || this.emitted.complete) {\n      return this;\n    }\n    this.emitted[event] = util.args(arguments, 1);\n  }\n\n  return EventEmitter.prototype.emit.apply(this, arguments);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Promise",
      "name": "emit",
      "string": "Promise.prototype.emit()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Shortcut for emitting complete event</p>",
      "summary": "<p>Shortcut for emitting complete event</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Promise.prototype.complete = function () {\n  var args = util.args(arguments);\n  return this.emit.apply(this, ['complete'].concat(args));\n};",
    "ctx": {
      "type": "method",
      "constructor": "Promise",
      "name": "complete",
      "string": "Promise.prototype.complete()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Shortcut for emitting err event</p>",
      "summary": "<p>Shortcut for emitting err event</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Promise.prototype.error = function (err) {\n  if (!(err instanceof Error)) err = new Error(err);\n  return this.emit('err', err);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Promise",
      "name": "error",
      "string": "Promise.prototype.error()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "promise"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Shortcut for <code>.on('complete', fn)</code></p>",
      "summary": "<p>Shortcut for <code>.on('complete', fn)</code></p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Promise.prototype.addCallback = function (fn) {\n  return this.on('complete', fn);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Promise",
      "name": "addCallback",
      "string": "Promise.prototype.addCallback()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "promise"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Shortcut for <code>.on('err', fn)</code></p>",
      "summary": "<p>Shortcut for <code>.on('err', fn)</code></p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Promise.prototype.addErrback = function (fn) {\n  return this.on('err', fn);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Promise",
      "name": "addErrback",
      "string": "Promise.prototype.addErrback()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "promise"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Adds a single function that's both callback and errback</p>",
      "summary": "<p>Adds a single function that's both callback and errback</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Promise.prototype.addBack = function (fn) {\n  this.on('err', function(err){\n    fn.call(this, err);\n  });\n\n  this.on('complete', function(){\n    var args = util.args(arguments);\n    fn.apply(this, [null].concat(args));\n  });\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Promise",
      "name": "addBack",
      "string": "Promise.prototype.addBack()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Error"
        ],
        "name": "optional",
        "description": "error or null"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "to complete the promise with"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sugar for handling cases where you may be<br />resolving to either an error condition or a <br />success condition.</p>",
      "summary": "<p>Sugar for handling cases where you may be<br />resolving to either an error condition or a <br />success condition.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Promise.prototype.resolve = function (err, val) {\n  if (err) return this.error(err);\n  return this.complete(val);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Promise",
      "name": "resolve",
      "string": "Promise.prototype.resolve()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = Promise;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "Promise",
      "string": "module.exports"
    }
  }
]
### lib/query.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var utils = require('./utils')\n  , merge = utils.merge\n  , Promise = require('./promise')\n  , Document = require('./document')\n  , Types = require('./schema/index')\n  , inGroupsOf = utils.inGroupsOf\n  , tick = utils.tick\n  , QueryStream = require('./querystream')",
    "ctx": {
      "type": "declaration",
      "name": "utils",
      "value": "require('./utils')",
      "string": "utils"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Query constructor</p>",
      "summary": "<p>Query constructor</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function Query (criteria, options) {\n  this.setOptions(options, true);\n  this._conditions = {};\n  this._updateArg = {};\n  if (criteria) this.find(criteria);\n}",
    "ctx": {
      "type": "function",
      "name": "Query",
      "string": "Query()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>setOptions</p>\n\n<p>Sets query options.</p>",
      "summary": "<p>setOptions</p>",
      "body": "<p>Sets query options.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.setOptions = function (options, overwrite",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "setOptions",
      "string": "Query.prototype.setOptions()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>nternal</p>",
      "summary": "<p>nternal</p>",
      "body": ""
    },
    "ignore": false,
    "code": "{\n  if (overwrite) {\n    options = this.options = options || {};\n    this.safe = options.safe\n\n    // normalize population options\n    var pop = this.options.populate;\n    this.options.populate = {};\n\n    if (pop && Array.isArray(pop)) {\n      for (var i = 0, l = pop.length; i < l; i++) {\n        this.options.populate[pop[i]] = {};\n      }\n    }\n\n    return this;\n  }\n\n  if (!(options && 'Object' == options.constructor.name))\n    return this;\n\n  if ('safe' in options)\n    this.safe = options.safe;\n\n  // set arbitrary options\n  var methods = Object.keys(options)\n    , i = methods.length\n    , method\n\n  while (i--) {\n    method = methods[i];\n\n    // use methods if exist (safer option manipulation)\n    if ('function' == typeof this[method]) {\n      var args = Array.isArray(options[method])\n        ? options[method]\n        : [options[method]];\n      this[method].apply(this, args)\n    } else {\n      this.options[method] = options[method];\n    }\n  }\n  return this;\n}"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Model"
        ],
        "name": "model",
        "description": "- the model to which the query is bound"
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "op",
        "description": "- the operation to execute"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "updateArg",
        "description": "- used in update methods"
      },
      {
        "type": "return",
        "types": [
          "Query"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Binds this query to a model.</p>",
      "summary": "<p>Binds this query to a model.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.bind = function bind (model, op, updateArg) {\n  this.model = model;\n  this.op = op;\n\n  if (model._mapreduce) this.options.lean = true;\n\n  if (op == 'update' || op == 'findOneAndUpdate') {\n    merge(this._updateArg, updateArg || {});\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "bind",
      "string": "Query.prototype.bind()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "Function"
        ],
        "name": "op",
        "description": "(optional)"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": "(optional)"
      },
      {
        "type": "return",
        "types": [
          "Promise"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>exec</p>\n\n<p>Executes the query returning a promise.</p>\n\n<h2>Examples</h2>\n\n<pre><code>query.exec();\nquery.exec(callback);\nquery.exec('update');\nquery.exec('find', callback);\n</code></pre>",
      "summary": "<p>exec</p>",
      "body": "<p>Executes the query returning a promise.</p>\n\n<h2>Examples</h2>\n\n<pre><code>query.exec();\nquery.exec(callback);\nquery.exec('update');\nquery.exec('find', callback);\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.exec = function exec (op, callback) {\n  var promise = new Promise();\n\n  switch (typeof op) {\n    case 'function':\n      callback = op;\n      op = null;\n      break;\n    case 'string':\n      this.op = op;\n      break;\n  }\n\n  if (callback) promise.addBack(callback);\n\n  if (!this.op) {\n    promise.complete();\n    return promise;\n  }\n\n  if ('update' == this.op) {\n    this[this.op](this._updateArg, promise.resolve.bind(promise));\n    return promise;\n  }\n\n  if ('distinct' == this.op) {\n    this.distinct(this._distinctArg, promise.resolve.bind(promise));\n    return promise;\n  }\n\n  this[this.op](promise.resolve.bind(promise));\n  return promise;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "exec",
      "string": "Query.prototype.exec()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "criteria",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Finds documents.</p>",
      "summary": "<p>Finds documents.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.find = function (criteria, callback) {\n  this.op = 'find';\n  if ('function' === typeof criteria) {\n    callback = criteria;\n    criteria = {};\n  } else if (criteria instanceof Query) {\n    // TODO Merge options, too\n    merge(this._conditions, criteria._conditions);\n  } else if (criteria instanceof Document) {\n    merge(this._conditions, criteria.toObject());\n  } else if (criteria && 'Object' === criteria.constructor.name) {\n    merge(this._conditions, criteria);\n  }\n  if (!callback) return this;\n  return this.execFind(callback);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "find",
      "string": "Query.prototype.find()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "model",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "(optional)"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Casts obj, or if obj is not present, then this._conditions,<br />based on the model's schema.</p>",
      "summary": "<p>Casts obj, or if obj is not present, then this._conditions,<br />based on the model's schema.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.cast = function (model, obj) {\n  obj || (obj= this._conditions);\n\n  var schema = model.schema\n    , paths = Object.keys(obj)\n    , i = paths.length\n    , any$conditionals\n    , schematype\n    , nested\n    , path\n    , type\n    , val;\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if ('$or' === path || '$nor' === path) {\n      var k = val.length\n        , orComponentQuery;\n\n      while (k--) {\n        orComponentQuery = new Query(val[k]);\n        orComponentQuery.cast(model);\n        val[k] = orComponentQuery._conditions;\n      }\n\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if ('string' !== type && 'function' !== type) {\n        throw new Error(\"Must have a string or function for $where\");\n      }\n\n      if ('function' === type) {\n        obj[path] = val.toString();\n      }\n\n      continue;\n\n    } else {\n\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        var split = path.split('.')\n          , j = split.length\n          , pathFirstHalf\n          , pathLastHalf\n          , remainingConds\n          , castingQuery;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) break;\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            castingQuery = new Query(remainingConds);\n            castingQuery.cast(schematype.caster);\n            obj[path] = castingQuery._conditions[pathLastHalf];\n          } else {\n            obj[path] = val;\n          }\n        }\n\n      } else if (val === null || val === undefined) {\n        continue;\n      } else if ('Object' === val.constructor.name) {\n\n        any$conditionals = Object.keys(val).some(function (k) {\n          return k.charAt(0) === '$' && k !== '$id' && k !== '$ref';\n        });\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(val);\n        } else {\n\n          var ks = Object.keys(val)\n            , k = ks.length\n            , $cond;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n\n            if ('$exists' === $cond) {\n              if ('boolean' !== typeof nested) {\n                throw new Error(\"$exists parameter must be Boolean\");\n              }\n              continue;\n            }\n\n            if ('$type' === $cond) {\n              if ('number' !== typeof nested) {\n                throw new Error(\"$type parameter must be Number\");\n              }\n              continue;\n            }\n\n            if ('$not' === $cond) {\n              this.cast(model, nested);\n            } else {\n              val[$cond] = schematype.castForQuery($cond, nested);\n            }\n          }\n        }\n      } else {\n        obj[path] = schematype.castForQuery(val);\n      }\n    }\n  }\n\n  return obj;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "cast",
      "string": "Query.prototype.cast()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Returns default options.</p>",
      "summary": "<p>Returns default options.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Query.prototype._optionsForExec = function (model) {\n  var options = utils.clone(this.options, { retainKeyOrder: true });\n  delete options.populate;\n  if (! ('safe' in options)) options.safe = model.schema.options.safe;\n  return options;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "_optionsForExec",
      "string": "Query.prototype._optionsForExec()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Applies schematype selected options to this query.</p>",
      "summary": "<p>Applies schematype selected options to this query.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Query.prototype._applyPaths = function applyPaths () {\n  // determine if query is selecting or excluding fields\n\n  var fields = this._fields\n    , exclude\n    , keys\n    , ki\n\n  if (fields) {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    while (ki--) {\n      if ('+' == keys[ki][0]) continue;\n      exclude = 0 === fields[keys[ki]];\n      break;\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n  var selected = []\n    , excluded = []\n\n  this.model.schema.eachPath(function (path, type) {\n    if ('boolean' != typeof type.selected) return;\n\n    if (fields && ('+' + path) in fields) {\n      // forced inclusion\n      delete fields['+' + path];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (false === exclude && keys.length > 1) {\n        fields[path] = 1;\n      }\n\n      return\n    };\n\n    ;(type.selected ? selected : excluded).push(path);\n  });\n\n  switch (exclude) {\n    case true:\n      excluded.length && this.select('-' + excluded.join(' -'));\n      break;\n    case false:\n      selected.length && this.select(selected.join(' '));\n      break;\n    case undefined:\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields\n      excluded.length && this.select('-' + excluded.join(' -'));\n      break;\n  }\n}",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "_applyPaths",
      "string": "Query.prototype._applyPaths()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String",
          "Function"
        ],
        "name": "js",
        "description": "is a javascript string or anonymous function"
      },
      {
        "type": "return",
        "types": [
          "Query"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>$where</p>\n\n<p>Sometimes you need to query for things in mongodb using a JavaScript<br />expression. You can do so via find({$where: javascript}), or you can<br />use the mongoose shortcut method $where via a Query chain or from<br />your mongoose Model.</p>",
      "summary": "<p>$where</p>",
      "body": "<p>Sometimes you need to query for things in mongodb using a JavaScript<br />expression. You can do so via find({$where: javascript}), or you can<br />use the mongoose shortcut method $where via a Query chain or from<br />your mongoose Model.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.$where = function (js) {\n  this._conditions['$where'] = js;\n  return this;\n};"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "val",
        "description": "(optional)"
      },
      {
        "type": "TODO",
        "string": "deprecate?"
      },
      {
        "type": "return",
        "types": [
          "Query"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>where</p>\n\n<p>Sugar for query.find().</p>\n\n<p>For example, instead of writing:</p>\n\n<pre><code>User.find({age: {$gte: 21, $lte: 65}}, callback);\n</code></pre>\n\n<p>we can instead write:</p>\n\n<pre><code>User.where('age').gte(21).lte(65);\n</code></pre>\n\n<p>Moreover, you can also chain a bunch of these together:</p>\n\n<pre><code>User\n</code></pre>\n\n<p>.where('age').gte(21).lte(65)<br />   .where('name', /^b/i)        // All names that begin where b or B<br />   .where('friends').slice(10);</p>",
      "summary": "<p>where</p>",
      "body": "<p>Sugar for query.find().</p>\n\n<p>For example, instead of writing:</p>\n\n<pre><code>User.find({age: {$gte: 21, $lte: 65}}, callback);\n</code></pre>\n\n<p>we can instead write:</p>\n\n<pre><code>User.where('age').gte(21).lte(65);\n</code></pre>\n\n<p>Moreover, you can also chain a bunch of these together:</p>\n\n<pre><code>User\n</code></pre>\n\n<p>.where('age').gte(21).lte(65)<br />   .where('name', /^b/i)        // All names that begin where b or B<br />   .where('friends').slice(10);</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.where = function (path, val) {\n  if (!arguments.length) return this;\n\n  if ('string' != typeof path) {\n    throw new TypeError('path must be a string');\n  }\n\n  this._currPath = path;\n\n  if (2 === arguments.length) {\n    this._conditions[path] = val;\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "where",
      "string": "Query.prototype.where()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "object"
        ],
        "name": "val",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Query"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p><code>equals</code> sugar.</p>\n\n<pre><code>User.where('age').equals(49);\n</code></pre>\n\n<p>Same as</p>\n\n<pre><code>User.where('age', 49);\n</code></pre>",
      "summary": "<p><code>equals</code> sugar.</p>",
      "body": "<pre><code>User.where('age').equals(49);\n</code></pre>\n\n<p>Same as</p>\n\n<pre><code>User.where('age', 49);\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.equals = function equals (val) {\n  var path = this._currPath;\n  if (!path) throw new Error('equals() must be used after where()');\n  this._conditions[path] = val;\n  return this;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "equals",
      "string": "Query.prototype.equals()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>or</p>",
      "summary": "<p>or</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Query.prototype.or = function or (array) {\n  var or = this._conditions.$or || (this._conditions.$or = []);\n  if (!Array.isArray(array)) array = [array];\n  or.push.apply(or, array);\n  return this;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "or",
      "string": "Query.prototype.or()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>nor</p>",
      "summary": "<p>nor</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Query.prototype.nor = function nor (array) {\n  var nor = this._conditions.$nor || (this._conditions.$nor = []);\n  if (!Array.isArray(array)) array = [array];\n  nor.push.apply(nor, array);\n  return this;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "nor",
      "string": "Query.prototype.nor()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance</p>\n\n<p>Can be used on Numbers or Dates.</p>\n\n<pre><code>Thing.where('type').nin(array)\n</code></pre>",
      "summary": "<p>gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance</p>",
      "body": "<p>Can be used on Numbers or Dates.</p>\n\n<pre><code>Thing.where('type').nin(array)\n</code></pre>"
    },
    "ignore": false,
    "code": "'gt gte lt lte ne in nin all regex size maxDistance'.split(' ').forEach(function ($conditional) {\n  Query.prototype[$conditional] = function (path, val) {\n    if (arguments.length === 1) {\n      val = path;\n      path = this._currPath\n    }\n    var conds = this._conditions[path] || (this._conditions[path] = {});\n    conds['$' + $conditional] = val;\n    return this;\n  };\n});"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>mod, near</p>",
      "summary": "<p>mod, near</p>",
      "body": ""
    },
    "ignore": false,
    "code": ";['mod', 'near'].forEach(function ($conditional) {\n  Query.prototype[$conditional] = function (path, val) {\n    if (arguments.length === 1) {\n      val = path;\n      path = this._currPath\n    } else if (arguments.length === 2 && !Array.isArray(val)) {\n      val = utils.args(arguments);\n      path = this._currPath;\n    } else if (arguments.length === 3) {\n      val = utils.args(arguments, 1);\n    }\n    var conds = this._conditions[path] || (this._conditions[path] = {});\n    conds['$' + $conditional] = val;\n    return this;\n  };\n});"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>exists</p>",
      "summary": "<p>exists</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Query.prototype.exists = function (path, val) {\n  if (arguments.length === 0) {\n    path = this._currPath\n    val = true;\n  } else if (arguments.length === 1) {\n    if ('boolean' === typeof path) {\n      val = path;\n      path = this._currPath;\n    } else {\n      val = true;\n    }\n  }\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds['$exists'] = val;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "exists",
      "string": "Query.prototype.exists()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>elemMatch</p>",
      "summary": "<p>elemMatch</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Query.prototype.elemMatch = function (path, criteria) {\n  var block;\n  if ('Object' === path.constructor.name) {\n    criteria = path;\n    path = this._currPath;\n  } else if ('function' === typeof path) {\n    block = path;\n    path = this._currPath;\n  } else if ('Object' === criteria.constructor.name) {\n  } else if ('function' === typeof criteria) {\n    block = criteria;\n  } else {\n    throw new Error(\"Argument error\");\n  }\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  if (block) {\n    criteria = new Query();\n    block(criteria);\n    conds['$elemMatch'] = criteria._conditions;\n  } else {\n    conds['$elemMatch'] = criteria;\n  }\n  return this;\n};\n\n// Spatial queries",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "elemMatch",
      "string": "Query.prototype.elemMatch()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "this"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>within</p>\n\n<h2>Example</h2>\n\n<pre><code>query.within.box()\nquery.within.center()\n</code></pre>",
      "summary": "<p>within</p>",
      "body": "<h2>Example</h2>\n\n<pre><code>query.within.box()\nquery.within.center()\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Object.defineProperty(Query.prototype, 'within', {\n  get: function () { return this }\n});"
  },
  {
    "tags": [
      {
        "type": "see",
        "title": "",
        "url": "http://www.mongodb.org/display/DOCS/Geospatial+Indexing",
        "visibility": "http://www.mongodb.org/display/DOCS/Geospatial+Indexing"
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "val",
        "description": ""
      }
    ],
    "description": {
      "full": "<p>box</p>\n\n<p>Specifies a $box query.</p>\n\n<h2>Example</h2>\n\n<pre><code>var lowerLeft = [40.73083, -73.99756]\nvar upperRight= [40.741404,  -73.988135]\nquery.where('loc').within.box({ ll: lowerLeft , ur: upperRight })\n</code></pre>",
      "summary": "<p>box</p>",
      "body": "<p>Specifies a $box query.</p>\n\n<h2>Example</h2>\n\n<pre><code>var lowerLeft = [40.73083, -73.99756]\nvar upperRight= [40.741404,  -73.988135]\nquery.where('loc').within.box({ ll: lowerLeft , ur: upperRight })\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.box = function (path, val) {\n  if (arguments.length === 1) {\n    val = path;\n    path = this._currPath;\n  }\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds['$within'] = { '$box': [val.ll, val.ur]  };\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "box",
      "string": "Query.prototype.box()"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "title": "",
        "url": "http://www.mongodb.org/display/DOCS/Geospatial+Indexing",
        "visibility": "http://www.mongodb.org/display/DOCS/Geospatial+Indexing"
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "val",
        "description": ""
      }
    ],
    "description": {
      "full": "<p>center</p>\n\n<p>Specifies a $center query.</p>\n\n<h2>Example</h2>\n\n<pre><code>var area = { center: [50, 50], radius: 10 }\nquery.where('loc').within.center(area)\n</code></pre>",
      "summary": "<p>center</p>",
      "body": "<p>Specifies a $center query.</p>\n\n<h2>Example</h2>\n\n<pre><code>var area = { center: [50, 50], radius: 10 }\nquery.where('loc').within.center(area)\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.center = function (path, val) {\n  if (arguments.length === 1) {\n    val = path;\n    path = this._currPath;\n  }\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds['$within'] = { '$center': [val.center, val.radius]  };\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "center",
      "string": "Query.prototype.center()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>centerSphere</p>",
      "summary": "<p>centerSphere</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Query.prototype.centerSphere = function (path, val) {\n  if (arguments.length === 1) {\n    val = path;\n    path = this._currPath;\n  }\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds['$within'] = { '$centerSphere': [val.center, val.radius]  };\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "centerSphere",
      "string": "Query.prototype.centerSphere()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object",
          "String"
        ],
        "name": "",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>select</p>\n\n<p>Specifies which fields to include or exclude from<br />the document that is returned from MongoDB.</p>\n\n<h2>Example</h2>\n\n<pre><code>query.select('a b -c');\nquery.select({a: 1, b: 1, c: 0}); // useful if you have keys that start with \"-\"\nquery.select('+path') // force inclusion of field excluded at schema level\n</code></pre>",
      "summary": "<p>select</p>",
      "body": "<p>Specifies which fields to include or exclude from<br />the document that is returned from MongoDB.</p>\n\n<h2>Example</h2>\n\n<pre><code>query.select('a b -c');\nquery.select({a: 1, b: 1, c: 0}); // useful if you have keys that start with \"-\"\nquery.select('+path') // force inclusion of field excluded at schema level\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.select = function select (arg) {\n  if (!arg) return this;\n\n  var fields = this._fields || (this._fields = {});\n\n  if ('Object' === arg.constructor.name) {\n    Object.keys(arg).forEach(function (field) {\n      fields[field] = arg[field];\n    });\n  } else if (1 === arguments.length && 'string' == typeof arg) {\n    arg.split(/\\s+/).forEach(function (field) {\n      if (!field) return;\n      var include = '-' == field[0] ? 0 : 1;\n      if (include === 0) field = field.substring(1);\n      fields[field] = include;\n    });\n  } else {\n    throw new TypeError('Invalid select() argument. Must be a string or object.');\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "select",
      "string": "Query.prototype.select()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>slice()</p>",
      "summary": "<p>slice()</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Query.prototype.slice = function (path, val) {\n  if (arguments.length === 1) {\n      val = path;\n      path = this._currPath\n  } else if (arguments.length === 2) {\n    if ('number' === typeof path) {\n      val = [path, val];\n      path = this._currPath;\n    }\n  } else if (arguments.length === 3) {\n    val = utils.args(arguments, 1);\n  }\n  var myFields = this._fields || (this._fields = {});\n  myFields[path] = { '$slice': val };\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "slice",
      "string": "Query.prototype.slice()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object",
          "String"
        ],
        "name": "",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>sort</p>\n\n<p>Sets the sort order. Accepts a single parameter, either an object or string.<br />If an object is passed values allowed are 'asc', 'desc', 'ascending', 'descending', 1, -1.<br />If a string is passed it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with <code>-</code> which will be treated as descending.</p>\n\n<h2>Examples</h2>\n\n<pre><code>// these are equivalent\nquery.sort({ field: 'asc', test: -1 });\nquery.sort('field -test');\n</code></pre>",
      "summary": "<p>sort</p>",
      "body": "<p>Sets the sort order. Accepts a single parameter, either an object or string.<br />If an object is passed values allowed are 'asc', 'desc', 'ascending', 'descending', 1, -1.<br />If a string is passed it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with <code>-</code> which will be treated as descending.</p>\n\n<h2>Examples</h2>\n\n<pre><code>// these are equivalent\nquery.sort({ field: 'asc', test: -1 });\nquery.sort('field -test');\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.sort = function (arg) {\n  if (!arg) return this;\n\n  var sort = this.options.sort || (this.options.sort = []);\n\n  if ('Object' === arg.constructor.name) {\n    Object.keys(arg).forEach(function (field) {\n      push(sort, field, arg[field]);\n    });\n  } else if (1 === arguments.length && 'string' == typeof arg) {\n    arg.split(/\\s+/).forEach(function (field) {\n      if (!field) return;\n      var ascend = '-' == field[0] ? -1 : 1;\n      if (ascend === -1) field = field.substring(1);\n      push(sort, field, ascend);\n    });\n  } else {\n    throw new TypeError('Invalid sort() argument. Must be a string or object.');\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "sort",
      "string": "Query.prototype.sort()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>@ignore</p>",
      "summary": "<p>@ignore</p>",
      "body": ""
    },
    "ignore": false,
    "code": "function push (arr, field, value) {\n  var val = String(value || 1).toLowerCase();\n  if (!/^(?:ascending|asc|descending|desc|1|-1)$/.test(val)) {\n    if (Array.isArray(value)) value = '['+value+']';\n    throw new TypeError('Invalid sort value: {' + field + ': ' + value + ' }');\n  }\n  arr.push([field, value]);\n}",
    "ctx": {
      "type": "function",
      "name": "push",
      "string": "push()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>limit, skip, maxscan, snapshot, batchSize, comment</p>\n\n<p>Sets these associated options.</p>\n\n<pre><code>query.comment('feed query');\n</code></pre>",
      "summary": "<p>limit, skip, maxscan, snapshot, batchSize, comment</p>",
      "body": "<p>Sets these associated options.</p>\n\n<pre><code>query.comment('feed query');\n</code></pre>"
    },
    "ignore": false,
    "code": ";['limit', 'skip', 'maxscan', 'snapshot', 'batchSize', 'comment'].forEach(function (method) {\n  Query.prototype[method] = function (v) {\n    this.options[method] = v;\n    return this;\n  };\n});"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "val",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Query"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>hint</p>\n\n<p>Sets query hints.</p>\n\n<h2>Examples</h2>\n\n<pre><code>new Query().hint({ indexA: 1, indexB: -1})\n</code></pre>",
      "summary": "<p>hint</p>",
      "body": "<p>Sets query hints.</p>\n\n<h2>Examples</h2>\n\n<pre><code>new Query().hint({ indexA: 1, indexB: -1})\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.hint = function (val) {\n  if (!val) return this;\n\n  var hint = this.options.hint || (this.options.hint = {});\n\n  if ('Object' === val.constructor.name) {\n    // must keep object keys in order so don't use Object.keys()\n    for (var k in val) {\n      hint[k] = val[k];\n    }\n  } else {\n    throw new TypeError('Invalid hint. ' + val);\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "hint",
      "string": "Query.prototype.hint()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "v",
        "description": "(defaults to true)"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>slaveOk</p>\n\n<p>Sets slaveOk option.</p>\n\n<pre><code>new Query().slaveOk() &lt;== true\nnew Query().slaveOk(true)\nnew Query().slaveOk(false)\n</code></pre>",
      "summary": "<p>slaveOk</p>",
      "body": "<p>Sets slaveOk option.</p>\n\n<pre><code>new Query().slaveOk() &lt;== true\nnew Query().slaveOk(true)\nnew Query().slaveOk(false)\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.slaveOk = function (v) {\n  this.options.slaveOk = arguments.length ? !!v : true;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "slaveOk",
      "string": "Query.prototype.slaveOk()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "v",
        "description": "(defaults to true)"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>tailable</p>\n\n<p>Sets tailable option.</p>\n\n<pre><code>new Query().tailable() &lt;== true\nnew Query().tailable(true)\nnew Query().tailable(false)\n</code></pre>",
      "summary": "<p>tailable</p>",
      "body": "<p>Sets tailable option.</p>\n\n<pre><code>new Query().tailable() &lt;== true\nnew Query().tailable(true)\nnew Query().tailable(false)\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.tailable = function (v) {\n  this.options.tailable = arguments.length ? !!v : true;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "tailable",
      "string": "Query.prototype.tailable()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>execFind</p>",
      "summary": "<p>execFind</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Query.prototype.execFind = function (callback) {\n  var model = this.model\n    , promise = new Promise(callback);\n\n  try {\n    this.cast(model);\n  } catch (err) {\n    return promise.error(err);\n  }\n\n  // apply default schematype path selections\n  this._applyPaths();\n\n  var self = this\n    , castQuery = this._conditions\n    , options = this._optionsForExec(model)\n\n  var fields = utils.clone(options.fields = this._fields);\n\n  model.collection.find(castQuery, options, function (err, cursor) {\n    if (err) return promise.error(err);\n    cursor.toArray(tick(cb));\n  });\n\n  function cb (err, docs) {\n    if (err) return promise.error(err);\n\n    if (true === options.lean)\n      return promise.complete(docs);\n\n    var arr = []\n      , count = docs.length;\n\n    if (!count) return promise.complete([]);\n\n    for (var i = 0, l = docs.length; i < l; i++) {\n      arr[i] = new model(undefined, fields, true);\n      arr[i].init(docs[i], self, function (err) {\n        if (err) return promise.error(err);\n        --count || promise.complete(arr);\n      });\n    }\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "execFind",
      "string": "Query.prototype.execFind()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": "function (err, found)"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>findOne</p>\n\n<p>Casts the query, sends the findOne command to mongodb.<br />Upon receiving the document, we initialize a mongoose<br />document based on the returned document from mongodb,<br />and then we invoke a callback on our mongoose document.</p>",
      "summary": "<p>findOne</p>",
      "body": "<p>Casts the query, sends the findOne command to mongodb.<br />Upon receiving the document, we initialize a mongoose<br />document based on the returned document from mongodb,<br />and then we invoke a callback on our mongoose document.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.findOne = function (callback) {\n  this.op = 'findOne';\n\n  if (!callback) return this;\n\n  var model = this.model;\n  var promise = new Promise(callback);\n\n  try {\n    this.cast(model);\n  } catch (err) {\n    promise.error(err);\n    return this;\n  }\n\n  // apply default schematype path selections\n  this._applyPaths();\n\n  var self = this\n    , castQuery = this._conditions\n    , options = this._optionsForExec(model)\n\n  var fields = utils.clone(options.fields = this._fields);\n\n  model.collection.findOne(castQuery, options, tick(function (err, doc) {\n    if (err) return promise.error(err);\n    if (!doc) return promise.complete(null);\n\n    if (true === options.lean) return promise.complete(doc);\n\n    var casted = new model(undefined, fields, true);\n    casted.init(doc, self, function (err) {\n      if (err) return promise.error(err);\n      promise.complete(casted);\n    });\n  }));\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "findOne",
      "string": "Query.prototype.findOne()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": "fn(err, cardinality)"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>count</p>\n\n<p>Casts this._conditions and sends a count<br />command to mongodb. Invokes a callback upon<br />receiving results</p>",
      "summary": "<p>count</p>",
      "body": "<p>Casts this._conditions and sends a count<br />command to mongodb. Invokes a callback upon<br />receiving results</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.count = function (callback) {\n  this.op = 'count';\n  var model = this.model;\n\n  try {\n    this.cast(model);\n  } catch (err) {\n    return callback(err);\n  }\n\n  var castQuery = this._conditions;\n  model.collection.count(castQuery, tick(callback));\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "count",
      "string": "Query.prototype.count()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": "fn(err, cardinality)"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>distinct</p>\n\n<p>Casts this._conditions and sends a distinct<br />command to mongodb. Invokes a callback upon<br />receiving results</p>",
      "summary": "<p>distinct</p>",
      "body": "<p>Casts this._conditions and sends a distinct<br />command to mongodb. Invokes a callback upon<br />receiving results</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.distinct = function (field, callback) {\n  this.op = 'distinct';\n  var model = this.model;\n\n  try {\n    this.cast(model);\n  } catch (err) {\n    return callback(err);\n  }\n\n  var castQuery = this._conditions;\n  model.collection.distinct(field, castQuery, tick(callback));\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "distinct",
      "string": "Query.prototype.distinct()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>These operators require casting docs<br />to real Documents for Update operations.</p>",
      "summary": "<p>These operators require casting docs<br />to real Documents for Update operations.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var castOps = {\n    $push: 1\n  , $pushAll: 1\n  , $addToSet: 1\n  , $set: 1\n};",
    "ctx": {
      "type": "declaration",
      "name": "castOps",
      "value": "{",
      "string": "castOps"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>These operators should be cast to numbers instead<br />of their path schema type.</p>",
      "summary": "<p>These operators should be cast to numbers instead<br />of their path schema type.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "var numberOps = {\n    $pop: 1\n  , $unset: 1\n  , $inc: 1\n}",
    "ctx": {
      "type": "declaration",
      "name": "numberOps",
      "value": "{",
      "string": "numberOps"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "doc",
        "description": "- the update"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": "- fn(err)"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>update</p>\n\n<p>Casts the <code>doc</code> according to the model Schema and<br />sends an update command to MongoDB.</p>\n\n<p><em>All paths passed that are not $atomic operations<br />will become $set ops so we retain backwards compatibility.</em></p>\n\n<h2>Example</h2>\n\n<p><code>Model.update({..}, { title: 'remove words' }, ...)</code></p>\n\n<p>becomes</p>\n\n<p><code>Model.update({..}, { $set: { title: 'remove words' }}, ...)</code></p>\n\n<p><em>Passing an empty object <code>{}</code> as the doc will result<br />in a no-op. The update operation will be ignored and the<br />callback executed without sending the command to MongoDB so as<br />to prevent accidently overwritting the collection.</em></p>",
      "summary": "<p>update</p>",
      "body": "<p>Casts the <code>doc</code> according to the model Schema and<br />sends an update command to MongoDB.</p>\n\n<p><em>All paths passed that are not $atomic operations<br />will become $set ops so we retain backwards compatibility.</em></p>\n\n<h2>Example</h2>\n\n<p><code>Model.update({..}, { title: 'remove words' }, ...)</code></p>\n\n<p>becomes</p>\n\n<p><code>Model.update({..}, { $set: { title: 'remove words' }}, ...)</code></p>\n\n<p><em>Passing an empty object <code>{}</code> as the doc will result<br />in a no-op. The update operation will be ignored and the<br />callback executed without sending the command to MongoDB so as<br />to prevent accidently overwritting the collection.</em></p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.update = function update (doc, callback) {\n  this.op = 'update';\n  this._updateArg = doc;\n\n  var model = this.model\n    , options = this._optionsForExec(model)\n    , fn = 'function' == typeof callback\n    , castedQuery\n    , castedDoc\n\n  castedQuery = castQuery(this);\n  if (castedQuery instanceof Error) {\n    if (fn) {\n      process.nextTick(callback.bind(null, castedQuery));\n      return this;\n    }\n    throw castedQuery;\n  }\n\n  castedDoc = castDoc(this);\n  if (!castedDoc) {\n    fn && process.nextTick(callback.bind(null, null, 0));\n    return this;\n  }\n\n  if (castedDoc instanceof Error) {\n    if (fn) {\n      process.nextTick(callback.bind(null, castedDoc));\n      return this;\n    }\n    throw castedDoc;\n  }\n\n  if (!fn) {\n    delete options.safe;\n  }\n\n  model.collection.update(castedQuery, castedDoc, options, tick(callback));\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "update",
      "string": "Query.prototype.update()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": "obj after casting its values"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts obj for an update command.</p>",
      "summary": "<p>Casts obj for an update command.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Query.prototype._castUpdate = function _castUpdate (obj) {\n  var ops = Object.keys(obj)\n    , i = ops.length\n    , ret = {}\n    , hasKeys\n    , val\n\n  while (i--) {\n    var op = ops[i];\n    if ('$' !== op[0]) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if ('$set' === op) {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n\n  // cast each value\n  i = ops.length;\n\n  while (i--) {\n    op = ops[i];\n    val = ret[op];\n    if ('Object' === val.constructor.name) {\n      hasKeys |= this._walkUpdatePath(val, op);\n    } else {\n      var msg = 'Invalid atomic update value for ' + op + '. '\n              + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n  }\n\n  return hasKeys && ret;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "_castUpdate",
      "string": "Query.prototype._castUpdate()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": "- part of a query"
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "op",
        "description": "- the atomic operator ($pull, $set, etc)"
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "pref",
        "description": "- path prefix (internal only)"
      },
      {
        "type": "return",
        "types": [
          "Bool"
        ],
        "description": "true if this path has keys to update"
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Walk each path of obj and cast its values<br />according to its schema.</p>",
      "summary": "<p>Walk each path of obj and cast its values<br />according to its schema.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype._walkUpdatePath = function _walkUpdatePath (obj, op, pref) {\n  var strict = this.model.schema.options.strict\n    , prefix = pref ? pref + '.' : ''\n    , keys = Object.keys(obj)\n    , i = keys.length\n    , hasKeys = false\n    , schema\n    , key\n    , val\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (val && 'Object' === val.constructor.name) {\n      // watch for embedded doc schemas\n      schema = this._getSchema(prefix + key);\n      if (schema && schema.caster && op in castOps) {\n        // embedded doc schema\n\n        if (strict && !schema) {\n          // path is not in our strict schema\n          if ('throw' == strict) {\n            throw new Error('Field `' + key + '` is not in schema.');\n          } else {\n            // ignore paths not specified in schema\n            delete obj[key];\n          }\n        } else {\n          hasKeys = true;\n          if ('$each' in val) {\n            obj[key] = {\n                $each: this._castUpdateVal(schema, val.$each, op)\n            }\n          } else {\n            obj[key] = this._castUpdateVal(schema, val, op);\n          }\n        }\n      } else {\n        hasKeys |= this._walkUpdatePath(val, op, prefix + key);\n      }\n    } else {\n      schema = '$each' === key\n        ? this._getSchema(pref)\n        : this._getSchema(prefix + key);\n\n      var skip = strict &&\n                 !schema &&\n                 !/real|nested/.test(this.model.schema.pathType(prefix + key));\n\n      if (skip) {\n        if ('throw' == strict) {\n          throw new Error('Field `' + prefix + key + '` is not in schema.');\n        } else {\n          delete obj[key];\n        }\n      } else {\n        hasKeys = true;\n        obj[key] = this._castUpdateVal(schema, val, op, key);\n      }\n    }\n  }\n  return hasKeys;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "_walkUpdatePath",
      "string": "Query.prototype._walkUpdatePath()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Schema"
        ],
        "name": "schema",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "val",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "op",
        "description": "- the atomic operator ($pull, $set, etc)"
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[$conditional]",
        "description": ""
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Casts <code>val</code> according to <code>schema</code> and atomic <code>op</code>.</p>",
      "summary": "<p>Casts <code>val</code> according to <code>schema</code> and atomic <code>op</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype._castUpdateVal = function _castUpdateVal (schema, val, op, $conditional) {\n  if (!schema) {\n    // non-existing schema path\n    return op in numberOps\n      ? Number(val)\n      : val\n  }\n\n  if (schema.caster && op in castOps &&\n    ('Object' === val.constructor.name || Array.isArray(val))) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    var tmp = schema.cast(val);\n\n    if (Array.isArray(val)) {\n      val = tmp;\n    } else {\n      val = tmp[0];\n    }\n  }\n\n  if (op in numberOps) return Number(val);\n  if (/^\\$/.test($conditional)) return schema.castForQuery($conditional, val);\n  return schema.castForQuery(val)\n}",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "_castUpdateVal",
      "string": "Query.prototype._castUpdateVal()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Finds the schema for <code>path</code>. This is different than<br />calling <code>schema.path</code> as it also resolves paths with<br />positional selectors (something.$.another.$.path).</p>",
      "summary": "<p>Finds the schema for <code>path</code>. This is different than<br />calling <code>schema.path</code> as it also resolves paths with<br />positional selectors (something.$.another.$.path).</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype._getSchema = function _getSchema (path) {\n  var schema = this.model.schema\n    , pathschema = schema.path(path);\n\n  if (pathschema)\n    return pathschema;\n\n  // look for arrays\n  return (function search (parts, schema) {\n    var p = parts.length + 1\n      , foundschema\n      , trypath\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.caster) {\n\n          // array of Mixed?\n          if (foundschema.caster instanceof Types.Mixed) {\n            return foundschema.caster;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          if (p !== parts.length) {\n            if ('$' === parts[p]) {\n              // comments.$.comments.$.title\n              return search(parts.slice(p+1), foundschema.schema);\n            } else {\n              // this is the last path of the selector\n              return search(parts.slice(p), foundschema.schema);\n            }\n          }\n        }\n        return foundschema;\n      }\n    }\n  })(path.split('.'), schema)\n}",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "_getSchema",
      "string": "Query.prototype._getSchema()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>remove</p>\n\n<p>Casts the query, sends the remove command to<br />mongodb where the query contents, and then<br />invokes a callback upon receiving the command<br />result.</p>",
      "summary": "<p>remove</p>",
      "body": "<p>Casts the query, sends the remove command to<br />mongodb where the query contents, and then<br />invokes a callback upon receiving the command<br />result.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.remove = function (callback) {\n  this.op = 'remove';\n\n  var model = this.model\n    , options = this._optionsForExec(model)\n    , cb = 'function' == typeof callback\n\n  try {\n    this.cast(model);\n  } catch (err) {\n    if (cb) return callback(err);\n    throw err;\n  }\n\n  if (!cb) {\n    delete options.safe;\n  }\n\n  var castQuery = this._conditions;\n  model.collection.remove(castQuery, options, tick(callback));\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "remove",
      "string": "Query.prototype.remove()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "query",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "doc",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>findOneAndUpdate</p>\n\n<p>Issues a mongodb findAndModify update command.</p>\n\n<p>Finds a matching document, updates it according to the <code>update</code><br />arg, passing any <code>options</code>, and returns the found document<br />(if any) to the callback. The query executes immediately if<br /><code>callback</code> is passed else a Query object is returned.</p>\n\n<h2>Available options</h2>\n\n<p><code>new</code>: bool - true to return the modified document rather than the original. defaults to true<br />  <code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.<br />  <code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</p>\n\n<h2>Examples</h2>\n\n<pre><code>query.findOneAndUpdate(conditions, update, options, callback) // executes\nquery.findOneAndUpdate(conditions, update, options)  // returns Query\nquery.findOneAndUpdate(conditions, update, callback) // executes\nquery.findOneAndUpdate(conditions, update)           // returns Query\nquery.findOneAndUpdate(callback)                     // executes\nquery.findOneAndUpdate()                             // returns Query\n</code></pre>",
      "summary": "<p>findOneAndUpdate</p>",
      "body": "<p>Issues a mongodb findAndModify update command.</p>\n\n<p>Finds a matching document, updates it according to the <code>update</code><br />arg, passing any <code>options</code>, and returns the found document<br />(if any) to the callback. The query executes immediately if<br /><code>callback</code> is passed else a Query object is returned.</p>\n\n<h2>Available options</h2>\n\n<p><code>new</code>: bool - true to return the modified document rather than the original. defaults to true<br />  <code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.<br />  <code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</p>\n\n<h2>Examples</h2>\n\n<pre><code>query.findOneAndUpdate(conditions, update, options, callback) // executes\nquery.findOneAndUpdate(conditions, update, options)  // returns Query\nquery.findOneAndUpdate(conditions, update, callback) // executes\nquery.findOneAndUpdate(conditions, update)           // returns Query\nquery.findOneAndUpdate(callback)                     // executes\nquery.findOneAndUpdate()                             // returns Query\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.findOneAndUpdate = function (query, doc, options, callback) {\n  this.op = 'findOneAndUpdate';\n\n  switch (arguments.length) {\n    case 3:\n      if ('function' == typeof options)\n        callback = options, options = {};\n      break;\n    case 2:\n      if ('function' == typeof doc) {\n        callback = doc;\n        doc = query;\n        query = undefined;\n      }\n      options = undefined;\n      break;\n    case 1:\n      if ('function' == typeof query) {\n        callback = query;\n        query = options = doc = undefined;\n      } else {\n        doc = query;\n        query = options = undefined;\n      }\n  }\n\n  // apply query\n  if (query) {\n    if ('Object' === query.constructor.name) {\n      merge(this._conditions, query);\n    } else if (query instanceof Query) {\n      merge(this._conditions, query._conditions);\n    } else if (query instanceof Document) {\n      merge(this._conditions, query.toObject());\n    }\n  }\n\n  // apply doc\n  if (doc) {\n    merge(this._updateArg, doc);\n  }\n\n  // apply options\n  options && this.setOptions(options);\n\n  if (!callback) return this;\n\n  return this._findAndModify('update', callback);\n}",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "findOneAndUpdate",
      "string": "Query.prototype.findOneAndUpdate()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "conditions",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>findOneAndRemove</p>\n\n<p>Issues a mongodb findAndModify remove command.</p>\n\n<p>Finds a matching document, removes it, passing the found<br />document (if any) to the callback. Executes immediately if <code>callback</code><br />is passed else a Query object is returned.</p>\n\n<h2>Available options</h2>\n\n<p><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</p>\n\n<h2>Examples</h2>\n\n<pre><code>A.where().findOneAndRemove(conditions, options, callback) // executes\nA.where().findOneAndRemove(conditions, options)  // return Query\nA.where().findOneAndRemove(conditions, callback) // executes\nA.where().findOneAndRemove(conditions) // returns Query\nA.where().findOneAndRemove(callback)   // executes\nA.where().findOneAndRemove()           // returns Query\n</code></pre>",
      "summary": "<p>findOneAndRemove</p>",
      "body": "<p>Issues a mongodb findAndModify remove command.</p>\n\n<p>Finds a matching document, removes it, passing the found<br />document (if any) to the callback. Executes immediately if <code>callback</code><br />is passed else a Query object is returned.</p>\n\n<h2>Available options</h2>\n\n<p><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</p>\n\n<h2>Examples</h2>\n\n<pre><code>A.where().findOneAndRemove(conditions, options, callback) // executes\nA.where().findOneAndRemove(conditions, options)  // return Query\nA.where().findOneAndRemove(conditions, callback) // executes\nA.where().findOneAndRemove(conditions) // returns Query\nA.where().findOneAndRemove(callback)   // executes\nA.where().findOneAndRemove()           // returns Query\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.findOneAndRemove = function (conditions, options, callback) {\n  this.op = 'findOneAndRemove';\n\n  if ('function' == typeof options) {\n    callback = options;\n    options = undefined;\n  } else if ('function' == typeof conditions) {\n    callback = conditions;\n    conditions = undefined;\n  }\n\n  // apply conditions\n  if (conditions) {\n    if ('Object' === conditions.constructor.name) {\n      merge(this._conditions, conditions);\n    } else if (conditions instanceof Query) {\n      merge(this._conditions, conditions._conditions);\n    } else if (conditions instanceof Document) {\n      merge(this._conditions, conditions.toObject());\n    }\n  }\n\n  // apply options\n  options && this.setOptions(options);\n\n  if (!callback) return this;\n\n  return this._findAndModify('remove', callback);\n}",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "findOneAndRemove",
      "string": "Query.prototype.findOneAndRemove()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "type",
        "description": "- either \"remove\" or \"update\""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>_findAndModify</p>",
      "summary": "<p>_findAndModify</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Query.prototype._findAndModify = function (type, callback) {\n  var model = this.model\n    , promise = new Promise(callback)\n    , self = this\n    , castedQuery\n    , castedDoc\n    , fields\n    , sort\n    , opts\n\n  castedQuery = castQuery(this);\n  if (castedQuery instanceof Error) {\n    process.nextTick(promise.error.bind(promise, castedQuery));\n    return promise;\n  }\n\n  opts = this._optionsForExec(model);\n\n  if ('remove' == type) {\n    opts.remove = true;\n  } else {\n    if (!('new' in opts)) opts.new = true;\n    if (!('upsert' in opts)) opts.upsert = false;\n\n    castedDoc = castDoc(this);\n    if (!castedDoc) {\n      if (opts.upsert) {\n        // still need to do the upsert to empty doc\n        castedDoc = { $set: {} };\n      } else {\n        return this.findOne(callback);\n      }\n    } else if (castedDoc instanceof Error) {\n      process.nextTick(promise.error.bind(promise, castedDoc));\n      return promise;\n    }\n  }\n\n  if (this._fields) {\n    fields = utils.clone(opts.fields = this._fields);\n  }\n\n  // the driver needs a default\n  sort = opts.sort || [];\n\n  model\n  .collection\n  .findAndModify(castedQuery, sort, castedDoc, opts, tick(function (err, doc) {\n    if (err) return promise.error(err);\n    if (!doc) return promise.complete(null);\n\n    if (true === opts.lean) {\n      return promise.complete(doc);\n    }\n\n    var casted = new model(undefined, fields, true);\n    casted.init(doc, self, function (err) {\n      if (err) return promise.error(err);\n      promise.complete(casted);\n    });\n  }));\n\n  return promise;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "_findAndModify",
      "string": "Query.prototype._findAndModify()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>populate</p>\n\n<p>Sets population options.</p>",
      "summary": "<p>populate</p>",
      "body": "<p>Sets population options.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.populate = function (path, fields, model, conditions, options) {\n  if ('string' !== typeof model) {\n    options = conditions;\n    conditions = model;\n    model = undefined;\n  }\n  // The order of fields/conditions args is opposite Model.find but\n  // necessary to keep backward compatibility (fields could be\n  // an array, string, or object literal).\n  this.options.populate[path] =\n    new PopulateOptions(fields, conditions, options, model);\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "populate",
      "string": "Query.prototype.populate()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Populate options constructor</p>",
      "summary": "<p>Populate options constructor</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function PopulateOptions (fields, conditions, options, model) {\n  this.conditions = conditions;\n  this.fields = fields;\n  this.options = options;\n  this.model = model;\n}\n\n// make it compatible with utils.clone\nPopulateOptions.prototype.constructor = Object;",
    "ctx": {
      "type": "function",
      "name": "PopulateOptions",
      "string": "PopulateOptions()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>stream</p>\n\n<p>Returns a stream interface</p>\n\n<h2>Example</h2>\n\n<pre><code>Thing.find({ name: /^hello/ }).stream().pipe(res)\n</code></pre>",
      "summary": "<p>stream</p>",
      "body": "<p>Returns a stream interface</p>\n\n<h2>Example</h2>\n\n<pre><code>Thing.find({ name: /^hello/ }).stream().pipe(res)\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Query.prototype.stream = function stream () {\n  return new QueryStream(this);\n}\n\n// helpers",
    "ctx": {
      "type": "method",
      "constructor": "Query",
      "name": "stream",
      "string": "Query.prototype.stream()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>castDoc</p>",
      "summary": "<p>castDoc</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function castDoc (query) {\n  try {\n    return query._castUpdate(query._updateArg);\n  } catch (err) {\n    return err;\n  }\n}",
    "ctx": {
      "type": "function",
      "name": "castDoc",
      "string": "castDoc()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>castQuery</p>",
      "summary": "<p>castQuery</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function castQuery (query) {\n  try {\n    return query.cast(query.model);\n  } catch (err) {\n    return err;\n  }\n}",
    "ctx": {
      "type": "function",
      "name": "castQuery",
      "string": "castQuery()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Exports.</p>",
      "summary": "<p>Exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = Query;\nmodule.exports.QueryStream = QueryStream;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "Query",
      "string": "module.exports"
    }
  }
]
### lib/querystream.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var Stream = require('stream').Stream\nvar utils = require('./utils')",
    "ctx": {
      "type": "declaration",
      "name": "Stream",
      "value": "require('stream').Stream",
      "string": "Stream"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Query"
        ],
        "name": "query",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Stream"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>QueryStream</p>\n\n<p>Returns a stream interface for the <code>query</code>.</p>",
      "summary": "<p>QueryStream</p>",
      "body": "<p>Returns a stream interface for the <code>query</code>.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function QueryStream (query) {\n  Stream.call(this);\n\n  this.query = query;\n  this.readable = true;\n  this.paused = false;\n  this._cursor = null;\n  this._destroyed = null;\n  this._fields = null;\n  this._ticks = 0;\n  this._inline = T_INIT;\n\n  // give time to hook up events\n  var self = this;\n  process.nextTick(function () {\n    self._init();\n  });\n}",
    "ctx": {
      "type": "function",
      "name": "QueryStream",
      "string": "QueryStream()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Inherit from Stream</p>",
      "summary": "<p>Inherit from Stream</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "QueryStream.prototype.__proto__ = Stream.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "QueryStream",
      "name": "__proto__",
      "value": "Stream.prototype",
      "string": "QueryStream.prototype__proto__"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Flag stating whether or not this stream is readable.</p>",
      "summary": "<p>Flag stating whether or not this stream is readable.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "QueryStream.prototype.readable;"
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Flag stating whether or not this stream is paused.</p>",
      "summary": "<p>Flag stating whether or not this stream is paused.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "QueryStream.prototype.paused;\n\n// trampoline flags\nvar T_INIT = 0;\nvar T_IDLE = 1;\nvar T_CONT = 2;"
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Initialize the query.</p>",
      "summary": "<p>Initialize the query.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "QueryStream.prototype._init = function () {\n  if (this._destroyed) return;\n\n  var query = this.query\n    , model = query.model\n    , options = query._optionsForExec(model)\n    , self = this\n\n  try {\n    query.cast(model);\n  } catch (err) {\n    return self.destroy(err);\n  }\n\n  self._fields = utils.clone(options.fields = query._fields);\n  \n  model.collection.find(query._conditions, options, function (err, cursor) {\n    if (err) return self.destroy(err);\n    self._cursor = cursor;\n    self._next();\n  });\n}",
    "ctx": {
      "type": "method",
      "constructor": "QueryStream",
      "name": "_init",
      "string": "QueryStream.prototype._init()"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "local": "__next",
        "visibility": "__next"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>_next</p>\n\n<p>Trampoline for pulling the next doc from cursor.</p>",
      "summary": "<p>_next</p>",
      "body": "<p>Trampoline for pulling the next doc from cursor.</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "QueryStream.prototype._next = function () {\n  // avoid stack overflows with large result sets.\n  // trampoline instead of recursion.\n  var fn;\n  while (fn = this.__next()) fn.call(this);\n}",
    "ctx": {
      "type": "method",
      "constructor": "QueryStream",
      "name": "_next",
      "string": "QueryStream.prototype._next()"
    }
  },
  {
    "tags": [
      {
        "type": "see",
        "local": "_next",
        "visibility": "_next"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>__next</p>\n\n<p>Pull the next doc from the cursor.</p>",
      "summary": "<p>__next</p>",
      "body": "<p>Pull the next doc from the cursor.</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "QueryStream.prototype.__next = function () {\n  if (this.paused || this._destroyed) return;\n\n  var self = this;\n  self._inline = T_INIT;\n\n  self._cursor.nextObject(function (err, doc) {\n    self._onNextObject(err, doc);\n  });\n\n  // if onNextObject() was already called in this tick\n  // return ourselves to the trampoline.\n  if (T_CONT === this._inline) {\n    return this.__next;\n  } else {\n    // onNextObject() hasn't fired yet. tell onNextObject\n    // that its ok to call _next b/c we are not within\n    // the trampoline anymore.\n    this._inline = T_IDLE;\n  }\n}",
    "ctx": {
      "type": "method",
      "constructor": "QueryStream",
      "name": "__next",
      "string": "QueryStream.prototype.__next()"
    }
  },
  {
    "tags": [
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Handle each document as its returned from the cursor<br />transforming the raw <code>doc</code> from -native into a model<br />instance.</p>",
      "summary": "<p>Handle each document as its returned from the cursor<br />transforming the raw <code>doc</code> from -native into a model<br />instance.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "QueryStream.prototype._onNextObject = function (err, doc) {\n  if (err) return this.destroy(err);\n\n  // when doc is null we hit the end of the cursor\n  if (!doc) {\n    return this.destroy();\n  }\n\n  if(this.query.options && this.query.options.lean === true)  {\n    this.emit('data', doc);\n    this._next();\n    return;\n  } \n  var instance = new this.query.model(undefined, this._fields);\n\n  // skip _id for pre-init hooks\n  delete instance._doc._id;\n\n  var self = this;\n  instance.init(doc, this.query, function (err) {\n    if (err) return self.destroy(err);\n    self.emit('data', instance);\n\n    // trampoline management\n    if (T_IDLE === self._inline) {\n      // no longer in trampoline. restart it.\n      self._next();\n    } else\n      // in a trampoline. tell __next that its\n      // ok to continue jumping.\n      self._inline = T_CONT;\n  });\n}",
    "ctx": {
      "type": "method",
      "constructor": "QueryStream",
      "name": "_onNextObject",
      "string": "QueryStream.prototype._onNextObject()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Pauses this stream.</p>",
      "summary": "<p>Pauses this stream.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "QueryStream.prototype.pause = function () {\n  this.paused = true;\n}",
    "ctx": {
      "type": "method",
      "constructor": "QueryStream",
      "name": "pause",
      "string": "QueryStream.prototype.pause()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Resumes this stream.</p>",
      "summary": "<p>Resumes this stream.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "QueryStream.prototype.resume = function () {\n  this.paused = false;\n  this._next();\n}",
    "ctx": {
      "type": "method",
      "constructor": "QueryStream",
      "name": "resume",
      "string": "QueryStream.prototype.resume()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Destroys the stream, closing the underlying<br />cursor. No more events will be emitted.</p>",
      "summary": "<p>Destroys the stream, closing the underlying<br />cursor. No more events will be emitted.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "QueryStream.prototype.destroy = function (err) {\n  if (this._destroyed) return;\n  this._destroyed = true;\n  this.readable = false;\n\n  if (this._cursor) {\n    this._cursor.close();\n  }\n\n  if (err) {\n    this.emit('error', err);\n  }\n\n  this.emit('close');\n}\n\n// TODO - maybe implement the -native raw option to pass binary?\n//QueryStream.prototype.setEncoding = function () {\n//}\n\nmodule.exports = exports = QueryStream;",
    "ctx": {
      "type": "method",
      "constructor": "QueryStream",
      "name": "destroy",
      "string": "QueryStream.prototype.destroy()"
    }
  }
]
### lib/schema/array.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var SchemaType = require('../schematype')\n  , CastError = SchemaType.CastError\n  , NumberSchema = require('./number')\n  , Types = {\n        Boolean: require('./boolean')\n      , Date: require('./date')\n      , Number: require('./number')\n      , String: require('./string')\n      , ObjectId: require('./objectid')\n      , Buffer: require('./buffer')\n    }\n  , MongooseArray = require('../types').Array\n  , Mixed = require('./mixed')\n  , Query = require('../query')\n  , isMongooseObject = require('../utils').isMongooseObject",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "SchemaType"
        ],
        "name": "cast",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Array SchemaType constructor</p>",
      "summary": "<p>Array SchemaType constructor</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function SchemaArray (key, cast, options) {\n  if (cast) {\n    var castOptions = {};\n\n    if ('Object' === cast.constructor.name) {\n      if (cast.type) {\n        // support { type: Woot }\n        castOptions = cast;\n        cast = cast.type;\n        delete castOptions.type;\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    var caster = cast.name in Types ? Types[cast.name] : cast;\n    this.casterConstructor = caster;\n    this.caster = new caster(null, castOptions);\n  }\n\n  SchemaType.call(this, key, options);\n\n  var self = this\n    , defaultArr\n    , fn;\n\n  if (this.defaultValue) {\n    defaultArr = this.defaultValue;\n    fn = 'function' == typeof defaultArr;\n  }\n\n  this.default(function(){\n    var arr = fn ? defaultArr() : defaultArr || [];\n    return new MongooseArray(arr, self.path, this);\n  });\n};",
    "ctx": {
      "type": "function",
      "name": "SchemaArray",
      "string": "SchemaArray()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "SchemaArray.prototype.__proto__ = SchemaType.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "SchemaArray",
      "name": "__proto__",
      "value": "SchemaType.prototype",
      "string": "SchemaArray.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Check required</p>",
      "summary": "<p>Check required</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaArray.prototype.checkRequired = function (value) {\n  return !!(value && value.length);\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaArray",
      "name": "checkRequired",
      "string": "SchemaArray.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "scope",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Overrides the getters application for the population special-case<br />TODO: implement this in SchemaObjectIdArray</p>",
      "summary": "<p>Overrides the getters application for the population special-case<br />TODO: implement this in SchemaObjectIdArray</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaArray.prototype.applyGetters = function (value, scope) {\n  if (this.caster.options && this.caster.options.ref) {\n    // means the object id was populated\n    return value;\n  }\n\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaArray",
      "name": "applyGetters",
      "string": "SchemaArray.prototype.applyGetters()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "document",
        "description": "that triggers the casting"
      },
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "whether",
        "description": "this is an initialization cast"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts contents</p>",
      "summary": "<p>Casts contents</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaArray.prototype.cast = function (value, doc, init) {\n  if (Array.isArray(value)) {\n    if (!(value instanceof MongooseArray)) {\n      value = new MongooseArray(value, this.path, doc);\n    }\n\n    if (this.caster) {\n      try {\n        for (var i = 0, l = value.length; i < l; i++) {\n          value[i] = this.caster.cast(value[i], doc, init);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError(e.type, value);\n      }\n    }\n\n    return value;\n  } else {\n    return this.cast([value], doc, init);\n  }\n};\n\nSchemaArray.prototype.castForQuery = function ($conditional, value) {\n  var handler\n    , val;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler)\n      throw new Error(\"Can't use \" + $conditional + \" with Array.\");\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    var proto = this.casterConstructor.prototype;\n    var method = proto.castForQuery || proto.cast;\n    if (Array.isArray(val)) {\n      val = val.map(function (v) {\n        if (method) v = method.call(proto, v);\n        return isMongooseObject(v)\n          ? v.toObject()\n          : v;\n      });\n    } else if (method) {\n      val = method.call(proto, val);\n    }\n  }\n  return val && isMongooseObject(val)\n    ? val.toObject()\n    : val;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaArray",
      "name": "cast",
      "string": "SchemaArray.prototype.cast()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>@ignore</p>",
      "summary": "<p>@ignore</p>",
      "body": ""
    },
    "ignore": false,
    "code": "function castToNumber (val) {\n  return Types.Number.prototype.cast.call(this, val);\n}\n\nSchemaArray.prototype.$conditionalHandlers = {\n    '$all': function handle$all (val) {\n      if (!Array.isArray(val)) {\n        val = [val];\n      }\n\n      val = val.map(function (v) {\n        if (v && 'Object' === v.constructor.name) {\n          var o = {};\n          o[this.path] = v;\n          var query = new Query(o);\n          query.cast(this.casterConstructor);\n          return query._conditions[this.path];\n        }\n        return v;\n      }, this);\n\n      return this.castForQuery(val);\n    }\n  , '$elemMatch': function (val) {\n      var query = new Query(val);\n      query.cast(this.casterConstructor);\n      return query._conditions;\n    }\n  , '$size': castToNumber\n  , '$ne': SchemaArray.prototype.castForQuery\n  , '$in': SchemaArray.prototype.castForQuery\n  , '$nin': SchemaArray.prototype.castForQuery\n  , '$regex': SchemaArray.prototype.castForQuery\n  , '$near': SchemaArray.prototype.castForQuery\n  , '$nearSphere': SchemaArray.prototype.castForQuery\n  , '$gt': castToNumber\n  , '$gte': castToNumber\n  , '$lt': castToNumber\n  , '$lte': castToNumber\n  , '$within': function(val) {\n      var query = new Query(val);\n      query.cast(this.casterConstructor)\n      return query._conditions;\n    }\n  , '$maxDistance': castToNumber\n};",
    "ctx": {
      "type": "function",
      "name": "castToNumber",
      "string": "castToNumber()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = SchemaArray;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "SchemaArray",
      "string": "module.exports"
    }
  }
]
### lib/schema/boolean.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var SchemaType = require('../schematype');",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Boolean SchemaType constructor.</p>",
      "summary": "<p>Boolean SchemaType constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function SchemaBoolean (path, options) {\n  SchemaType.call(this, path, options);\n};",
    "ctx": {
      "type": "function",
      "name": "SchemaBoolean",
      "string": "SchemaBoolean()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "SchemaBoolean.prototype.__proto__ = SchemaType.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "SchemaBoolean",
      "name": "__proto__",
      "value": "SchemaType.prototype",
      "string": "SchemaBoolean.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Required validator for date</p>",
      "summary": "<p>Required validator for date</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaBoolean.prototype.checkRequired = function (value) {\n  return value === true || value === false;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaBoolean",
      "name": "checkRequired",
      "string": "SchemaBoolean.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "to cast"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts to boolean</p>",
      "summary": "<p>Casts to boolean</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaBoolean.prototype.cast = function (value) {\n  if (value === null) return value;\n  if (value === '0') return false;\n  return !!value;\n};\n\nSchemaBoolean.prototype.castForQuery = function ($conditional, val) {\n  if (arguments.length === 1) {\n    val = $conditional;\n  }\n  return this.cast(val);\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaBoolean",
      "name": "cast",
      "string": "SchemaBoolean.prototype.cast()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = SchemaBoolean;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "SchemaBoolean",
      "string": "module.exports"
    }
  }
]
### lib/schema/buffer.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var SchemaType = require('../schematype')\n  , CastError = SchemaType.CastError\n  , MongooseBuffer = require('../types').Buffer\n  , Binary = MongooseBuffer.Binary\n  , Query = require('../query');",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "SchemaType"
        ],
        "name": "cast",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Buffer SchemaType constructor</p>",
      "summary": "<p>Buffer SchemaType constructor</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function SchemaBuffer (key, options) {\n  SchemaType.call(this, key, options, 'Buffer');\n};",
    "ctx": {
      "type": "function",
      "name": "SchemaBuffer",
      "string": "SchemaBuffer()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "SchemaBuffer.prototype.__proto__ = SchemaType.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "SchemaBuffer",
      "name": "__proto__",
      "value": "SchemaType.prototype",
      "string": "SchemaBuffer.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Check required</p>",
      "summary": "<p>Check required</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaBuffer.prototype.checkRequired = function (value) {\n  return !!(value && value.length);\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaBuffer",
      "name": "checkRequired",
      "string": "SchemaBuffer.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "document",
        "description": "that triggers the casting"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts contents</p>",
      "summary": "<p>Casts contents</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaBuffer.prototype.cast = function (value, doc, init) {\n  if (SchemaType._isRef(this, value, init)) return value;\n\n  if (Buffer.isBuffer(value)) {\n    if (!(value instanceof MongooseBuffer)) {\n      value = new MongooseBuffer(value, [this.path, doc]);\n    }\n\n    return value;\n  } else if (value instanceof Binary) {\n    return new MongooseBuffer(value.value(true), [this.path, doc]);\n  }\n\n  if ('string' === typeof value || Array.isArray(value)) {\n    return new MongooseBuffer(value, [this.path, doc]);\n  }\n\n  throw new CastError('buffer', value);\n};\n\nfunction handleSingle (val) {\n  return this.castForQuery(val);\n}\n\nfunction handleArray (val) {\n  var self = this;\n  return val.map( function (m) {\n    return self.castForQuery(m);\n  });\n}\n\nSchemaBuffer.prototype.$conditionalHandlers = {\n    '$ne' : handleSingle\n  , '$in' : handleArray\n  , '$nin': handleArray\n  , '$gt' : handleSingle\n  , '$lt' : handleSingle\n  , '$gte': handleSingle\n  , '$lte': handleSingle\n};\n\nSchemaBuffer.prototype.castForQuery = function ($conditional, val) {\n  var handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler)\n      throw new Error(\"Can't use \" + $conditional + \" with Buffer.\");\n    return handler.call(this, val);\n  } else {\n    val = $conditional;\n    return this.cast(val).toObject();\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaBuffer",
      "name": "cast",
      "string": "SchemaBuffer.prototype.cast()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = SchemaBuffer;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "SchemaBuffer",
      "string": "module.exports"
    }
  }
]
### lib/schema/date.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module requirements.</p>",
      "summary": "<p>Module requirements.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var SchemaType = require('../schematype')\n  , CastError = SchemaType.CastError;",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Date SchemaType constructor.</p>",
      "summary": "<p>Date SchemaType constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function SchemaDate (key, options) {\n  SchemaType.call(this, key, options);\n};",
    "ctx": {
      "type": "function",
      "name": "SchemaDate",
      "string": "SchemaDate()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "SchemaDate.prototype.__proto__ = SchemaType.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "SchemaDate",
      "name": "__proto__",
      "value": "SchemaType.prototype",
      "string": "SchemaDate.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Required validator for date</p>",
      "summary": "<p>Required validator for date</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaDate.prototype.checkRequired = function (value) {\n  return value instanceof Date;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaDate",
      "name": "checkRequired",
      "string": "SchemaDate.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "to cast"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts to date</p>",
      "summary": "<p>Casts to date</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaDate.prototype.cast = function (value) {\n  if (value === null || value === '')\n    return null;\n\n  if (value instanceof Date)\n    return value;\n\n  var date;\n\n  // support for timestamps\n  if (value instanceof Number || 'number' == typeof value \n      || String(value) == Number(value))\n    date = new Date(Number(value));\n\n  // support for date strings\n  else if (value.toString)\n    date = new Date(value.toString());\n\n  if (date.toString() != 'Invalid Date')\n    return date;\n\n  throw new CastError('date', value);\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaDate",
      "name": "cast",
      "string": "SchemaDate.prototype.cast()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Date Query casting.</p>",
      "summary": "<p>Date Query casting.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function handleSingle (val) {\n  return this.cast(val);\n}\n\nfunction handleArray (val) {\n  var self = this;\n  return val.map( function (m) {\n    return self.cast(m);\n  });\n}\n\nSchemaDate.prototype.$conditionalHandlers = {\n    '$lt': handleSingle\n  , '$lte': handleSingle\n  , '$gt': handleSingle\n  , '$gte': handleSingle\n  , '$ne': handleSingle\n  , '$in': handleArray\n  , '$nin': handleArray\n  , '$all': handleArray\n};\n\nSchemaDate.prototype.castForQuery = function ($conditional, val) {\n  var handler;\n\n  if (2 !== arguments.length) {\n    return this.cast($conditional);\n  }\n\n  handler = this.$conditionalHandlers[$conditional];\n\n  if (!handler) {\n    throw new Error(\"Can't use \" + $conditional + \" with Date.\");\n  }\n\n  return handler.call(this, val);\n};",
    "ctx": {
      "type": "function",
      "name": "handleSingle",
      "string": "handleSingle()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = SchemaDate;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "SchemaDate",
      "string": "module.exports"
    }
  }
]
### lib/schema/documentarray.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var SchemaType = require('../schematype')\n  , ArrayType = require('./array')\n  , MongooseDocumentArray = require('../types/documentarray')\n  , Subdocument = require('../types/embedded')\n  , CastError = SchemaType.CastError\n  , Document = require('../document');",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Schema"
        ],
        "name": "schema",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>SubdocsArray SchemaType constructor</p>",
      "summary": "<p>SubdocsArray SchemaType constructor</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function DocumentArray (key, schema, options) {\n  // compile an embedded document for this schema\n  // TODO Move this into parent model compilation for performance improvement?\n  function EmbeddedDocument () {\n    Subdocument.apply(this, arguments);\n  };\n\n  EmbeddedDocument.prototype.__proto__ = Subdocument.prototype;\n  EmbeddedDocument.prototype._setSchema(schema);\n  EmbeddedDocument.schema = schema;\n\n  // apply methods\n  for (var i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (var i in schema.statics)\n    EmbeddedDocument[i] = schema.statics[i];\n\n  EmbeddedDocument.options = options;\n  this.schema = schema;\n\n  ArrayType.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  var path = this.path;\n  var fn = this.defaultValue;\n\n  this.default(function(){\n    var arr = fn.call(this);\n    if (!Array.isArray(arr)) arr = [arr];\n    return new MongooseDocumentArray(arr, path, this);\n  });\n};",
    "ctx": {
      "type": "function",
      "name": "DocumentArray",
      "string": "DocumentArray()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from ArrayType.</p>",
      "summary": "<p>Inherits from ArrayType.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "DocumentArray.prototype.__proto__ = ArrayType.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "DocumentArray",
      "name": "__proto__",
      "value": "ArrayType.prototype",
      "string": "DocumentArray.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Performs local validations first, then validations on each embedded doc</p>",
      "summary": "<p>Performs local validations first, then validations on each embedded doc</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "DocumentArray.prototype.doValidate = function (array, fn, scope) {\n  var self = this;\n  SchemaType.prototype.doValidate.call(this, array, function(err){\n    if (err) return fn(err);\n\n    var count = array && array.length\n      , error = false;\n\n    if (!count) return fn();\n\n    array.forEach(function(doc, index){\n      doc.validate(function(err){\n        if (err && !error){\n          // rewrite they key\n          err.key = self.key + '.' + index + '.' + err.key;\n          fn(err);\n          error = true;\n        } else {\n          --count || fn();\n        }\n      });\n    });\n  }, scope);\n};",
    "ctx": {
      "type": "method",
      "constructor": "DocumentArray",
      "name": "doValidate",
      "string": "DocumentArray.prototype.doValidate()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "document",
        "description": "that triggers the casting"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts contents</p>",
      "summary": "<p>Casts contents</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "DocumentArray.prototype.cast = function (value, doc, init, prev) {\n  var subdoc\n    , i\n\n  if (Array.isArray(value)) {\n    if (!(value instanceof MongooseDocumentArray)) {\n      value = new MongooseDocumentArray(value, this.path, doc);\n    }\n\n    i = value.length;\n\n    while (i--) {\n      if (!(value[i] instanceof Subdocument)) {\n        if (init) {\n          subdoc = new this.casterConstructor(null, value, true);\n          value[i] = subdoc.init(value[i]);\n        } else {\n          subdoc = prev && prev.id(value[i]._id) ||\n                   new this.casterConstructor(value[i], value);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          value[i] = subdoc;\n        }\n      }\n    }\n\n    return value;\n  } else {\n    return this.cast([value], doc, init, prev);\n  }\n\n  throw new CastError('documentarray', value);\n};",
    "ctx": {
      "type": "method",
      "constructor": "DocumentArray",
      "name": "cast",
      "string": "DocumentArray.prototype.cast()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = DocumentArray;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "DocumentArray",
      "string": "module.exports"
    }
  }
]
### lib/schema/index.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "exports.String = require('./string');\n\nexports.Number = require('./number');\n\nexports.Boolean = require('./boolean');\n\nexports.DocumentArray = require('./documentarray');\n\nexports.Array = require('./array');\n\nexports.Buffer = require('./buffer');\n\nexports.Date = require('./date');\n\nexports.ObjectId = require('./objectid');\n\nexports.Mixed = require('./mixed');\n\n// alias\n\nexports.Oid = exports.ObjectId;\nexports.Object = exports.Mixed;\nexports.Bool = exports.Boolean;",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "String",
      "value": "require('./string')",
      "string": "exports.String"
    }
  }
]
### lib/schema/mixed.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var SchemaType = require('../schematype');",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Mixed SchemaType constructor.</p>",
      "summary": "<p>Mixed SchemaType constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function Mixed (path, options) {\n  // make sure empty array defaults are handled\n  if (options &&\n      options.default &&\n      Array.isArray(options.default) &&\n      0 === options.default.length) {\n    options.default = Array;\n  }\n\n  SchemaType.call(this, path, options);\n};",
    "ctx": {
      "type": "function",
      "name": "Mixed",
      "string": "Mixed()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Mixed.prototype.__proto__ = SchemaType.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "Mixed",
      "name": "__proto__",
      "value": "SchemaType.prototype",
      "string": "Mixed.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Required validator for mixed type</p>",
      "summary": "<p>Required validator for mixed type</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Mixed.prototype.checkRequired = function (val) {\n  return true;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Mixed",
      "name": "checkRequired",
      "string": "Mixed.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "to cast"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Noop casting</p>",
      "summary": "<p>Noop casting</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Mixed.prototype.cast = function (val) {\n  return val;\n};\n\nMixed.prototype.castForQuery = function ($cond, val) {\n  if (arguments.length === 2) return val;\n  return $cond;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Mixed",
      "name": "cast",
      "string": "Mixed.prototype.cast()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = Mixed;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "Mixed",
      "string": "module.exports"
    }
  }
]
### lib/schema/number.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module requirements.</p>",
      "summary": "<p>Module requirements.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var SchemaType = require('../schematype')\n  , CastError = SchemaType.CastError",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Number SchemaType constructor.</p>",
      "summary": "<p>Number SchemaType constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function SchemaNumber (key, options) {\n  SchemaType.call(this, key, options, 'Number');\n};",
    "ctx": {
      "type": "function",
      "name": "SchemaNumber",
      "string": "SchemaNumber()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "SchemaNumber.prototype.__proto__ = SchemaType.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "SchemaNumber",
      "name": "__proto__",
      "value": "SchemaType.prototype",
      "string": "SchemaNumber.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Required validator for number</p>",
      "summary": "<p>Required validator for number</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaNumber.prototype.checkRequired = function checkRequired (value) {\n  if (SchemaType._isRef(this, value, true)) {\n    return null != value;\n  } else {\n    return typeof value == 'number' || value instanceof Number;\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaNumber",
      "name": "checkRequired",
      "string": "SchemaNumber.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Number"
        ],
        "name": "minimum",
        "description": "number"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets a maximum number validator</p>",
      "summary": "<p>Sets a maximum number validator</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "SchemaNumber.prototype.min = function (value, message) {\n  if (this.minValidator)\n    this.validators = this.validators.filter(function(v){\n      return v[1] != 'min';\n    });\n  if (value != null)\n    this.validators.push([function(v){\n      return v === null || v >= value;\n    }, 'min']);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaNumber",
      "name": "min",
      "string": "SchemaNumber.prototype.min()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Number"
        ],
        "name": "maximum",
        "description": "number"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets a maximum number validator</p>",
      "summary": "<p>Sets a maximum number validator</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "SchemaNumber.prototype.max = function (value, message) {\n  if (this.maxValidator)\n    this.validators = this.validators.filter(function(v){\n      return v[1] != 'max';\n    });\n  if (value != null)\n    this.validators.push([this.maxValidator = function(v){\n      return v === null || v <= value;\n    }, 'max']);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaNumber",
      "name": "max",
      "string": "SchemaNumber.prototype.max()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "to cast"
      },
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "document",
        "description": "that triggers the casting"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts to number</p>",
      "summary": "<p>Casts to number</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaNumber.prototype.cast = function (value, doc, init) {\n  if (SchemaType._isRef(this, value, init)) return value;\n\n  if (!isNaN(value)){\n    if (null === value) return value;\n    if ('' === value) return null;\n    if ('string' == typeof value) value = Number(value);\n    if (value instanceof Number) return value\n    if ('number' == typeof value) return value;\n    if (value.toString && !Array.isArray(value) &&\n        value.toString() == Number(value)) {\n      return new Number(value)\n    }\n  }\n\n  throw new CastError('number', value);\n};\n\nfunction handleSingle (val) {\n  return this.cast(val)\n}\n\nfunction handleArray (val) {\n  var self = this;\n  return val.map( function (m) {\n    return self.cast(m)\n  });\n}\n\nSchemaNumber.prototype.$conditionalHandlers = {\n    '$lt' : handleSingle\n  , '$lte': handleSingle\n  , '$gt' : handleSingle\n  , '$gte': handleSingle\n  , '$ne' : handleSingle\n  , '$in' : handleArray\n  , '$nin': handleArray\n  , '$mod': handleArray\n  , '$all': handleArray\n};\n\nSchemaNumber.prototype.castForQuery = function ($conditional, val) {\n  var handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler)\n      throw new Error(\"Can't use \" + $conditional + \" with Number.\");\n    return handler.call(this, val);\n  } else {\n    val = this.cast($conditional);\n    return val == null ? val : val\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaNumber",
      "name": "cast",
      "string": "SchemaNumber.prototype.cast()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = SchemaNumber;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "SchemaNumber",
      "string": "module.exports"
    }
  }
]
### lib/schema/objectid.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var SchemaType = require('../schematype')\n  , CastError = SchemaType.CastError\n  , driver = global.MONGOOSE_DRIVER_PATH || './../drivers/node-mongodb-native'\n  , oid = require('../types/objectid');",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>ObjectId SchemaType constructor.</p>",
      "summary": "<p>ObjectId SchemaType constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function ObjectId (key, options) {\n  SchemaType.call(this, key, options, 'ObjectID');\n};",
    "ctx": {
      "type": "function",
      "name": "ObjectId",
      "string": "ObjectId()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "ObjectId.prototype.__proto__ = SchemaType.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "ObjectId",
      "name": "__proto__",
      "value": "SchemaType.prototype",
      "string": "ObjectId.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Check required</p>",
      "summary": "<p>Check required</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "ObjectId.prototype.checkRequired = function checkRequired (value) {\n  if (SchemaType._isRef(this, value, true)) {\n    return null != value;\n  } else {\n    return value instanceof oid;\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "ObjectId",
      "name": "checkRequired",
      "string": "ObjectId.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "scope",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "whether",
        "description": "this is an initialization cast"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts to ObjectId</p>",
      "summary": "<p>Casts to ObjectId</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "ObjectId.prototype.cast = function (value, scope, init) {\n  if (SchemaType._isRef(this, value, init)) return value;\n\n  if (value === null) return value;\n\n  if (value instanceof oid)\n    return value;\n\n  if (value._id && value._id instanceof oid)\n    return value._id;\n\n  if (value.toString)\n    return oid.fromString(value.toString());\n\n  throw new CastError('object id', value);\n};\n\nfunction handleSingle (val) {\n  return this.cast(val);\n}\n\nfunction handleArray (val) {\n  var self = this;\n  return val.map(function (m) {\n    return self.cast(m);\n  });\n}\n\nObjectId.prototype.$conditionalHandlers = {\n    '$ne': handleSingle\n  , '$in': handleArray\n  , '$nin': handleArray\n  , '$gt': handleSingle\n  , '$lt': handleSingle\n  , '$gte': handleSingle\n  , '$lte': handleSingle\n  , '$all': handleArray\n};\n\nObjectId.prototype.castForQuery = function ($conditional, val) {\n  var handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler)\n      throw new Error(\"Can't use \" + $conditional + \" with ObjectId.\");\n    return handler.call(this, val);\n  } else {\n    return this.cast($conditional);\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "ObjectId",
      "name": "cast",
      "string": "ObjectId.prototype.cast()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "turnOn",
        "description": "auto generated ObjectId defaults"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Adds an auto-generated ObjectId default if turnOn is true.</p>",
      "summary": "<p>Adds an auto-generated ObjectId default if turnOn is true.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "ObjectId.prototype.auto = function (turnOn) {\n  if (turnOn) {\n    this.default(defaultId);\n    this.set(resetId)\n  }\n};\n\nfunction defaultId () {\n  return new oid();\n};\n\nfunction resetId (v) {\n  this.__id = null;\n  return v;\n}",
    "ctx": {
      "type": "method",
      "constructor": "ObjectId",
      "name": "auto",
      "string": "ObjectId.prototype.auto()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = ObjectId;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "ObjectId",
      "string": "module.exports"
    }
  }
]
### lib/schema/string.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var SchemaType = require('../schematype')\n  , CastError = SchemaType.CastError;",
    "ctx": {
      "type": "declaration",
      "name": "SchemaType",
      "value": "require('../schematype')",
      "string": "SchemaType"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>String SchemaType constructor.</p>",
      "summary": "<p>String SchemaType constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function SchemaString (key, options) {\n  this.enumValues = [];\n  this.regExp = null;\n  SchemaType.call(this, key, options, 'String');\n};",
    "ctx": {
      "type": "function",
      "name": "SchemaString",
      "string": "SchemaString()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from SchemaType.</p>",
      "summary": "<p>Inherits from SchemaType.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "SchemaString.prototype.__proto__ = SchemaType.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "SchemaString",
      "name": "__proto__",
      "value": "SchemaType.prototype",
      "string": "SchemaString.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "multiple"
        ],
        "name": "enumeration",
        "description": "values"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds enumeration values</p>",
      "summary": "<p>Adds enumeration values</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "SchemaString.prototype.enum = function () {\n  var len = arguments.length;\n  if (!len || undefined === arguments[0] || false === arguments[0]) {\n    if (this.enumValidator){\n      this.enumValidator = false;\n      this.validators = this.validators.filter(function(v){\n        return v[1] != 'enum';\n      });\n    }\n    return;\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (undefined !== arguments[i]) {\n      this.enumValues.push(this.cast(arguments[i]));\n    }\n  }\n\n  if (!this.enumValidator) {\n    var values = this.enumValues;\n    this.enumValidator = function(v){\n      return undefined === v || ~values.indexOf(v);\n    };\n    this.validators.push([this.enumValidator, 'enum']);\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaString",
      "name": "enum",
      "string": "SchemaString.prototype.enum()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds a lowercase setter</p>",
      "summary": "<p>Adds a lowercase setter</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "SchemaString.prototype.lowercase = function () {\n  return this.set(function (v) {\n    return v.toLowerCase();\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaString",
      "name": "lowercase",
      "string": "SchemaString.prototype.lowercase()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds an uppercase setter</p>",
      "summary": "<p>Adds an uppercase setter</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "SchemaString.prototype.uppercase = function () {\n  return this.set(function (v) {\n    return v.toUpperCase();\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaString",
      "name": "uppercase",
      "string": "SchemaString.prototype.uppercase()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds a trim setter</p>",
      "summary": "<p>Adds a trim setter</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "SchemaString.prototype.trim = function () {\n  return this.set(function (v) {\n    return v.trim();\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaString",
      "name": "trim",
      "string": "SchemaString.prototype.trim()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "RegExp"
        ],
        "name": "regular",
        "description": "expression to test against"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets a regexp test</p>",
      "summary": "<p>Sets a regexp test</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "SchemaString.prototype.match = function match (regExp) {\n  this.validators.push([function(v){\n    return null != v && '' !== v\n      ? regExp.test(v)\n      : true\n  }, 'regexp']);\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaString",
      "name": "match",
      "string": "SchemaString.prototype.match()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Check required</p>",
      "summary": "<p>Check required</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaString.prototype.checkRequired = function checkRequired (value) {\n  if (SchemaType._isRef(this, value, true)) {\n    return null != value;\n  } else {\n    return (value instanceof String || typeof value == 'string') && value.length;\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaString",
      "name": "checkRequired",
      "string": "SchemaString.prototype.checkRequired()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts to String</p>",
      "summary": "<p>Casts to String</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaString.prototype.cast = function (value, scope, init) {\n  if (SchemaType._isRef(this, value, init)) return value;\n  if (value === null) return value;\n  if ('undefined' !== typeof value && value.toString) return value.toString();\n  throw new CastError('string', value);\n};\n\nfunction handleSingle (val) {\n  return this.castForQuery(val);\n}\n\nfunction handleArray (val) {\n  var self = this;\n  return val.map(function (m) {\n    return self.castForQuery(m);\n  });\n}\n\nSchemaString.prototype.$conditionalHandlers = {\n    '$ne' : handleSingle\n  , '$in' : handleArray\n  , '$nin': handleArray\n  , '$gt' : handleSingle\n  , '$lt' : handleSingle\n  , '$gte': handleSingle\n  , '$lte': handleSingle\n  , '$all': handleArray\n  , '$regex': handleSingle\n  , '$options': handleSingle\n};\n\nSchemaString.prototype.castForQuery = function ($conditional, val) {\n  var handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler)\n      throw new Error(\"Can't use \" + $conditional + \" with String.\");\n    return handler.call(this, val);\n  } else {\n    val = $conditional;\n    if (val instanceof RegExp) return val;\n    return this.cast(val);\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaString",
      "name": "cast",
      "string": "SchemaString.prototype.cast()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = SchemaString;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "SchemaString",
      "string": "module.exports"
    }
  }
]
### lib/schema.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var EventEmitter = require('events').EventEmitter\n  , VirtualType = require('./virtualtype')\n  , utils = require('./utils')\n  , NamedScope\n  , Query\n  , Types",
    "ctx": {
      "type": "declaration",
      "name": "EventEmitter",
      "value": "require('events').EventEmitter",
      "string": "EventEmitter"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "definition",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Schema constructor.</p>",
      "summary": "<p>Schema constructor.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function Schema (obj, options) {\n  if (!(this instanceof Schema))\n    return new Schema(obj, options);\n\n  this.paths = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this.methods = {};\n  this.statics = {};\n  this.tree = {};\n  this._requiredpaths = undefined;\n\n  // set options\n  this.options = utils.options({\n      safe: true\n    , strict: true\n    , capped: false // { size, max, autoIndexId }\n    , versionKey: '__v'\n    , minimize: true\n    , autoIndex: true\n  }, options);\n\n  // build paths\n  if (obj) {\n    this.add(obj);\n  }\n\n  if (!this.paths['_id'] && !this.options.noId) {\n    this.add({ _id: {type: ObjectId, auto: true} });\n  }\n\n  if (!this.paths['id'] && !this.options.noVirtualId) {\n    this.virtual('id').get(function () {\n      if (this.__id) {\n        return this.__id;\n      }\n\n      return this.__id = null == this._id\n        ? null\n        : this._id.toString();\n    });\n  }\n\n  delete this.options.noVirtualId;\n\n  // versioning not directly added to schema b/c we only want\n  // it in the top level document, not embedded ones.\n};",
    "ctx": {
      "type": "function",
      "name": "Schema",
      "string": "Schema()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherit from EventEmitter.</p>",
      "summary": "<p>Inherit from EventEmitter.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Schema.prototype.__proto__ = EventEmitter.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "Schema",
      "name": "__proto__",
      "value": "EventEmitter.prototype",
      "string": "Schema.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Schema by paths</p>\n\n<p>Example (embedded doc):<br />   {<br />       'test'       : SchemaType,<br />     , 'test.test'  : SchemaType,<br />     , 'first_name' : SchemaType<br />   }</p>",
      "summary": "<p>Schema by paths</p>",
      "body": "<p>Example (embedded doc):<br />   {<br />       'test'       : SchemaType,<br />     , 'test.test'  : SchemaType,<br />     , 'first_name' : SchemaType<br />   }</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Schema.prototype.paths;"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Schema as a tree</p>\n\n<h2>Example</h2>\n\n<p>{<br />       '_id'     : ObjectId<br />     , 'nested'  : {<br />           'key': String<br />       }<br />   }</p>",
      "summary": "<p>Schema as a tree</p>",
      "body": "<h2>Example</h2>\n\n<p>{<br />       '_id'     : ObjectId<br />     , 'nested'  : {<br />           'key': String<br />       }<br />   }</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Schema.prototype.tree;"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "keys",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "prefix",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets the keys</p>",
      "summary": "<p>Sets the keys</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.prototype.add = function add (obj, prefix) {\n  prefix = prefix || '';\n  for (var i in obj) {\n    if (null == obj[i]) {\n      throw new TypeError('Invalid value for schema path `'+ prefix + i +'`');\n    }\n\n    if (obj[i].constructor.name == 'Object' && (!obj[i].type || obj[i].type.type)) {\n      if (Object.keys(obj[i]).length) {\n        // nested object { last: { name: String }}\n        this.nested[prefix + i] = true;\n        this.add(obj[i], prefix + i + '.');\n      }\n      else\n        this.path(prefix + i, obj[i]); // mixed type\n    } else\n      this.path(prefix + i, obj[i]);\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "add",
      "string": "Schema.prototype.add()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Reserved document keys.</p>\n\n<p>Keys in this object are names that are rejected<br />in schema declarations b/c they conflict with<br />mongoose functionality.</p>",
      "summary": "<p>Reserved document keys.</p>",
      "body": "<p>Keys in this object are names that are rejected<br />in schema declarations b/c they conflict with<br />mongoose functionality.</p>"
    },
    "ignore": false,
    "code": "var reserved = Object.create(null);\nreserved.on =\nreserved.db =\nreserved.init =\nreserved.model =\nreserved.isNew =\nreserved.errors =\nreserved.schema =\nreserved.modelName =\nreserved.collection = 1;",
    "ctx": {
      "type": "declaration",
      "name": "reserved",
      "value": "Object.create(null)",
      "string": "reserved"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "constructor",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets a path (if arity 2)<br />Gets a path (if arity 1)</p>",
      "summary": "<p>Sets a path (if arity 2)<br />Gets a path (if arity 1)</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.prototype.path = function (path, obj) {\n  if (obj == undefined) {\n    if (this.paths[path]) return this.paths[path];\n    if (this.subpaths[path]) return this.subpaths[path];\n\n    // subpaths?\n    return /\\.\\d+\\.?/.test(path)\n      ? getPositionalPath(this, path)\n      : undefined;\n  }\n\n  // some path names conflict with document methods\n  if (reserved[path]) {\n    throw new Error(\"`\" + path + \"` may not be used as a schema pathname\");\n  }\n\n  // update the tree\n  var subpaths = path.split(/\\./)\n    , last = subpaths.pop()\n    , branch = this.tree;\n\n  subpaths.forEach(function(path) {\n    if (!branch[path]) branch[path] = {};\n    branch = branch[path];\n  });\n\n  branch[last] = utils.clone(obj);\n\n  this.paths[path] = Schema.interpretAsType(path, obj);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "path",
      "string": "Schema.prototype.path()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "constructor",
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Converts -- e.g., Number, [SomeSchema],<br />{ type: String, enum: ['m', 'f'] } -- into<br />the appropriate Mongoose Type, which we use<br />later for casting, validation, etc.</p>",
      "summary": "<p>Converts -- e.g., Number, [SomeSchema],<br />{ type: String, enum: ['m', 'f'] } -- into<br />the appropriate Mongoose Type, which we use<br />later for casting, validation, etc.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.interpretAsType = function (path, obj) {\n  if (obj.constructor.name != 'Object')\n    obj = { type: obj };\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  var type = obj.type && !obj.type.type\n    ? obj.type\n    : {};\n\n  if ('Object' == type.constructor.name || 'mixed' == type) {\n    return new Types.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || Array == type || 'array' == type) {\n    // if it was specified through { type } look for `cast`\n    var cast = (Array == type || 'array' == type)\n      ? obj.cast\n      : type[0];\n\n    if (cast instanceof Schema) {\n      return new Types.DocumentArray(path, cast, obj);\n    }\n\n    if ('string' == typeof cast) {\n      cast = Types[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (cast && !cast.type\n                    && 'Object' == cast.constructor.name\n                    && Object.keys(cast).length) {\n      return new Types.DocumentArray(path, new Schema(cast), obj);\n    }\n\n    return new Types.Array(path, cast || Types.Mixed, obj);\n  }\n\n  var name = 'string' == typeof type\n    ? type\n    : type.name;\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n\n  if (undefined == Types[name]) {\n    throw new TypeError('Undefined type at `' + path +\n        '`\\n  Did you try nesting Schemas? ' +\n        'You can only nest using refs or arrays.');\n  }\n\n  return new Types[name](path, obj);\n};",
    "ctx": {
      "type": "method",
      "receiver": "Schema",
      "name": "interpretAsType",
      "string": "Schema.interpretAsType()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": "function - fn(pathstring, type)"
      },
      {
        "type": "return",
        "types": [
          "Schema"
        ],
        "description": "this for chaining"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Iterates through the schema's paths, passing the path string and type object<br />to the callback.</p>",
      "summary": "<p>Iterates through the schema's paths, passing the path string and type object<br />to the callback.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.prototype.eachPath = function (fn) {\n  var keys = Object.keys(this.paths)\n    , len = keys.length;\n\n  for (var i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "eachPath",
      "string": "Schema.prototype.eachPath()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns an Array of path strings that are required.</p>",
      "summary": "<p>Returns an Array of path strings that are required.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.prototype.requiredPaths = function requiredPaths () {\n  if (this._requiredpaths) return this._requiredpaths;\n\n  var paths = Object.keys(this.paths)\n    , i = paths.length\n    , ret = [];\n\n  while (i--) {\n    var path = paths[i];\n    if (this.paths[path].isRequired) ret.push(path);\n  }\n\n  return this._requiredpaths = ret;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "requiredPaths",
      "string": "Schema.prototype.requiredPaths()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Given a path, returns whether it is a real, virtual,<br />nested, or ad-hoc/undefined path.</p>",
      "summary": "<p>Given a path, returns whether it is a real, virtual,<br />nested, or ad-hoc/undefined path.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.prototype.pathType = function (path) {\n  if (path in this.paths) return 'real';\n  if (path in this.virtuals) return 'virtual';\n  if (path in this.nested) return 'nested';\n  if (path in this.subpaths) return 'real';\n\n  if (/\\.\\d+\\.?/.test(path) && getPositionalPath(this, path)) {\n    return 'real';\n  } else {\n    return 'adhocOrUndefined'\n  }\n};\n\nfunction getPositionalPath (self, path) {\n  var subpaths = path.split(/\\.(\\d+)\\.?/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return self.paths[subpaths[0]];\n  }\n\n  var val = self.path(subpaths[0])\n    , last = subpaths.length - 1\n    , subpath;\n\n  for (var i = 1; i < subpaths.length; ++i) {\n    var subpath = subpaths[i];\n\n    if (i === last &&\n        val &&\n        !val.schema &&\n        !/\\D/.test(subpath) &&\n        val instanceof Types.Array) {\n      // StringSchema, NumberSchema, etc\n      val = val.caster;\n      continue;\n    }\n\n    // 'path.0.subpath'\n    if (!/\\D/.test(subpath)) continue;\n    val = val.schema.path(subpath);\n  }\n\n  return self.subpaths[path] = val;\n}",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "pathType",
      "string": "Schema.prototype.pathType()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "method",
        "description": "name"
      },
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "arguments",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Adds a method call to the queue</p>",
      "summary": "<p>Adds a method call to the queue</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "Schema.prototype.queue = function(name, args){\n  this.callQueue.push([name, args]);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "queue",
      "string": "Schema.prototype.queue()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "method",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Defines a pre for the document</p>",
      "summary": "<p>Defines a pre for the document</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.prototype.pre = function(){\n  return this.queue('pre', arguments);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "pre",
      "string": "Schema.prototype.pre()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "method",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Defines a post for the document</p>",
      "summary": "<p>Defines a post for the document</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.prototype.post = function(method, fn){\n  return this.queue('on', arguments);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "post",
      "string": "Schema.prototype.post()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "plugin",
        "description": "callback"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Registers a plugin for this schema</p>",
      "summary": "<p>Registers a plugin for this schema</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.prototype.plugin = function (fn, opts) {\n  fn(this, opts);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "plugin",
      "string": "Schema.prototype.plugin()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "method",
        "description": "name"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "handler",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds a method</p>",
      "summary": "<p>Adds a method</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.prototype.method = function (name, fn) {\n  if ('string' != typeof name)\n    for (var i in name)\n      this.methods[i] = name[i];\n  else\n    this.methods[name] = fn;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "method",
      "string": "Schema.prototype.method()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "name",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "handler",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Defines a static method</p>",
      "summary": "<p>Defines a static method</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.prototype.static = function(name, fn) {\n  if ('string' != typeof name)\n    for (var i in name)\n      this.statics[i] = name[i];\n  else\n    this.statics[name] = fn;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "static",
      "string": "Schema.prototype.static()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "field",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "optional",
        "description": "options object"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Defines an index (most likely compound)</p>\n\n<h2>Example</h2>\n\n<p>schema.index({ first: 1, last: -1 })</p>",
      "summary": "<p>Defines an index (most likely compound)</p>\n\n<h2>Example</h2>\n\n<p>schema.index({ first: 1, last: -1 })</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.prototype.index = function (fields, options) {\n  this._indexes.push([fields, options || {}]);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "index",
      "string": "Schema.prototype.index()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "optional",
        "description": "value"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets/gets an option</p>",
      "summary": "<p>Sets/gets an option</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.prototype.set = function (key, value) {\n  if (arguments.length == 1)\n    return this.options[key];\n  this.options[key] = value;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "set",
      "string": "Schema.prototype.set()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Compiles indexes from fields and schema-level indexes</p>",
      "summary": "<p>Compiles indexes from fields and schema-level indexes</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.prototype.indexes = function () {\n  var indexes = []\n    , seenSchemas = [];\n\n  collectIndexes(this);\n\n  return indexes;\n\n  function collectIndexes (schema, prefix) {\n    if (~seenSchemas.indexOf(schema)) return;\n    seenSchemas.push(schema);\n\n    var index;\n    var paths = schema.paths;\n    prefix = prefix || '';\n\n    for (var i in paths) {\n      if (paths[i]) {\n        if (paths[i] instanceof Types.DocumentArray) {\n          collectIndexes(paths[i].schema, i + '.');\n        } else {\n          index = paths[i]._index;\n\n          if (index !== false && index !== null){\n            var field = {};\n            field[prefix + i] = '2d' === index ? index : 1;\n            var options = 'Object' === index.constructor.name ? index : {};\n            if (!('background' in options)) options.background = true;\n            indexes.push([field, options]);\n          }\n        }\n      }\n    }\n\n    if (prefix) {\n      fixSubIndexPaths(schema, prefix);\n    } else {\n      schema._indexes.forEach(function (index) {\n        if (!('background' in index[1])) index[1].background = true;\n      });\n      indexes = indexes.concat(schema._indexes);\n    }\n  }",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "indexes",
      "string": "Schema.prototype.indexes()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Checks for indexes added to subdocs using Schema.index().<br />These indexes need their paths prefixed properly.</p>\n\n<p>schema._indexes = [ [indexObj, options], [indexObj, options] ..]</p>",
      "summary": "<p>Checks for indexes added to subdocs using Schema.index().<br />These indexes need their paths prefixed properly.</p>",
      "body": "<p>schema._indexes = [ [indexObj, options], [indexObj, options] ..]</p>"
    },
    "ignore": false,
    "code": "function fixSubIndexPaths (schema, prefix) {\n    var subindexes = schema._indexes\n      , len = subindexes.length\n      , indexObj\n      , newindex\n      , klen\n      , keys\n      , key\n      , i = 0\n      , j\n\n    for (i = 0; i < len; ++i) {\n      indexObj = subindexes[i][0];\n      keys = Object.keys(indexObj);\n      klen = keys.length;\n      newindex = {};\n\n      // use forward iteration, order matters\n      for (j = 0; j < klen; ++j) {\n        key = keys[j];\n        newindex[prefix + key] = indexObj[key];\n      }\n\n      indexes.push([newindex, subindexes[i][1]]);\n    }\n  }\n\n}",
    "ctx": {
      "type": "function",
      "name": "fixSubIndexPaths",
      "string": "fixSubIndexPaths()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "name",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "VirtualType"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Retrieves or creates the virtual type with the given name.</p>",
      "summary": "<p>Retrieves or creates the virtual type with the given name.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.prototype.virtual = function (name, options) {\n  var virtuals = this.virtuals;\n  var parts = name.split('.');\n  return virtuals[name] = parts.reduce(function (mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length-1)\n                            ? new VirtualType(options)\n                            : {});\n    return mem[part];\n  }, this.tree);\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "virtual",
      "string": "Schema.prototype.virtual()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "name",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "VirtualType"
        ],
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Fetches the virtual type with the given name.<br />Should be distinct from virtual because virtual auto-defines a new VirtualType<br />if the path doesn't exist.</p>",
      "summary": "<p>Fetches the virtual type with the given name.<br />Should be distinct from virtual because virtual auto-defines a new VirtualType<br />if the path doesn't exist.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "Schema.prototype.virtualpath = function (name) {\n  return this.virtuals[name];\n};\n\nSchema.prototype.namedScope = function (name, fn) {\n  var namedScopes = this.namedScopes || (this.namedScopes = new NamedScope)\n    , newScope = Object.create(namedScopes)\n    , allScopes = namedScopes.scopesByName || (namedScopes.scopesByName = {});\n  allScopes[name] = newScope;\n  newScope.name = name;\n  newScope.block = fn;\n  newScope.query = new Query();\n  newScope.decorate(namedScopes, {\n    block0: function (block) {\n      return function () {\n        block.call(this.query);\n        return this;\n      };\n    },\n    blockN: function (block) {\n      return function () {\n        block.apply(this.query, arguments);\n        return this;\n      };\n    },\n    basic: function (query) {\n      return function () {\n        this.query.find(query);\n        return this;\n      };\n    }\n  });\n  return newScope;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Schema",
      "name": "virtualpath",
      "string": "Schema.prototype.virtualpath()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>ObjectId schema identifier. Not an actual ObjectId, only used for Schemas.</p>",
      "summary": "<p>ObjectId schema identifier. Not an actual ObjectId, only used for Schemas.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function ObjectId () {\n  throw new Error('This is an abstract interface. Its only purpose is to mark '\n                + 'fields as ObjectId in the schema creation.');\n}",
    "ctx": {
      "type": "function",
      "name": "ObjectId",
      "string": "ObjectId()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = exports = Schema;\n\n// require down here because of reference issues\nexports.Types = Types = require('./schema/index');\nNamedScope = require('./namedscope')\nQuery = require('./query');\n\nexports.ObjectId = ObjectId;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "exports = Schema",
      "string": "module.exports"
    }
  }
]
### lib/schemadefault.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var Schema = require('./schema')",
    "ctx": {
      "type": "declaration",
      "name": "Schema",
      "value": "require('./schema')",
      "string": "Schema"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Default model for querying the system.profiles<br />collection (it only exists when profiling is<br />enabled.</p>",
      "summary": "<p>Default model for querying the system.profiles<br />collection (it only exists when profiling is<br />enabled.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "exports['system.profile'] = new Schema({\n    ts: Date\n  , info: String // deprecated\n  , millis: Number\n  , op: String\n  , ns: String\n  , query: Schema.Types.Mixed\n  , updateobj: Schema.Types.Mixed\n  , ntoreturn: Number\n  , nreturned: Number\n  , nscanned: Number\n  , responseLength: Number\n  , client: String\n  , user: String\n  , idhack: Boolean\n  , scanAndOrder: Boolean\n  , keyUpdates: Number\n  , cursorid: Number\n}, { noVirtualId: true, noId: true });"
  }
]
### lib/schematype.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var MongooseError = require('./error');\nvar utils = require('./utils');",
    "ctx": {
      "type": "declaration",
      "name": "MongooseError",
      "value": "require('./error')",
      "string": "MongooseError"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>SchemaType constructor</p>",
      "summary": "<p>SchemaType constructor</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function SchemaType (path, options, instance) {\n  this.path = path;\n  this.instance = instance;\n  this.validators = [];\n  this.setters = [];\n  this.getters = [];\n  this.options = options;\n  this._index = null;\n  this.selected;\n\n  for (var i in options) if (this[i] && 'function' == typeof this[i]) {\n    // { unique: true, index: true }\n    if ('index' == i && this._index) continue;\n\n    var opts = Array.isArray(options[i])\n      ? options[i]\n      : [options[i]];\n\n    this[i].apply(this, opts);\n  }\n};",
    "ctx": {
      "type": "function",
      "name": "SchemaType",
      "string": "SchemaType()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "default",
        "description": "value"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets a default</p>",
      "summary": "<p>Sets a default</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "SchemaType.prototype.default = function (val) {\n  if (1 === arguments.length) {\n    this.defaultValue = typeof val === 'function'\n      ? val\n      : this.cast(val);\n    return this;\n  } else if (arguments.length > 1) {\n    this.defaultValue = utils.args(arguments);\n  }\n  return this.defaultValue;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "name": "default",
      "string": "SchemaType.prototype.default()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "true/",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Sets index. It can be a boolean or a hash of options</p>\n\n<h2>Example</h2>\n\n<p>Schema.path('my.path').index(true);<br />   Schema.path('my.path').index({ unique: true });</p>\n\n<p>\"Direction doesn't matter for single key indexes\"<br /><a href='http://www.mongodb.org/display/DOCS/Indexes#Indexes-CompoundKeysIndexes'>http://www.mongodb.org/display/DOCS/Indexes#Indexes-CompoundKeysIndexes</a></p>",
      "summary": "<p>Sets index. It can be a boolean or a hash of options</p>\n\n<h2>Example</h2>\n\n<p>Schema.path('my.path').index(true);<br />   Schema.path('my.path').index({ unique: true });</p>",
      "body": "<p>\"Direction doesn't matter for single key indexes\"<br /><a href='http://www.mongodb.org/display/DOCS/Indexes#Indexes-CompoundKeysIndexes'>http://www.mongodb.org/display/DOCS/Indexes#Indexes-CompoundKeysIndexes</a></p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "SchemaType.prototype.index = function (index) {\n  this._index = index;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "name": "index",
      "string": "SchemaType.prototype.index()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Adds an unique index</p>",
      "summary": "<p>Adds an unique index</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaType.prototype.unique = function (bool) {\n  if (!this._index || 'Object' !== this._index.constructor.name) {\n    this._index = {};\n  }\n\n  this._index.unique = bool;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "name": "unique",
      "string": "SchemaType.prototype.unique()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Adds an unique index</p>",
      "summary": "<p>Adds an unique index</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaType.prototype.sparse = function (bool) {\n  if (!this._index || 'Object' !== this._index.constructor.name) {\n    this._index = {};\n  }\n\n  this._index.sparse = bool;\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "name": "sparse",
      "string": "SchemaType.prototype.sparse()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "setter",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds a setter</p>",
      "summary": "<p>Adds a setter</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "SchemaType.prototype.set = function (fn) {\n  if ('function' != typeof fn)\n    throw new Error('A setter must be a function.');\n  this.setters.push(fn);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "name": "set",
      "string": "SchemaType.prototype.set()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "getter",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds a getter</p>",
      "summary": "<p>Adds a getter</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "SchemaType.prototype.get = function (fn) {\n  if ('function' != typeof fn)\n    throw new Error('A getter must be a function.');\n  this.getters.push(fn);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "name": "get",
      "string": "SchemaType.prototype.get()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "validator",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "optional",
        "description": "error message"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<h2>validate</h2>\n\n<p>Adds validators.</p>\n\n<h2>Examples</h2>\n\n<pre><code>function validator () { ... }\n\nvar single = [validator, 'failed']\nnew Schema({ name: { type: String, validate: single }});\n\nvar many = [\n    { validator: validator, msg: 'uh oh' }\n  , { validator: fn, msg: 'failed' }\n]\nnew Schema({ name: { type: String, validate: many }});\n</code></pre>",
      "summary": "<h2>validate</h2>",
      "body": "<p>Adds validators.</p>\n\n<h2>Examples</h2>\n\n<pre><code>function validator () { ... }\n\nvar single = [validator, 'failed']\nnew Schema({ name: { type: String, validate: single }});\n\nvar many = [\n    { validator: validator, msg: 'uh oh' }\n  , { validator: fn, msg: 'failed' }\n]\nnew Schema({ name: { type: String, validate: many }});\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "SchemaType.prototype.validate = function (obj, error) {\n  if ('function' == typeof obj || obj && 'RegExp' === obj.constructor.name) {\n    this.validators.push([obj, error]);\n    return this;\n  }\n\n  var i = arguments.length\n    , arg\n\n  while (i--) {\n    arg = arguments[i];\n    this.validators.push([arg.validator, arg.msg]);\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "name": "validate",
      "string": "SchemaType.prototype.validate()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "enable/disable",
        "description": "the validator"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds a required validator</p>",
      "summary": "<p>Adds a required validator</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "SchemaType.prototype.required = function (required) {\n  var self = this;\n\n  function __checkRequired (v) {\n    // in here, `this` refers to the validating document.\n    // no validation when this path wasn't selected in the query.\n    if ('isSelected' in this &&\n        !this.isSelected(self.path) &&\n        !this.isModified(self.path)) return true;\n    return self.checkRequired(v);\n  }\n\n  if (false === required) {\n    this.isRequired = false;\n    this.validators = this.validators.filter(function (v) {\n      return v[0].name !== '__checkRequired';\n    });\n  } else {\n    this.isRequired = true;\n    this.validators.push([__checkRequired, 'required']);\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "name": "required",
      "string": "SchemaType.prototype.required()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "scope",
        "description": "for callback defaults"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Gets the default value</p>",
      "summary": "<p>Gets the default value</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaType.prototype.getDefault = function (scope, init) {\n  var ret = 'function' === typeof this.defaultValue\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (null !== ret && undefined !== ret) {\n    return this.cast(ret, scope, init);\n  } else {\n    return ret;\n  }\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "name": "getDefault",
      "string": "SchemaType.prototype.getDefault()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "scope",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Applies setters</p>",
      "summary": "<p>Applies setters</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaType.prototype.applySetters = function (value, scope, init) {\n  if (SchemaType._isRef(this, value, init)) return value;\n\n  var v = value\n    , setters = this.setters\n    , len = setters.length\n\n  if (!len) {\n    if (null === v || undefined === v) return v;\n    return init\n      ? v // if we just initialized we dont recast\n      : this.cast(v, scope, init)\n  }\n\n  while (len--) {\n    v = setters[len].call(scope, v, this);\n  }\n\n  if (null === v || undefined === v) return v;\n\n  // do not cast until all setters are applied #665\n  v = this.cast(v, scope);\n\n  return v;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "name": "applySetters",
      "string": "SchemaType.prototype.applySetters()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "scope",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Applies getters to a value</p>",
      "summary": "<p>Applies getters to a value</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaType.prototype.applyGetters = function (value, scope) {\n  if (SchemaType._isRef(this, value, true)) return value;\n\n  var v = value\n    , getters = this.getters\n    , len = getters.length;\n\n  if (!len) {\n    return v;\n  }\n\n  while (len--) {\n    v = getters[len].call(scope, v, this);\n  }\n\n  return v;\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "name": "applyGetters",
      "string": "SchemaType.prototype.applyGetters()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<h2>select</h2>\n\n<p>Set default select() behavior for this path. True if<br />this path should always be included in the results,<br />false if it should be excluded by default. This setting<br />can be overridden at the query level.</p>\n\n<pre><code>T = db.model('T', new Schema({ x: { type: String, select: true }}));\nT.find(..); // x will always be selected ..\n// .. unless overridden;\nT.find().select({ x: 0 }).exec();\n</code></pre>",
      "summary": "<h2>select</h2>",
      "body": "<p>Set default select() behavior for this path. True if<br />this path should always be included in the results,<br />false if it should be excluded by default. This setting<br />can be overridden at the query level.</p>\n\n<pre><code>T = db.model('T', new Schema({ x: { type: String, select: true }}));\nT.find(..); // x will always be selected ..\n// .. unless overridden;\nT.find().select({ x: 0 }).exec();\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "SchemaType.prototype.select = function select (val) {\n  this.selected = !! val;\n}",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "name": "select",
      "string": "SchemaType.prototype.select()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "scope",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Performs a validation</p>",
      "summary": "<p>Performs a validation</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "SchemaType.prototype.doValidate = function (value, fn, scope) {\n  var err = false\n    , path = this.path\n    , count = this.validators.length;\n\n  if (!count) return fn(null);\n\n  function validate (val, msg) {\n    if (err) return;\n    if (val === undefined || val) {\n      --count || fn(null);\n    } else {\n      fn(err = new ValidatorError(path, msg));\n    }\n  }\n\n  this.validators.forEach(function (v) {\n    var validator = v[0]\n      , message   = v[1];\n\n    if (validator instanceof RegExp) {\n      validate(validator.test(value), message);\n    } else if ('function' === typeof validator) {\n      if (2 === validator.length) {\n        validator.call(scope, value, function (val) {\n          validate(val, message);\n        });\n      } else {\n        validate(validator.call(scope, value), message);\n      }\n    }\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "SchemaType",
      "name": "doValidate",
      "string": "SchemaType.prototype.doValidate()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "SchemaType"
        ],
        "name": "self",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "object"
        ],
        "name": "value",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Boolean"
        ],
        "name": "init",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "MongooseType"
        ],
        "name": "instance",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Boolean"
        ],
        "description": ""
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Determines if value is a valid Reference.</p>",
      "summary": "<p>Determines if value is a valid Reference.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "SchemaType._isRef = function (self, value, init) {\n  if (init && self.options && self.options.ref) {\n    if (null == value) return true;\n    if (value._id && value._id.constructor.name === self.instance) return true;\n  }\n\n  return false;\n}",
    "ctx": {
      "type": "method",
      "receiver": "SchemaType",
      "name": "_isRef",
      "string": "SchemaType._isRef()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "msg",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Schema validator error</p>",
      "summary": "<p>Schema validator error</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function ValidatorError (path, type) {\n  var msg = type\n    ? '\"' + type + '\" '\n    : '';\n  MongooseError.call(this, 'Validator ' + msg + 'failed for path ' + path);\n  Error.captureStackTrace(this, arguments.callee);\n  this.name = 'ValidatorError';\n  this.path = path;\n  this.type = type;\n};\n\nValidatorError.prototype.toString = function () {\n  return this.message;\n}",
    "ctx": {
      "type": "function",
      "name": "ValidatorError",
      "string": "ValidatorError()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from MongooseError</p>",
      "summary": "<p>Inherits from MongooseError</p>",
      "body": ""
    },
    "ignore": false,
    "code": "ValidatorError.prototype.__proto__ = MongooseError.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "ValidatorError",
      "name": "__proto__",
      "value": "MongooseError.prototype",
      "string": "ValidatorError.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Cast error</p>",
      "summary": "<p>Cast error</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function CastError (type, value) {\n  MongooseError.call(this, 'Cast to ' + type + ' failed for value \"' + value + '\"');\n  Error.captureStackTrace(this, arguments.callee);\n  this.name = 'CastError';\n  this.type = type;\n  this.value = value;\n};",
    "ctx": {
      "type": "function",
      "name": "CastError",
      "string": "CastError()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from MongooseError.</p>",
      "summary": "<p>Inherits from MongooseError.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "CastError.prototype.__proto__ = MongooseError.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "CastError",
      "name": "__proto__",
      "value": "MongooseError.prototype",
      "string": "CastError.prototype__proto__"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = exports = SchemaType;\n\nexports.CastError = CastError;\n\nexports.ValidatorError = ValidatorError;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "exports = SchemaType",
      "string": "module.exports"
    }
  }
]
### lib/statemachine.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var utils = require('./utils');",
    "ctx": {
      "type": "declaration",
      "name": "utils",
      "value": "require('./utils')",
      "string": "utils"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>StateMachine represents a minimal <code>interface</code> for the<br />constructors it builds via StateMachine.ctor(...).</p>",
      "summary": "<p>StateMachine represents a minimal <code>interface</code> for the<br />constructors it builds via StateMachine.ctor(...).</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var StateMachine = module.exports = exports = function StateMachine () {\n  this.paths = {};\n  this.states = {};\n}",
    "ctx": {
      "type": "declaration",
      "name": "StateMachine",
      "value": "module.exports = exports = function StateMachine () {",
      "string": "StateMachine"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "state",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[state]",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": "subclass constructor"
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>StateMachine.ctor('state1', 'state2', ...)<br />A factory method for subclassing StateMachine.<br />The arguments are a list of states. For each state,<br />the constructor's prototype gets state transition<br />methods named after each state. These transition methods<br />place their path argument into the given state.</p>",
      "summary": "<p>StateMachine.ctor('state1', 'state2', ...)<br />A factory method for subclassing StateMachine.<br />The arguments are a list of states. For each state,<br />the constructor's prototype gets state transition<br />methods named after each state. These transition methods<br />place their path argument into the given state.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "StateMachine.ctor = function () {\n  var states = utils.args(arguments);\n\n  var ctor = function () {\n    StateMachine.apply(this, arguments);\n    this.stateNames = states;\n\n    var i = states.length\n      , state;\n\n    while (i--) {\n      state = states[i];\n      this.states[state] = {};\n    }\n  };\n\n  ctor.prototype.__proto__ = StateMachine.prototype;\n\n  states.forEach(function (state) {\n    // Changes the `path`'s state to `state`.\n    ctor.prototype[state] = function (path) {\n      this._changeState(path, state);\n    }\n  });\n\n  return ctor;\n};",
    "ctx": {
      "type": "method",
      "receiver": "StateMachine",
      "name": "ctor",
      "string": "StateMachine.ctor()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<h2>This function is wrapped by the state change functions</h2>\n\n<ul>\n<li><code>require(path)</code></li>\n<li><code>modify(path)</code></li>\n<li><code>init(path)</code></li>\n</ul>",
      "summary": "<h2>This function is wrapped by the state change functions</h2>\n\n<ul>\n<li><code>require(path)</code></li>\n<li><code>modify(path)</code></li>\n<li><code>init(path)</code></li>\n</ul>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "StateMachine.prototype._changeState = function _changeState (path, nextState) {\n  var prevBucket = this.states[this.paths[path]];\n  if (prevBucket) delete prevBucket[path];\n\n  this.paths[path] = nextState;\n  this.states[nextState][path] = true;\n}\n\nStateMachine.prototype.clear = function clear (state) {\n  var keys = Object.keys(this.states[state])\n    , i = keys.length\n    , path\n\n  while (i--) {\n    path = keys[i];\n    delete this.states[state][path];\n    delete this.paths[path];\n  }\n}",
    "ctx": {
      "type": "method",
      "constructor": "StateMachine",
      "name": "_changeState",
      "string": "StateMachine.prototype._changeState()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "state",
        "description": "that we want to check for."
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Checks to see if at least one path is in the states passed in via <code>arguments</code><br />e.g., this.some('required', 'inited')</p>",
      "summary": "<p>Checks to see if at least one path is in the states passed in via <code>arguments</code><br />e.g., this.some('required', 'inited')</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "StateMachine.prototype.some = function some () {\n  var self = this;\n  var what = arguments.length ? arguments : this.stateNames;\n  return Array.prototype.some.call(what, function (state) {\n    return Object.keys(self.states[state]).length;\n  });\n}",
    "ctx": {
      "type": "method",
      "constructor": "StateMachine",
      "name": "some",
      "string": "StateMachine.prototype.some()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "iterMethod",
        "description": "is either 'forEach' or 'map'"
      },
      {
        "type": "return",
        "types": [
          "Function"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>This function builds the functions that get assigned to <code>forEach</code> and <code>map</code>,<br />since both of those methods share a lot of the same logic.</p>",
      "summary": "<p>This function builds the functions that get assigned to <code>forEach</code> and <code>map</code>,<br />since both of those methods share a lot of the same logic.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "StateMachine.prototype._iter = function _iter (iterMethod) {\n  return function () {\n    var numArgs = arguments.length\n      , states = utils.args(arguments, 0, numArgs-1)\n      , callback = arguments[numArgs-1];\n\n    if (!states.length) states = this.stateNames;\n\n    var self = this;\n\n    var paths = states.reduce(function (paths, state) {\n      return paths.concat(Object.keys(self.states[state]));\n    }, []);\n\n    return paths[iterMethod](function (path, i, paths) {\n      return callback(path, i, paths);\n    });\n  };\n}",
    "ctx": {
      "type": "method",
      "constructor": "StateMachine",
      "name": "_iter",
      "string": "StateMachine.prototype._iter()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[state]",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[state]",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Iterates over the paths that belong to one of the parameter states.</p>\n\n<h2>The function profile can look like</h2>\n\n<p>this.forEach(state1, fn);         // iterates over all paths in state1<br />this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2<br />this.forEach(fn);                 // iterates over all paths in all states</p>",
      "summary": "<p>Iterates over the paths that belong to one of the parameter states.</p>",
      "body": "<h2>The function profile can look like</h2>\n\n<p>this.forEach(state1, fn);         // iterates over all paths in state1<br />this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2<br />this.forEach(fn);                 // iterates over all paths in all states</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "StateMachine.prototype.forEach = function forEach () {\n  this.forEach = this._iter('forEach');\n  return this.forEach.apply(this, arguments);\n}",
    "ctx": {
      "type": "method",
      "constructor": "StateMachine",
      "name": "forEach",
      "string": "StateMachine.prototype.forEach()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[state]",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "[state]",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": ""
      },
      {
        "type": "private",
        "string": ""
      }
    ],
    "description": {
      "full": "<p>Maps over the paths that belong to one of the parameter states.</p>\n\n<h2>The function profile can look like</h2>\n\n<p>this.forEach(state1, fn);         // iterates over all paths in state1<br />this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2<br />this.forEach(fn);                 // iterates over all paths in all states</p>",
      "summary": "<p>Maps over the paths that belong to one of the parameter states.</p>",
      "body": "<h2>The function profile can look like</h2>\n\n<p>this.forEach(state1, fn);         // iterates over all paths in state1<br />this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2<br />this.forEach(fn);                 // iterates over all paths in all states</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "StateMachine.prototype.map = function map () {\n  this.map = this._iter('map');\n  return this.map.apply(this, arguments);\n}",
    "ctx": {
      "type": "method",
      "constructor": "StateMachine",
      "name": "map",
      "string": "StateMachine.prototype.map()"
    }
  }
]
### lib/types/array.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var EmbeddedDocument = require('./embedded');\nvar Document = require('../document');\nvar ObjectId = require('./objectid');",
    "ctx": {
      "type": "declaration",
      "name": "EmbeddedDocument",
      "value": "require('./embedded')",
      "string": "EmbeddedDocument"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "values",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": "path"
      },
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "parent",
        "description": "document"
      },
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "see",
        "title": "",
        "url": "http://bit.ly/f6CnZU",
        "visibility": "http://bit.ly/f6CnZU"
      }
    ],
    "description": {
      "full": "<p>Mongoose Array constructor.<br />Values always have to be passed to the constructor to initialize, since<br />otherwise MongooseArray#push will mark the array as modified to the parent.</p>",
      "summary": "<p>Mongoose Array constructor.<br />Values always have to be passed to the constructor to initialize, since<br />otherwise MongooseArray#push will mark the array as modified to the parent.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function MongooseArray (values, path, doc) {\n  var arr = [];\n  arr.push.apply(arr, values);\n  arr.__proto__ = MongooseArray.prototype;\n\n  arr._atomics = {};\n  arr.validators = [];\n  arr._path = path;\n\n  if (doc) {\n    arr._parent = doc;\n    arr._schema = doc.schema.path(path);\n  }\n\n  return arr;\n};",
    "ctx": {
      "type": "function",
      "name": "MongooseArray",
      "string": "MongooseArray()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherit from Array</p>",
      "summary": "<p>Inherit from Array</p>",
      "body": ""
    },
    "ignore": false,
    "code": "MongooseArray.prototype = new Array;",
    "ctx": {
      "type": "property",
      "receiver": "MongooseArray",
      "name": "prototype",
      "value": "new Array",
      "string": "MongooseArray.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Stores a queue of atomic operations to perform</p>",
      "summary": "<p>Stores a queue of atomic operations to perform</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "MongooseArray.prototype._atomics;"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Parent owner document</p>",
      "summary": "<p>Parent owner document</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "MongooseArray.prototype._parent;"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Casts a member</p>",
      "summary": "<p>Casts a member</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "MongooseArray.prototype._cast = function (value) {\n  var cast = this._schema.caster.cast\n    , doc = this._parent;\n\n  return cast.call(null, value, doc);\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "_cast",
      "string": "MongooseArray.prototype._cast()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "EmbeddedDocument"
        ],
        "name": "embeddedDoc",
        "description": "that invokes this method on the Array"
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "embeddedPath",
        "description": "is what changed inthe embeddedDoc"
      },
      {
        "type": "",
        "string": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Marks this array as modified.<br />It is called during a nonAtomicPush, an atomic opteration,<br />or by an existing embedded document that is modified.</p>\n\n<p>If it bubbles up from an embedded document change,<br />then it takes the following arguments (otherwise, takes<br />0 arguments)</p>",
      "summary": "<p>Marks this array as modified.<br />It is called during a nonAtomicPush, an atomic opteration,<br />or by an existing embedded document that is modified.</p>",
      "body": "<p>If it bubbles up from an embedded document change,<br />then it takes the following arguments (otherwise, takes<br />0 arguments)</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype._markModified = function (embeddedDoc, embeddedPath) {\n  var parent = this._parent\n    , dirtyPath;\n\n  if (parent) {\n    if (arguments.length) {\n      // If an embedded doc bubbled up the change\n      dirtyPath = [this._path, this.indexOf(embeddedDoc), embeddedPath].join('.');\n    } else {\n      dirtyPath = this._path;\n    }\n    parent.markModified(dirtyPath);\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "_markModified",
      "string": "MongooseArray.prototype._markModified()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "operation",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Register an atomic operation with the parent</p>",
      "summary": "<p>Register an atomic operation with the parent</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "MongooseArray.prototype._registerAtomic = function (op, val) {\n  if ('$set' == op) {\n    // $set takes precedence over all other ops.\n    // mark entire array modified.\n    this._atomics = { $set: val };\n    this._markModified();\n    return this;\n  }\n\n  var atomics = this._atomics;\n\n  // reset pop/shift after save\n  if ('$pop' == op && !('$pop' in atomics)) {\n    var self = this;\n    this._parent.once('save', function () {\n      self._popped = self._shifted = null;\n    });\n  }\n\n  if (this._atomics.$set) {\n    return this;\n  }\n\n  // check for impossible $atomic combos (Mongo denies more than one\n  // $atomic op on a single path\n  if (Object.keys(atomics).length && !(op in atomics)) {\n    // a different op was previously registered.\n    // save the entire thing.\n    this._atomics = { $set: this };\n    this._markModified();\n    return this;\n  }\n\n  if (op === '$pullAll' || op === '$pushAll' || op === '$addToSet') {\n    atomics[op] || (atomics[op] = []);\n    atomics[op] = atomics[op].concat(val);\n  } else if (op === '$pullDocs') {\n    var pullOp = atomics['$pull'] || (atomics['$pull'] = {})\n      , selector = pullOp['_id'] || (pullOp['_id'] = {'$in' : [] });\n    selector['$in'] = selector['$in'].concat(val);\n  } else {\n    atomics[op] = val;\n  }\n\n  this._markModified();\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "_registerAtomic",
      "string": "MongooseArray.prototype._registerAtomic()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns true if we have to perform atomics for this, and no normal<br />operations</p>",
      "summary": "<p>Returns true if we have to perform atomics for this, and no normal<br />operations</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.hasAtomics = function hasAtomics () {\n  if (!(this._atomics && 'Object' === this._atomics.constructor.name)) {\n    return 0;\n  }\n\n  return Object.keys(this._atomics).length;\n}",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "hasAtomics",
      "string": "MongooseArray.prototype.hasAtomics()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Pushes item/s to the array atomically. Overrides Array#push</p>",
      "summary": "<p>Pushes item/s to the array atomically. Overrides Array#push</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.push = function () {\n  var values = [].map.call(arguments, this._cast, this)\n    , ret = [].push.apply(this, values);\n\n  // $pushAll might be fibbed (could be $push). But it makes it easier to\n  // handle what could have been $push, $pushAll combos\n  this._registerAtomic('$pushAll', values);\n  return ret;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "push",
      "string": "MongooseArray.prototype.push()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Pushes item/s to the array non-atomically</p>",
      "summary": "<p>Pushes item/s to the array non-atomically</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.nonAtomicPush = function () {\n  var values = [].map.call(arguments, this._cast, this)\n    , ret = [].push.apply(this, values);\n  this._registerAtomic('$set', this);\n  return ret;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "nonAtomicPush",
      "string": "MongooseArray.prototype.nonAtomicPush()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Pops the array atomically</p>\n\n<p>Only works once per doc.save(). Calling this mulitple<br />times on an array before saving sends the same command<br />as calling it once. See MongoDB docs.</p>",
      "summary": "<p>Pops the array atomically</p>",
      "body": "<p>Only works once per doc.save(). Calling this mulitple<br />times on an array before saving sends the same command<br />as calling it once. See MongoDB docs.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.$pop = function () {\n  this._registerAtomic('$pop', 1);\n\n  // only allow popping once\n  if (this._popped) return;\n  this._popped = true;\n\n  return [].pop.call(this);\n};"
  },
  {
    "tags": [
      {
        "type": "see",
        "local": "the $pop atomic alternative method.",
        "visibility": "the"
      },
      {
        "type": "",
        "string": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Non-atomically pops the array.</p>\n\n<p>Note: marks the <em>entire</em> array as modified which<br />will pass the entire thing to $set potentially<br />overwritting any changes that happen between<br />when you retrieved the object and when you save<br />it.</p>",
      "summary": "<p>Non-atomically pops the array.</p>",
      "body": "<p>Note: marks the <em>entire</em> array as modified which<br />will pass the entire thing to $set potentially<br />overwritting any changes that happen between<br />when you retrieved the object and when you save<br />it.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.pop = function () {\n  var ret = [].pop.call(this);\n  this._registerAtomic('$set', this);\n  return ret;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "pop",
      "string": "MongooseArray.prototype.pop()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Atomically shifts the array.</p>\n\n<p>Only works once per doc.save(). Calling this mulitple<br />times on an array before saving sends the same command<br />as calling it once. See MongoDB docs.</p>",
      "summary": "<p>Atomically shifts the array.</p>",
      "body": "<p>Only works once per doc.save(). Calling this mulitple<br />times on an array before saving sends the same command<br />as calling it once. See MongoDB docs.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.$shift = function $shift () {\n  this._registerAtomic('$pop', -1);\n\n  // only allow shifting once\n  if (this._shifted) return;\n  this._shifted = true;\n\n  return [].shift.call(this);\n};"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>shift</p>\n\n<p>Non-atomically shifts the array.</p>\n\n<p>Note: marks the <em>entire</em> array as modified which<br />will pass the entire thing to $set potentially<br />overwritting any changes that happen between<br />when you retrieved the object and when you save<br />it.</p>",
      "summary": "<p>shift</p>",
      "body": "<p>Non-atomically shifts the array.</p>\n\n<p>Note: marks the <em>entire</em> array as modified which<br />will pass the entire thing to $set potentially<br />overwritting any changes that happen between<br />when you retrieved the object and when you save<br />it.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.shift = function () {\n  var ret = [].shift.call(this);\n  this._registerAtomic('$set', this);\n  return ret;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "shift",
      "string": "MongooseArray.prototype.shift()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": "to remove"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>remove</p>\n\n<p>Removes items from an array atomically</p>\n\n<h2>Examples</h2>\n\n<pre><code>doc.array.remove(ObjectId)\ndoc.array.remove('tag 1', 'tag 2')\n</code></pre>",
      "summary": "<p>remove</p>",
      "body": "<p>Removes items from an array atomically</p>\n\n<h2>Examples</h2>\n\n<pre><code>doc.array.remove(ObjectId)\ndoc.array.remove('tag 1', 'tag 2')\n</code></pre>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.remove = function () {\n  var args = [].map.call(arguments, this._cast, this);\n  if (args.length == 1)\n    this.pull(args[0]);\n  else\n    this.pull.apply(this, args);\n  return args;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "remove",
      "string": "MongooseArray.prototype.remove()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Pulls from the array</p>",
      "summary": "<p>Pulls from the array</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.pull = function () {\n  var values = [].map.call(arguments, this._cast, this)\n    , cur = this._parent.get(this._path)\n    , i = cur.length\n    , mem;\n\n  while (i--) {\n    mem = cur[i];\n    if (mem instanceof EmbeddedDocument) {\n      if (values.some(function (v) { return v.equals(mem); } )) {\n        [].splice.call(cur, i, 1);\n      }\n    } else if (~cur.indexOf.call(values, mem)) {\n      [].splice.call(cur, i, 1);\n    }\n  }\n\n  if (values[0] instanceof EmbeddedDocument) {\n    this._registerAtomic('$pullDocs', values.map( function (v) { return v._id; } ));\n  } else {\n    this._registerAtomic('$pullAll', values);\n  }\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "pull",
      "string": "MongooseArray.prototype.pull()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Splices the array.</p>\n\n<p>Note: marks the <em>entire</em> array as modified which<br />will pass the entire thing to $set potentially<br />overwritting any changes that happen on the db between<br />when you retrieved the object and when you save<br />it.</p>",
      "summary": "<p>Splices the array.</p>",
      "body": "<p>Note: marks the <em>entire</em> array as modified which<br />will pass the entire thing to $set potentially<br />overwritting any changes that happen on the db between<br />when you retrieved the object and when you save<br />it.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.splice = function () {\n  if (arguments.length) {\n    var ret = [].splice.apply(this, arguments);\n    this._registerAtomic('$set', this);\n  }\n  return ret;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "splice",
      "string": "MongooseArray.prototype.splice()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Non-atomically unshifts onto the array.</p>\n\n<p>Note: marks the <em>entire</em> array as modified which<br />will pass the entire thing to $set potentially<br />overwritting any changes that happen between<br />when you retrieved the object and when you save<br />it.</p>",
      "summary": "<p>Non-atomically unshifts onto the array.</p>",
      "body": "<p>Note: marks the <em>entire</em> array as modified which<br />will pass the entire thing to $set potentially<br />overwritting any changes that happen between<br />when you retrieved the object and when you save<br />it.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.unshift = function () {\n  var values = [].map.call(arguments, this._cast, this);\n  [].unshift.apply(this, values);\n  this._registerAtomic('$set', this);\n  return this.length;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "unshift",
      "string": "MongooseArray.prototype.unshift()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>sort</p>",
      "summary": "<p>sort</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.sort = function () {\n  var ret = [].sort.apply(this, arguments);\n  this._registerAtomic('$set', this);\n  return ret;\n}",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "sort",
      "string": "MongooseArray.prototype.sort()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds values to the array if not already present.</p>",
      "summary": "<p>Adds values to the array if not already present.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.addToSet = function addToSet () {\n  var values = [].map.call(arguments, this._cast, this)\n    , added = []\n    , type = values[0] instanceof EmbeddedDocument ? 'doc' :\n             values[0] instanceof Date ? 'date' :\n             '';\n\n  values.forEach(function (v) {\n    var found;\n    switch (type) {\n      case 'doc':\n        found = this.some(function(doc){ return doc.equals(v) });\n        break;\n      case 'date':\n        var val = +v;\n        found = this.some(function(d){ return +d === val });\n        break;\n      default:\n        found = ~this.indexOf(v);\n    }\n\n    if (!found) {\n      [].push.call(this, v);\n      this._registerAtomic('$addToSet', v);\n      [].push.call(added, v);\n    }\n  }, this);\n\n  return added;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "addToSet",
      "string": "MongooseArray.prototype.addToSet()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns an native js Array</p>",
      "summary": "<p>Returns an native js Array</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.toObject = function (options) {\n  if (options && options.depopulate && this[0] instanceof Document) {\n    return this.map(function (doc) {\n      return doc._id;\n    });\n  }\n\n  // return this.slice()?\n  return this.map(function (doc) {\n    return doc;\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "toObject",
      "string": "MongooseArray.prototype.toObject()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Helper for console.log</p>",
      "summary": "<p>Helper for console.log</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.inspect = function () {\n  return '[' + this.map(function (doc) {\n    return ' ' + doc;\n  }) + ' ]';\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "inspect",
      "string": "MongooseArray.prototype.inspect()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "obj",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Number"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Return the index of <code>obj</code> or <code>-1.</code></p>",
      "summary": "<p>Return the index of <code>obj</code> or <code>-1.</code></p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseArray.prototype.indexOf = function indexOf (obj) {\n  if (obj instanceof ObjectId) obj = obj.toString();\n  for (var i = 0, len = this.length; i < len; ++i) {\n    if (obj == this[i])\n      return i;\n  }\n  return -1;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseArray",
      "name": "indexOf",
      "string": "MongooseArray.prototype.indexOf()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = exports = MongooseArray;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "exports = MongooseArray",
      "string": "module.exports"
    }
  }
]
### lib/types/buffer.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Access driver.</p>",
      "summary": "<p>Access driver.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var driver = global.MONGOOSE_DRIVER_PATH || '../drivers/node-mongodb-native';",
    "ctx": {
      "type": "declaration",
      "name": "driver",
      "value": "global.MONGOOSE_DRIVER_PATH || '../drivers/node-mongodb-native'",
      "string": "driver"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var Binary = require(driver + '/binary');",
    "ctx": {
      "type": "declaration",
      "name": "Binary",
      "value": "require(driver + '/binary')",
      "string": "Binary"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Buffer"
        ],
        "name": "value",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": "path"
      },
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "parent",
        "description": "document"
      },
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "see",
        "title": "",
        "url": "http://bit.ly/f6CnZU",
        "visibility": "http://bit.ly/f6CnZU"
      }
    ],
    "description": {
      "full": "<p>Mongoose Buffer constructor.<br />Values always have to be passed to the constructor to initialize, since<br />otherwise MongooseBuffer#push will mark the buffer as modified to the parent.</p>",
      "summary": "<p>Mongoose Buffer constructor.<br />Values always have to be passed to the constructor to initialize, since<br />otherwise MongooseBuffer#push will mark the buffer as modified to the parent.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function MongooseBuffer (value, encode, offset) {\n  var length = arguments.length;\n  var val;\n\n  if (0 === length || null === arguments[0] || undefined === arguments[0]) {\n    val = 0;\n  } else {\n    val = value;\n  }\n\n  var encoding;\n  var path;\n  var doc;\n\n  if (Array.isArray(encode)) {\n    // internal casting\n    path = encode[0];\n    doc = encode[1];\n  } else {\n    encoding = encode;\n  }\n\n  var buf = new Buffer(val, encoding, offset);\n  buf.__proto__ = MongooseBuffer.prototype;\n\n  // make sure these internal props don't show up in Object.keys()\n  Object.defineProperties(buf, {\n      validators: { value: [] }\n    , _path: { value: path }\n    , _parent: { value: doc }\n  });\n\n  if (doc && \"string\" === typeof path) {\n    Object.defineProperty(buf, '_schema', {\n        value: doc.schema.path(path)\n    });\n  }\n\n  return buf;\n};",
    "ctx": {
      "type": "function",
      "name": "MongooseBuffer",
      "string": "MongooseBuffer()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherit from Buffer.</p>",
      "summary": "<p>Inherit from Buffer.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "MongooseBuffer.prototype = new Buffer(0);",
    "ctx": {
      "type": "property",
      "receiver": "MongooseBuffer",
      "name": "prototype",
      "value": "new Buffer(0)",
      "string": "MongooseBuffer.prototype"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Parent owner document</p>",
      "summary": "<p>Parent owner document</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "MongooseBuffer.prototype._parent;"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Marks this buffer as modified.</p>",
      "summary": "<p>Marks this buffer as modified.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseBuffer.prototype._markModified = function () {\n  var parent = this._parent;\n\n  if (parent) {\n    parent.markModified(this._path);\n  }\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseBuffer",
      "name": "_markModified",
      "string": "MongooseBuffer.prototype._markModified()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Writes the buffer.</p>",
      "summary": "<p>Writes the buffer.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "MongooseBuffer.prototype.write = function () {\n  var written = Buffer.prototype.write.apply(this, arguments);\n\n  if (written > 0) {\n    this._markModified();\n  }\n\n  return written;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseBuffer",
      "name": "write",
      "string": "MongooseBuffer.prototype.write()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Copy the buffer.</p>\n\n<p>Note: Buffer#copy will not mark target as modified so<br />you must copy from a MongooseBuffer for it to work<br />as expected.</p>\n\n<p>Work around since copy modifies the target, not this.</p>",
      "summary": "<p>Copy the buffer.</p>",
      "body": "<p>Note: Buffer#copy will not mark target as modified so<br />you must copy from a MongooseBuffer for it to work<br />as expected.</p>\n\n<p>Work around since copy modifies the target, not this.</p>"
    },
    "ignore": false,
    "code": "MongooseBuffer.prototype.copy = function (target) {\n  var ret = Buffer.prototype.copy.apply(this, arguments);\n\n  if (target instanceof MongooseBuffer) {\n    target._markModified();\n  }\n\n  return ret;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseBuffer",
      "name": "copy",
      "string": "MongooseBuffer.prototype.copy()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Compile other Buffer methods marking this buffer as modified.</p>",
      "summary": "<p>Compile other Buffer methods marking this buffer as modified.</p>",
      "body": ""
    },
    "ignore": false,
    "code": ";(\n// node < 0.5\n'writeUInt8 writeUInt16 writeUInt32 writeInt8 writeInt16 writeInt32 ' +\n'writeFloat writeDouble fill ' +\n'utf8Write binaryWrite asciiWrite set ' +\n\n// node >= 0.5\n'writeUInt16LE writeUInt16BE writeUInt32LE writeUInt32BE ' +\n'writeInt16LE writeInt16BE writeInt32LE writeInt32BE ' +\n'writeFloatLE writeFloatBE writeDoubleLE writeDoubleBE'\n).split(' ').forEach(function (method) {\n  if (!Buffer.prototype[method]) return;\n  MongooseBuffer.prototype[method] = new Function(\n    'var ret = Buffer.prototype.'+method+'.apply(this, arguments);' +\n    'this._markModified();' +\n    'return ret;'\n  )\n});"
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Hex"
        ],
        "name": "BSON",
        "description": "SubType"
      },
      {
        "type": "SubTypes:",
        "string": ""
      },
      {
        "type": "",
        "string": "0x00: Binary/Generic"
      },
      {
        "type": "",
        "string": "0x01: Function"
      },
      {
        "type": "",
        "string": "0x02: Binary (Deprecated, 0x00 is new default)"
      },
      {
        "type": "",
        "string": "0x03: UUID"
      },
      {
        "type": "",
        "string": "0x04: MD5"
      },
      {
        "type": "",
        "string": "0x80: User Defined"
      },
      {
        "type": "",
        "string": "More info here: http://bsonspec.org/#/specification"
      },
      {
        "type": "return",
        "types": [
          "Buffer"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns a Binary.</p>",
      "summary": "<p>Returns a Binary.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseBuffer.prototype.toObject = function (subtype) {\n  subtype = typeof subtype !== 'undefined' ? subtype : 0x00\n  return new Binary(this, subtype);\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseBuffer",
      "name": "toObject",
      "string": "MongooseBuffer.prototype.toObject()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "MongooseBuffer.Binary = Binary;\n\nmodule.exports = MongooseBuffer;",
    "ctx": {
      "type": "property",
      "receiver": "MongooseBuffer",
      "name": "Binary",
      "value": "Binary",
      "string": "MongooseBuffer.Binary"
    }
  }
]
### lib/types/documentarray.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var MongooseArray = require('./array')\n  , driver = global.MONGOOSE_DRIVER_PATH || '../drivers/node-mongodb-native'\n  , ObjectId = require(driver + '/objectid')\n  , ObjectIdSchema = require('../schema/objectid')\n  , util = require('util')",
    "ctx": {
      "type": "declaration",
      "name": "MongooseArray",
      "value": "require('./array')",
      "string": "MongooseArray"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Array"
        ],
        "name": "values",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "key",
        "description": "path"
      },
      {
        "type": "param",
        "types": [
          "Document"
        ],
        "name": "parent",
        "description": "document"
      },
      {
        "type": "api",
        "visibility": "private"
      },
      {
        "type": "see",
        "title": "",
        "url": "http://bit.ly/f6CnZU",
        "visibility": "http://bit.ly/f6CnZU"
      }
    ],
    "description": {
      "full": "<p>Array of embedded documents<br />Values always have to be passed to the constructor to initialize, since<br />otherwise MongooseArray#push will mark the array as modified to the parent.</p>",
      "summary": "<p>Array of embedded documents<br />Values always have to be passed to the constructor to initialize, since<br />otherwise MongooseArray#push will mark the array as modified to the parent.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function MongooseDocumentArray (values, path, doc) {\n  var arr = [];\n  arr.push.apply(arr, values);\n  arr.__proto__ = MongooseDocumentArray.prototype;\n\n  arr._atomics = {};\n  arr.validators = [];\n  arr._path = path;\n\n  if (doc) {\n    arr._parent = doc;\n    arr._schema = doc.schema.path(path);\n    doc.on('save', arr.notify('save'));\n    doc.on('isNew', arr.notify('isNew'));\n  }\n\n  return arr;\n};",
    "ctx": {
      "type": "function",
      "name": "MongooseDocumentArray",
      "string": "MongooseDocumentArray()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherits from MongooseArray</p>",
      "summary": "<p>Inherits from MongooseArray</p>",
      "body": ""
    },
    "ignore": false,
    "code": "MongooseDocumentArray.prototype.__proto__ = MongooseArray.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "MongooseDocumentArray",
      "name": "__proto__",
      "value": "MongooseArray.prototype",
      "string": "MongooseDocumentArray.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Overrides cast</p>",
      "summary": "<p>Overrides cast</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "MongooseDocumentArray.prototype._cast = function (value) {\n  var doc = new this._schema.casterConstructor(value, this);\n  return doc;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseDocumentArray",
      "name": "_cast",
      "string": "MongooseDocumentArray.prototype._cast()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "id",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Filters items by id</p>",
      "summary": "<p>Filters items by id</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseDocumentArray.prototype.id = function (id) {\n  var casted\n    , _id;\n\n  try {\n    casted = ObjectId.toString(ObjectIdSchema.prototype.cast.call({}, id));\n  } catch (e) {\n    casted = null;\n  }\n\n  for (var i = 0, l = this.length; i < l; i++) {\n    _id = this[i].get('_id');\n    if (!(_id instanceof ObjectId)) {\n      if (String(id) == _id)\n        return this[i];\n    } else {\n      if (casted == _id)\n        return this[i];\n    }\n  }\n\n  return null;\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseDocumentArray",
      "name": "id",
      "string": "MongooseDocumentArray.prototype.id()"
    }
  },
  {
    "tags": [
      {
        "type": "return",
        "types": [
          "Array"
        ],
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Returns an Array and converts any Document<br />members toObject.</p>",
      "summary": "<p>Returns an Array and converts any Document<br />members toObject.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseDocumentArray.prototype.toObject = function () {\n  return this.map(function (doc) {\n    return doc && doc.toObject() || null;\n  });\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseDocumentArray",
      "name": "toObject",
      "string": "MongooseDocumentArray.prototype.toObject()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Helper for console.log</p>",
      "summary": "<p>Helper for console.log</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseDocumentArray.prototype.inspect = function () {\n  return '[' + this.map(function (doc) {\n    if (doc) {\n      return doc.inspect\n        ? doc.inspect()\n        : util.inspect(doc)\n    }\n    return 'null'\n  }).join('\\n') + ']';\n};",
    "ctx": {
      "type": "method",
      "constructor": "MongooseDocumentArray",
      "name": "inspect",
      "string": "MongooseDocumentArray.prototype.inspect()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>create</p>\n\n<p>Creates a subdocument casted to this schema.</p>",
      "summary": "<p>create</p>",
      "body": "<p>Creates a subdocument casted to this schema.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "MongooseDocumentArray.prototype.create = function (v) {\n  return new this._schema.casterConstructor(v);\n}",
    "ctx": {
      "type": "method",
      "constructor": "MongooseDocumentArray",
      "name": "create",
      "string": "MongooseDocumentArray.prototype.create()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "event",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Create fn that notifies all child docs of event.</p>",
      "summary": "<p>Create fn that notifies all child docs of event.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "MongooseDocumentArray.prototype.notify = function notify (event) {\n  var self = this;\n  return function notify (val) {\n    var i = self.length;\n    while (i--) {\n      self[i].emit(event, val);\n    }\n  }\n}",
    "ctx": {
      "type": "method",
      "constructor": "MongooseDocumentArray",
      "name": "notify",
      "string": "MongooseDocumentArray.prototype.notify()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = MongooseDocumentArray;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "MongooseDocumentArray",
      "string": "module.exports"
    }
  }
]
### lib/types/embedded.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var Document = require('../document')\n  , inspect = require('util').inspect;",
    "ctx": {
      "type": "declaration",
      "name": "Document",
      "value": "require('../document')",
      "string": "Document"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "object",
        "description": "from db"
      },
      {
        "type": "param",
        "types": [
          "MongooseDocumentArray"
        ],
        "name": "parent",
        "description": "array"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>EmbeddedDocument constructor.</p>",
      "summary": "<p>EmbeddedDocument constructor.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function EmbeddedDocument (obj, parentArr, skipId) {\n  if (parentArr) {\n    this.__parentArray = parentArr;\n    this.__parent = parentArr._parent;\n  } else {\n    this.__parentArray = undefined;\n    this.__parent = undefined;\n  }\n\n  Document.call(this, obj, undefined, skipId);\n\n  var self = this;\n  this.on('isNew', function (val) {\n    self.isNew = val;\n  });\n};",
    "ctx": {
      "type": "function",
      "name": "EmbeddedDocument",
      "string": "EmbeddedDocument()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherit from Document</p>",
      "summary": "<p>Inherit from Document</p>",
      "body": ""
    },
    "ignore": false,
    "code": "EmbeddedDocument.prototype.__proto__ = Document.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "EmbeddedDocument",
      "name": "__proto__",
      "value": "Document.prototype",
      "string": "EmbeddedDocument.prototype__proto__"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Marks parent array as modified</p>",
      "summary": "<p>Marks parent array as modified</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "// TODO remove commit alias\nEmbeddedDocument.prototype.commit =\nEmbeddedDocument.prototype.markModified = function (path) {\n  if (!this.__parentArray) return;\n\n  this._activePaths.modify(path);\n\n  if (this.isNew) {\n    // Mark the WHOLE parent array as modified\n    // if this is a new document (i.e., we are initializing\n    // a document),\n    this.__parentArray._markModified();\n  } else\n    this.__parentArray._markModified(this, path);\n};"
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Noop. Does not actually save the doc to the db.</p>",
      "summary": "<p>Noop. Does not actually save the doc to the db.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "EmbeddedDocument.prototype.save = function(fn) {\n  if (fn)\n    fn(null);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "EmbeddedDocument",
      "name": "save",
      "string": "EmbeddedDocument.prototype.save()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Remove the subdocument</p>",
      "summary": "<p>Remove the subdocument</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "EmbeddedDocument.prototype.remove = function (fn) {\n  if (!this.__parentArray) return this;\n\n  var _id;\n  if (!this.willRemove) {\n    _id = this._doc._id;\n    if (!_id) {\n      throw new Error('For your own good, Mongoose does not know ' + \n                      'how to remove an EmbeddedDocument that has no _id');\n    }\n    this.__parentArray.pull({ _id: _id });\n    this.willRemove = true;\n  }\n\n  if (fn)\n    fn(null);\n\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "EmbeddedDocument",
      "name": "remove",
      "string": "EmbeddedDocument.prototype.remove()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Helper for console.log</p>",
      "summary": "<p>Helper for console.log</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "EmbeddedDocument.prototype.inspect = function () {\n  return inspect(this.toObject());\n};",
    "ctx": {
      "type": "method",
      "constructor": "EmbeddedDocument",
      "name": "inspect",
      "string": "EmbeddedDocument.prototype.inspect()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "path",
        "description": "of the field to invalidate"
      },
      {
        "type": "param",
        "types": [
          "String",
          "Error"
        ],
        "name": "error",
        "description": "of the path."
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Invalidate</p>\n\n<p>Report accurate embedded paths for invalidation.</p>",
      "summary": "<p>Invalidate</p>",
      "body": "<p>Report accurate embedded paths for invalidation.</p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "EmbeddedDocument.prototype.invalidate = function (path, err) {\n  if (!this.__parent) return false;\n  var index = this.__parentArray.indexOf(this);\n  var parentPath = this.__parentArray._path;\n  var fullPath = [parentPath, index, path].join('.');\n  this.__parent.invalidate(fullPath, err);\n  return true;\n}",
    "ctx": {
      "type": "method",
      "constructor": "EmbeddedDocument",
      "name": "invalidate",
      "string": "EmbeddedDocument.prototype.invalidate()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "module.exports = EmbeddedDocument;",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "EmbeddedDocument",
      "string": "module.exports"
    }
  }
]
### lib/types/index.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "exports.Array = require('./array');\nexports.Buffer = require('./buffer');\n\nexports.Document = // @deprecate\nexports.Embedded = require('./embedded');\n\nexports.DocumentArray = require('./documentarray');\n//exports.Number = require('./number');\nexports.ObjectId = require('./objectid');",
    "ctx": {
      "type": "property",
      "receiver": "exports",
      "name": "Array",
      "value": "require('./array')",
      "string": "exports.Array"
    }
  }
]
### lib/types/objectid.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Access driver.</p>",
      "summary": "<p>Access driver.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var driver = global.MONGOOSE_DRIVER_PATH || '../drivers/node-mongodb-native';",
    "ctx": {
      "type": "declaration",
      "name": "driver",
      "value": "global.MONGOOSE_DRIVER_PATH || '../drivers/node-mongodb-native'",
      "string": "driver"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Module exports.</p>",
      "summary": "<p>Module exports.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "module.exports = require(driver + '/objectid');",
    "ctx": {
      "type": "property",
      "receiver": "module",
      "name": "exports",
      "value": "require(driver + '/objectid')",
      "string": "module.exports"
    }
  }
]
### lib/utils.js
[
  {
    "tags": [],
    "description": {
      "full": "<p>Module dependencies.</p>",
      "summary": "<p>Module dependencies.</p>",
      "body": ""
    },
    "ignore": true,
    "code": "var EventEmitter = require('events').EventEmitter\n  , ObjectId = require('./types/objectid')\n  , MongooseBuffer\n  , MongooseArray\n  , Document",
    "ctx": {
      "type": "declaration",
      "name": "EventEmitter",
      "value": "require('events').EventEmitter",
      "string": "EventEmitter"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "model",
        "description": "name"
      },
      {
        "type": "return",
        "types": [
          "String"
        ],
        "description": "collection name"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Produces a collection name from a model name</p>",
      "summary": "<p>Produces a collection name from a model name</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "exports.toCollectionName = function (name) {\n  if ('system.profile' === name) return name;\n  if ('system.indexes' === name) return name;\n  return pluralize(name.toLowerCase());\n};",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "toCollectionName",
      "string": "exports.toCollectionName()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Pluralization rules.</p>",
      "summary": "<p>Pluralization rules.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "var rules = [\n  [/(m)an$/gi, '$1en'],\n  [/(pe)rson$/gi, '$1ople'],\n  [/(child)$/gi, '$1ren'],\n  [/^(ox)$/gi, '$1en'],\n  [/(ax|test)is$/gi, '$1es'],\n  [/(octop|vir)us$/gi, '$1i'],\n  [/(alias|status)$/gi, '$1es'],\n  [/(bu)s$/gi, '$1ses'],\n  [/(buffal|tomat|potat)o$/gi, '$1oes'],\n  [/([ti])um$/gi, '$1a'],\n  [/sis$/gi, 'ses'],\n  [/(?:([^f])fe|([lr])f)$/gi, '$1$2ves'],\n  [/(hive)$/gi, '$1s'],\n  [/([^aeiouy]|qu)y$/gi, '$1ies'],\n  [/(x|ch|ss|sh)$/gi, '$1es'],\n  [/(matr|vert|ind)ix|ex$/gi, '$1ices'],\n  [/([m|l])ouse$/gi, '$1ice'],\n  [/(quiz)$/gi, '$1zes'],\n  [/s$/gi, 's'],\n  [/$/gi, 's']\n];",
    "ctx": {
      "type": "declaration",
      "name": "rules",
      "value": "[",
      "string": "rules"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Uncountable words.</p>",
      "summary": "<p>Uncountable words.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "var uncountables = [\n  'advice',\n  'energy',\n  'excretion',\n  'digestion',\n  'cooperation',\n  'health',\n  'justice',\n  'labour',\n  'machinery',\n  'equipment',\n  'information',\n  'pollution',\n  'sewage',\n  'paper',\n  'money',\n  'species',\n  'series',\n  'rain',\n  'rice',\n  'fish',\n  'sheep',\n  'moose',\n  'deer',\n  'news'\n];",
    "ctx": {
      "type": "declaration",
      "name": "uncountables",
      "value": "[",
      "string": "uncountables"
    }
  },
  {
    "tags": [
      {
        "type": "author",
        "string": "TJ Holowaychuk (extracted from _ext.js_)"
      },
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "string",
        "description": "to pluralize"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Pluralize function.</p>",
      "summary": "<p>Pluralize function.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "function pluralize (str) {\n  var rule, found;\n  if (!~uncountables.indexOf(str.toLowerCase())){\n    found = rules.filter(function(rule){\n      return str.match(rule[0]);\n    });\n    if (found[0]) return str.replace(found[0][0], found[0][1]);\n  }\n  return str;\n};",
    "ctx": {
      "type": "function",
      "name": "pluralize",
      "string": "pluralize()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "String"
        ],
        "name": "event",
        "description": "name"
      },
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "listener",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Add <code>once</code> to EventEmitter if absent</p>",
      "summary": "<p>Add <code>once</code> to EventEmitter if absent</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var Events = EventEmitter;\n\nif (!('once' in EventEmitter.prototype)){\n\n  Events = function () {\n    EventEmitter.apply(this, arguments);\n  };",
    "ctx": {
      "type": "declaration",
      "name": "Events",
      "value": "EventEmitter",
      "string": "Events"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Inherit from EventEmitter.</p>",
      "summary": "<p>Inherit from EventEmitter.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Events.prototype.__proto__ = EventEmitter.prototype;",
    "ctx": {
      "type": "property",
      "constructor": "Events",
      "name": "__proto__",
      "value": "EventEmitter.prototype",
      "string": "Events.prototype__proto__"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Add <code>once</code>.</p>",
      "summary": "<p>Add <code>once</code>.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "Events.prototype.once = function (type, listener) {\n    var self = this;\n    self.on(type, function g(){\n      self.removeListener(type, g);\n      listener.apply(this, arguments);\n    });\n  };\n\n}\n\nexports.EventEmitter = Events;\n\n// Modified from node/lib/assert.js\nexports.deepEqual = function deepEqual (a, b) {\n  if (a === b) return true;\n\n  if (a instanceof Date && b instanceof Date)\n    return a.getTime() === b.getTime();\n\n  if (a instanceof ObjectId && b instanceof ObjectId) {\n    return a.toString() === b.toString();\n  }\n\n  if (typeof a !== 'object' && typeof b !== 'object')\n    return a == b;\n\n  if (a === null || b === null || a === undefined || b === undefined)\n    return false\n\n  if (a.prototype !== b.prototype) return false;\n\n  // Handle MongooseNumbers\n  if (a instanceof Number && b instanceof Number) {\n    return a.valueOf() === b.valueOf();\n  }\n\n  if (Buffer.isBuffer(a)) {\n    if (!Buffer.isBuffer(b)) return false;\n    if (a.length !== b.length) return false;\n    for (var i = 0, len = a.length; i < len; ++i) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n\n  if (isMongooseObject(a)) a = a.toObject();\n  if (isMongooseObject(b)) b = b.toObject();\n\n  try {\n    var ka = Object.keys(a),\n        kb = Object.keys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key])) return false;\n  }\n\n  return true;\n};",
    "ctx": {
      "type": "method",
      "constructor": "Events",
      "name": "once",
      "string": "Events.prototype.once()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "object",
        "description": "to clone"
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": "- minimize , retainKeyOrder"
      },
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": "cloned object"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Object clone with Mongoose natives support.<br />Creates a minimal data Object.<br />It does not clone empty Arrays, empty Objects,<br />and undefined values.<br />This makes the data payload sent to MongoDB as minimal<br />as possible.</p>",
      "summary": "<p>Object clone with Mongoose natives support.<br />Creates a minimal data Object.<br />It does not clone empty Arrays, empty Objects,<br />and undefined values.<br />This makes the data payload sent to MongoDB as minimal<br />as possible.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "var clone = exports.clone = function clone (obj, options) {\n  if (obj === undefined || obj === null)\n    return obj;\n\n  if (Array.isArray(obj))\n    return cloneArray(obj, options);\n\n  if (isMongooseObject(obj)) {\n    if (options && options.json && 'function' === typeof obj.toJSON) {\n      return obj.toJSON(options);\n    } else {\n      return obj.toObject(options);\n    }\n  }\n\n  if ('Object' === obj.constructor.name)\n    return cloneObject(obj, options);\n\n  if ('Date' === obj.constructor.name || 'Function' === obj.constructor.name)\n    return new obj.constructor(+obj);\n\n  if ('RegExp' === obj.constructor.name)\n    return new RegExp(obj.source);\n\n  if (obj instanceof ObjectId) {\n    return new ObjectId(obj.id);\n  }\n\n  if (obj.valueOf)\n    return obj.valueOf();\n};\n\nfunction cloneObject (obj, options) {\n  var retainKeyOrder = options && options.retainKeyOrder\n    , minimize = options && options.minimize\n    , ret = {}\n    , hasKeys\n    , keys\n    , val\n    , k\n    , i\n\n  if (retainKeyOrder) {\n    for (k in obj) {\n      val = clone(obj[k], options);\n\n      if (!minimize || ('undefined' !== typeof val)) {\n        hasKeys || (hasKeys = true);\n        ret[k] = val;\n      }\n    }\n  } else {\n    // faster\n\n    keys = Object.keys(obj);\n    i = keys.length;\n\n    while (i--) {\n      k = keys[i];\n      val = clone(obj[k], options);\n\n      if (!minimize || ('undefined' !== typeof val)) {\n        if (!hasKeys) hasKeys = true;\n        ret[k] = val;\n      }\n    }\n  }\n\n  return minimize\n    ? hasKeys && ret\n    : ret;\n};\n\nfunction cloneArray (arr, options) {\n  var ret = [];\n  for (var i = 0, l = arr.length; i < l; i++)\n    ret.push(clone(arr[i], options));\n  return ret;\n};",
    "ctx": {
      "type": "declaration",
      "name": "clone",
      "value": "exports.clone = function clone (obj, options) {",
      "string": "clone"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "defaults",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "options",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "Object"
        ],
        "description": "(merged) object"
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Copies and merges options with defaults.</p>",
      "summary": "<p>Copies and merges options with defaults.</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "exports.options = function (defaults, options) {\n  var keys = Object.keys(defaults)\n    , i = keys.length\n    , k ;\n\n  options = options || {};\n\n  while (i--) {\n    k = keys[i];\n    if (!(k in options)) {\n      options[k] = defaults[k];\n    }\n  }\n\n  return options;\n};",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "options",
      "string": "exports.options()"
    }
  },
  {
    "tags": [
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>Generates a random string</p>",
      "summary": "<p>Generates a random string</p>",
      "body": ""
    },
    "isPrivate": true,
    "ignore": false,
    "code": "exports.random = function () {\n  return Math.random().toString().substr(3);\n};\n\nexports.inGroupsOf = function inGroupsOf (card, arr, fn) {\n  var group = [];\n  for (var i = 0, l = arr.length; i < l; i++) {\n    if (i && i % card === 0) {\n      fn.apply(this, group);\n      group.length = 0;\n    }\n    group.push(arr[i]);\n  }\n  fn.apply(this, group);\n};",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "random",
      "string": "exports.random()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "to",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "from",
        "description": ""
      }
    ],
    "description": {
      "full": "<p>Merges <code>from</code> into <code>to</code> without overwriting<br />existing properties of <code>to</code>.</p>",
      "summary": "<p>Merges <code>from</code> into <code>to</code> without overwriting<br />existing properties of <code>to</code>.</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "exports.merge = function merge (to, from) {\n  var keys = Object.keys(from)\n    , i = keys.length\n    , key\n\n  while (i--) {\n    key = keys[i];\n    if ('undefined' === typeof to[key]) {\n      to[key] = from[key];\n    } else {\n      merge(to[key], from[key]);\n    }\n  }\n};",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "merge",
      "string": "exports.merge()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>A faster Array.prototype.slice.call(arguments) alternative</p>",
      "summary": "<p>A faster Array.prototype.slice.call(arguments) alternative</p>",
      "body": ""
    },
    "ignore": false,
    "code": "exports.args = function (args, slice, sliceEnd) {\n  var ret = [];\n  var start = slice || 0;\n  var end = 3 === arguments.length\n    ? sliceEnd\n    : args.length;\n\n  for (var i = start; i < end; ++i) {\n    ret[i - start] = args[i];\n  }\n\n  return ret;\n}",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "args",
      "string": "exports.args()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "callback",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "private"
      }
    ],
    "description": {
      "full": "<p>process.nextTick helper.</p>\n\n<p>Wraps <code>callback</code> in a try/catch + nextTick.</p>\n\n<p>-native has a habit of state corruption<br /> when an error is immediately thrown from within<br /> a collection callback.</p>",
      "summary": "<p>process.nextTick helper.</p>",
      "body": "<p>Wraps <code>callback</code> in a try/catch + nextTick.</p>\n\n<p>-native has a habit of state corruption<br /> when an error is immediately thrown from within<br /> a collection callback.</p>"
    },
    "isPrivate": true,
    "ignore": false,
    "code": "exports.tick = function tick (callback) {\n  if ('function' !== typeof callback) return;\n  return function () {\n    try {\n      callback.apply(this, arguments);\n    } catch (err) {\n      // only nextTick on err to get out of\n      // the event loop and avoid state corruption.\n      process.nextTick(function () {\n        throw err;\n      });\n    }\n  }\n}",
    "ctx": {
      "type": "method",
      "receiver": "exports",
      "name": "tick",
      "string": "exports.tick()"
    }
  },
  {
    "tags": [],
    "description": {
      "full": "<p>Returns if <code>v</code> is a mongoose object that has<br />a <code>toObject()</code> method we can use. This is for<br />compatibility with libs like Date.js which do<br />foolish things to Natives.</p>",
      "summary": "<p>Returns if <code>v</code> is a mongoose object that has<br />a <code>toObject()</code> method we can use. This is for<br />compatibility with libs like Date.js which do<br />foolish things to Natives.</p>",
      "body": ""
    },
    "ignore": false,
    "code": "var isMongooseObject = exports.isMongooseObject = function (v) {\n  Document || (Document = require('./document'));\n  MongooseArray || (MongooseArray = require('./types').Array);\n  MongooseBuffer || (MongooseBuffer = require('./types').Buffer);\n\n  return v instanceof Document ||\n         v instanceof MongooseArray ||\n         v instanceof MongooseBuffer\n}",
    "ctx": {
      "type": "declaration",
      "name": "isMongooseObject",
      "value": "exports.isMongooseObject = function (v) {",
      "string": "isMongooseObject"
    }
  }
]
### lib/virtualtype.js
[
  {
    "tags": [
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>VirtualType constructor</p>\n\n<p>This is what mongoose uses to define virtual attributes via<br /><code>Schema.prototype.virtual</code></p>",
      "summary": "<p>VirtualType constructor</p>",
      "body": "<p>This is what mongoose uses to define virtual attributes via<br /><code>Schema.prototype.virtual</code></p>"
    },
    "isPrivate": false,
    "ignore": false,
    "code": "function VirtualType (options) {\n  this.getters = [];\n  this.setters = [];\n  this.options = options || {};\n}",
    "ctx": {
      "type": "function",
      "name": "VirtualType",
      "string": "VirtualType()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "VirtualType"
        ],
        "description": "this"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds a getter</p>",
      "summary": "<p>Adds a getter</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "VirtualType.prototype.get = function (fn) {\n  this.getters.push(fn);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "VirtualType",
      "name": "get",
      "string": "VirtualType.prototype.get()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Function"
        ],
        "name": "fn",
        "description": ""
      },
      {
        "type": "return",
        "types": [
          "VirtualType"
        ],
        "description": "this"
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Adds a setter</p>",
      "summary": "<p>Adds a setter</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "VirtualType.prototype.set = function (fn) {\n  this.setters.push(fn);\n  return this;\n};",
    "ctx": {
      "type": "method",
      "constructor": "VirtualType",
      "name": "set",
      "string": "VirtualType.prototype.set()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "scope",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Applies getters</p>",
      "summary": "<p>Applies getters</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "VirtualType.prototype.applyGetters = function (value, scope) {\n  var v = value;\n  for (var l = this.getters.length - 1; l >= 0; l--){\n    v = this.getters[l].call(scope, v);\n  }\n  return v;\n};",
    "ctx": {
      "type": "method",
      "constructor": "VirtualType",
      "name": "applyGetters",
      "string": "VirtualType.prototype.applyGetters()"
    }
  },
  {
    "tags": [
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "value",
        "description": ""
      },
      {
        "type": "param",
        "types": [
          "Object"
        ],
        "name": "scope",
        "description": ""
      },
      {
        "type": "api",
        "visibility": "public"
      }
    ],
    "description": {
      "full": "<p>Applies setters</p>",
      "summary": "<p>Applies setters</p>",
      "body": ""
    },
    "isPrivate": false,
    "ignore": false,
    "code": "VirtualType.prototype.applySetters = function (value, scope) {\n  var v = value;\n  for (var l = this.setters.length - 1; l >= 0; l--){\n    this.setters[l].call(scope, v);\n  }\n  return v;\n};\n\nmodule.exports = VirtualType;",
    "ctx": {
      "type": "method",
      "constructor": "VirtualType",
      "name": "applySetters",
      "string": "VirtualType.prototype.applySetters()"
    }
  }
]