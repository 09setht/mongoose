<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Mongoose API v3.0.0alpha2</title><link href="http://fonts.googleapis.com/css?family=Anonymous+Pro:400,700|Droid+Sans+Mono|Open+Sans:400,700|Linden+Hill|Quattrocento:400,700|News+Cycle:400,700|Antic+Slab|Cabin+Condensed:400,700" rel="stylesheet" type="text/css"><link href="/docs/css/default.css" rel="stylesheet" type="text/css"><style>body {
  background: #d8e2d8 url(/docs/images/square_bg.png); /* #D8E2D8 #B5F66E; /* #CEF6A4; */
  font-family: 'Open Sans', Helvetica, Arial, FreeSans;
  color: #333;
  -webkit-font-smoothing: antialiased;
  -webkit-text-size-adjust: 100%;
  padding: 0;
  margin: 0;
}
a {
  color: #800;
  -webkit-transition-property: opacity, -webkit-transform, color, background-color, padding, -webkit-box-shadow;
  -webkit-transition-duration: 0.15s;
  -webkit-transition-timing-function: ease-out;
}
a:hover {
  opacity: 0.8;
}
#wrap {
  width: 600px;
  margin: 0 auto;
  position:relative;
}
h1 {
  font-family: 'Helvetica Nueue', Helvetica, Arial, FreeSans, sans-serif;
  text-rendering: geometricPrecision;
}
pre {
  background: rgba(255,255,255,.8);
  border: 1px solid #bbb;
  padding:5px;
  border-radius: 3px;
  box-shadow: 1px 3px 6px #ddd;
}
code {
  background: rgba(255,255,255,.8);
  border: 1px solid #c6c6c6;
  color: #333;
  border-radius: 3px
}
pre code {
  border: 0 none;
  padding: 1.2em;
  font-size: 1.1em;
}
#header {
  text-align: center;
  position: relative;
  padding-top: 40px;
}
#header h1 {
  margin-top: 0;
  margin-bottom: 0;
}
#header h1 a {
  text-decoration: none;
}
#header .mongoose {
  font-size: 60px;
  font-weight: 100;
  text-indent: -23px;
  color: #fff;
  text-shadow: 18px 5px 6px #777, -6px 0px 2px #fff;
  letter-spacing: -7px;
}</style></head><body class="api"><a href="http://github.com/learnboost/mongoose"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"></a><div id="wrap"><div id="header"><h1><a href="https://github.com/learnboost/mongoose" target="blank"><div class="mongoose">Mongoose</div></a></h1></div><div id="links"><ul><li><a href="/docs/index.html">lib/collection.js</a><h3>Collection</h3><p>Collection constructor</p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Collection</span> <span class="params">(name, conn, opts)</span> {</span>
  <span class="keyword">this</span>.name = name;
  <span class="keyword">this</span>.conn = conn;
  <span class="keyword">this</span>.buffer = <span class="literal">true</span>;
  <span class="keyword">this</span>.queue = [];

  <span class="keyword">if</span> (<span class="string">'number'</span> == <span class="keyword">typeof</span> opts) opts = { size: opts };
  <span class="keyword">this</span>.opts = opts || {};

  <span class="keyword">if</span> (STATES.connected == <span class="keyword">this</span>.conn.readyState) {
    <span class="keyword">this</span>.onOpen();
  }
};</code></pre><p>The collection name</p><pre><code class="javascript">Collection.prototype.name;</code></pre><p>The Connection instance</p><pre><code class="javascript">Collection.prototype.conn;</code></pre></li><li><a href="/docs/index.html">lib/connection.js</a><h3>Connection</h3><p>Connection constructor. For practical reasons, a Connection equals a Db</p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Connection</span> <span class="params">(base)</span> {</span>
  <span class="keyword">this</span>.base = base;
  <span class="keyword">this</span>.collections = {};
  <span class="keyword">this</span>.models = {};
  <span class="keyword">this</span>.replica = <span class="literal">false</span>;
  <span class="keyword">this</span>.host = <span class="literal">null</span>;
  <span class="keyword">this</span>.port = <span class="literal">null</span>;
  <span class="keyword">this</span>.user = <span class="literal">null</span>;
  <span class="keyword">this</span>.pass = <span class="literal">null</span>;
  <span class="keyword">this</span>.name = <span class="literal">null</span>;
  <span class="keyword">this</span>.options = <span class="literal">null</span>;
  <span class="keyword">this</span>._readyState = STATES.disconnected;
};</code></pre><h3>__proto__</h3><p>Inherit from EventEmitter.</p><pre><code class="javascript">Connection.prototype.__proto__ = EventEmitter.prototype;</code></pre><h2>Connection ready state</h2>

<p>0 = Disconnected<br /> 1 = Connected<br /> 2 = Connecting<br /> 3 = Disconnecting</p>

<p>Each state change emits its associated event name.</p><pre><code class="javascript">Object.defineProperty(Connection.prototype, <span class="string">'readyState'</span>, {
    get: <span class="keyword">function</span>(){ <span class="keyword">return</span> <span class="keyword">this</span>._readyState; }
  , set: <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
      <span class="keyword">if</span> (!(val <span class="keyword">in</span> STATES)) {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Invalid connection state: '</span> + val);
      }

      <span class="keyword">this</span>._readyState = val;
      <span class="keyword">this</span>.emit(STATES[val]);
    }
});</code></pre><p>A hash of the collections associated with this connection</p><pre><code class="javascript">Connection.prototype.collections;</code></pre><p>The mongodb.Db instance, set when the connection is opened</p><pre><code class="javascript">Connection.prototype.db;</code></pre><h3>open</h3><p>Establishes the connection</p>

<p><code>options</code> is a hash with the following optional properties:</p>

<p>options.db      - passed to the connection db instance<br />  options.server  - passed to the connection server instance(s)<br />  options.replset - passed to the connection ReplSetServer instance<br />  options.user    - username for authentication<br />  options.pass    - password for authentication</p>

<p>Notes:</p>

<p>Mongoose forces the db option <code>forceServerObjectId</code> false and cannot<br />  be overridden.</p>

<p>Mongoose defaults the server <code>auto_reconnect</code> options to true which<br />  can be overridden.</p>

<p>See the node-mongodb-native driver instance for options that it<br />  understands.</p><pre><code class="javascript">Connection.prototype.open = <span class="function"><span class="keyword">function</span> <span class="params">(host, database, port, options, callback)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>
    , uri;

  <span class="keyword">if</span> (<span class="string">'string'</span> === <span class="keyword">typeof</span> database) {
    <span class="keyword">switch</span> (arguments.length) {
      <span class="keyword">case</span> <span class="number">2</span>:
        port = <span class="number">27017</span>;
      <span class="keyword">case</span> <span class="number">3</span>:
        <span class="keyword">switch</span> (<span class="keyword">typeof</span> port) {
          <span class="keyword">case</span> <span class="string">'function'</span>:
            callback = port, port = <span class="number">27017</span>;
            <span class="keyword">break</span>;
          <span class="keyword">case</span> <span class="string">'object'</span>:
            options = port, port = <span class="number">27017</span>;
            <span class="keyword">break</span>;
        }
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="number">4</span>:
        <span class="keyword">if</span> (<span class="string">'function'</span> === <span class="keyword">typeof</span> options)
          callback = options, options = {};
    }
  } <span class="keyword">else</span> {
    <span class="keyword">switch</span> (<span class="keyword">typeof</span> database) {
      <span class="keyword">case</span> <span class="string">'function'</span>:
        callback = database, database = <span class="literal">undefined</span>;
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'object'</span>:
        options = database;
        database = <span class="literal">undefined</span>;
        callback = port;
        <span class="keyword">break</span>;
    }

    <span class="keyword">if</span> (!rgxProtocol.test(host)) {
      host = <span class="string">'mongodb://'</span> + host;
    }

    uri = url.parse(host);
    host = uri.hostname;
    port = uri.port || <span class="number">27017</span>;
    database = uri.pathname &amp;&amp; uri.pathname.replace(<span class="regexp">/\//g</span>, <span class="string">''</span>);
  }

  <span class="keyword">this</span>.options = <span class="keyword">this</span>.defaultOptions(options);

  <span class="comment">// make sure we can open</span>
  <span class="keyword">if</span> (STATES.disconnected !== <span class="keyword">this</span>.readyState) {
    <span class="keyword">var</span> err = <span class="keyword">new</span> Error(<span class="string">'Trying to open unclosed connection.'</span>);
    err.state = <span class="keyword">this</span>.readyState;
    <span class="keyword">this</span>.error(err, callback);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="keyword">if</span> (!host) {
    <span class="keyword">this</span>.error(<span class="keyword">new</span> Error(<span class="string">'Missing connection hostname.'</span>), callback);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="keyword">if</span> (!database) {
    <span class="keyword">this</span>.error(<span class="keyword">new</span> Error(<span class="string">'Missing connection database.'</span>), callback);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="comment">// handle authentication</span>
  <span class="keyword">if</span> (uri &amp;&amp; uri.auth) {
    <span class="keyword">var</span> auth = uri.auth.split(<span class="string">':'</span>);
    <span class="keyword">this</span>.user = auth[<span class="number">0</span>];
    <span class="keyword">this</span>.pass = auth[<span class="number">1</span>];

  <span class="comment">// Check hostname for user/pass</span>
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/@/</span>.test(host) &amp;&amp; <span class="regexp">/:/</span>.test(host.split(<span class="string">'@'</span>)[<span class="number">0</span>])) {
    host = host.split(<span class="string">'@'</span>);
    <span class="keyword">var</span> auth = host.shift().split(<span class="string">':'</span>);
    host = host.pop();
    <span class="keyword">this</span>.user = auth[<span class="number">0</span>];
    <span class="keyword">this</span>.pass = auth[<span class="number">1</span>];

  <span class="comment">// user/pass options</span>
  } <span class="keyword">else</span> <span class="keyword">if</span> (options &amp;&amp; options.user &amp;&amp; options.pass) {
    <span class="keyword">this</span>.user = options.user;
    <span class="keyword">this</span>.pass = options.pass;

  } <span class="keyword">else</span> {
    <span class="keyword">this</span>.user = <span class="keyword">this</span>.pass = <span class="literal">undefined</span>;
  }

  <span class="keyword">this</span>.name = database;
  <span class="keyword">this</span>.host = host;
  <span class="keyword">this</span>.port = port;

  <span class="keyword">this</span>._open(callback);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>openSet</h3><p>Connects to a replica set.</p>

<p>Supply a comma-separted list of mongodb:// URIs. You only need to specify<br />the database name and/or auth to one of them.</p>

<p>The options parameter is passed to the low level connection. See the<br />node-mongodb-native driver instance for detail.</p><pre><code class="javascript">Connection.prototype.openSet = <span class="function"><span class="keyword">function</span> <span class="params">(uris, database, options, callback)</span> {</span>
  <span class="keyword">var</span> uris = uris.split(<span class="string">','</span>)
    , self = <span class="keyword">this</span>;

  <span class="keyword">switch</span> (arguments.length) {
    <span class="keyword">case</span> <span class="number">3</span>:
      <span class="keyword">this</span>.name = database;
      <span class="keyword">if</span> (<span class="string">'function'</span> === <span class="keyword">typeof</span> options) callback = options, options = {};
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="number">2</span>:
      <span class="keyword">switch</span> (<span class="keyword">typeof</span> database) {
        <span class="keyword">case</span> <span class="string">'string'</span>:
          <span class="keyword">this</span>.name = database;
        <span class="keyword">case</span> <span class="string">'function'</span>:
          callback = database, database = <span class="literal">null</span>;
          <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">'object'</span>:
          options = database, database = <span class="literal">null</span>;
          <span class="keyword">break</span>;
      }
  }

  <span class="keyword">this</span>.options = options = <span class="keyword">this</span>.defaultOptions(options);

  <span class="keyword">if</span> (uris.length &lt; <span class="number">2</span>) {
    <span class="keyword">this</span>.error(<span class="keyword">new</span> Error(<span class="string">'Please provide comma-separated URIs'</span>), callback);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="keyword">this</span>.replica = <span class="literal">true</span>;
  <span class="keyword">this</span>.host = [];
  <span class="keyword">this</span>.port = [];

  uris.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(uri)</span> {</span>
    <span class="comment">// handle missing protocols</span>
    <span class="keyword">if</span> (!rgxProtocol.test(uri))
      uri = <span class="string">'mongodb://'</span> + uri;

    <span class="keyword">var</span> uri = url.parse(uri);

    self.host.push(uri.hostname);
    self.port.push(uri.port || <span class="number">27017</span>);

    <span class="keyword">if</span> (!self.name &amp;&amp; uri.pathname &amp;&amp; uri.pathname.replace(<span class="regexp">/\//g</span>, <span class="string">''</span>))
      self.name = uri.pathname.replace(<span class="regexp">/\//g</span>, <span class="string">''</span>);

    <span class="keyword">if</span> (!self.user &amp;&amp; uri.auth) {
      <span class="keyword">var</span> auth = uri.auth.split(<span class="string">':'</span>);
      self.user = auth[<span class="number">0</span>];
      self.pass = auth[<span class="number">1</span>];
    }
  });

  <span class="keyword">if</span> (!<span class="keyword">this</span>.name) {
    <span class="keyword">this</span>.error(<span class="keyword">new</span> Error(<span class="string">'No database name provided for replica set'</span>), callback);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="keyword">this</span>._open(callback);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>close</h3><p>Closes the connection</p><pre><code class="javascript">Connection.prototype.close = <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;

  <span class="keyword">switch</span> (<span class="keyword">this</span>.readyState){
    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// disconnected</span>
      callback &amp;&amp; callback();
      <span class="keyword">break</span>;

    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// connected</span>
      <span class="keyword">this</span>.readyState = STATES.disconnecting;
      <span class="keyword">this</span>.doClose(<span class="keyword">function</span>(err){
        <span class="keyword">if</span> (err){
          self.error(err, callback);
        } <span class="keyword">else</span> {
          self.onClose();
          callback &amp;&amp; callback();
        }
      });
      <span class="keyword">break</span>;

    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// connecting</span>
      <span class="keyword">this</span>.once(<span class="string">'open'</span>, <span class="keyword">function</span>(){
        self.close(callback);
      });
      <span class="keyword">break</span>;

    <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// disconnecting</span>
      <span class="keyword">if</span> (!callback) <span class="keyword">break</span>;
      <span class="keyword">this</span>.once(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        callback();
      });
      <span class="keyword">break</span>;
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>collection</h3><p>Retrieves a collection, creating it if not cached.</p><pre><code class="javascript">Connection.prototype.collection = <span class="function"><span class="keyword">function</span> <span class="params">(name, options)</span> {</span>
  <span class="keyword">if</span> (!(name <span class="keyword">in</span> <span class="keyword">this</span>.collections))
    <span class="keyword">this</span>.collections[name] = <span class="keyword">new</span> Collection(name, <span class="keyword">this</span>, options);
  <span class="keyword">return</span> <span class="keyword">this</span>.collections[name];
};</code></pre><h3>model</h3><p>Defines a model or retrieves it</p><pre><code class="javascript">Connection.prototype.model = <span class="function"><span class="keyword">function</span> <span class="params">(name, schema, collection)</span> {</span>
  <span class="keyword">if</span> (!<span class="keyword">this</span>.models[name]) {
    <span class="keyword">var</span> model = <span class="keyword">this</span>.base.model(name, schema, collection, <span class="literal">true</span>)
      , Model

    <span class="keyword">if</span> (<span class="keyword">this</span> != model.prototype.db) {
      <span class="comment">// subclass model using this connection and collection name</span>
      Model = <span class="function"><span class="keyword">function</span> <span class="title">Model</span> <span class="params">(doc, fields, skipId)</span> {</span>
        <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Model))
          <span class="keyword">return</span> <span class="keyword">new</span> Model(doc, fields, skipId);
        model.call(<span class="keyword">this</span>, doc, fields, skipId);
      };

      Model.__proto__ = model;
      Model.prototype.__proto__ = model.prototype;
      Model.db = Model.prototype.db = <span class="keyword">this</span>;

      <span class="comment">// collection name discovery</span>
      <span class="keyword">if</span> (<span class="string">'string'</span> === <span class="keyword">typeof</span> schema) {
        collection = schema;
      }

      <span class="keyword">if</span> (!collection) {
        collection = model.prototype.schema.set(<span class="string">'collection'</span>) || utils.toCollectionName(name);
      }

      <span class="keyword">var</span> s = <span class="string">'string'</span> != <span class="keyword">typeof</span> schema
        ? schema
        : model.prototype.schema;

      Model.prototype.collection = <span class="keyword">this</span>.collection(collection, s &amp;&amp; s.options.capped);
      Model.collection = Model.prototype.collection;
      Model.init();
    }

    <span class="keyword">this</span>.models[name] = Model || model;
  }

  <span class="keyword">return</span> <span class="keyword">this</span>.models[name];
};</code></pre><h3>setProfiling</h3><p>Set profiling level.</p><pre><code class="javascript">Connection.prototype.setProfiling = <span class="function"><span class="keyword">function</span> <span class="params">(level, ms, callback)</span> {</span>
  <span class="keyword">if</span> (STATES.connected !== <span class="keyword">this</span>.readyState) {
    <span class="keyword">return</span> <span class="keyword">this</span>.on(<span class="string">'open'</span>, <span class="keyword">this</span>.setProfiling.bind(<span class="keyword">this</span>, level, ms, callback));
  }

  <span class="keyword">if</span> (!callback) callback = ms, ms = <span class="number">100</span>;

  <span class="keyword">var</span> cmd = {};

  <span class="keyword">switch</span> (level) {
    <span class="keyword">case</span> <span class="number">0</span>:
    <span class="keyword">case</span> <span class="string">'off'</span>:
      cmd.profile = <span class="number">0</span>;
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="number">1</span>:
    <span class="keyword">case</span> <span class="string">'slow'</span>:
      cmd.profile = <span class="number">1</span>;
      <span class="keyword">if</span> (<span class="string">'number'</span> !== <span class="keyword">typeof</span> ms) {
        ms = parseInt(ms, <span class="number">10</span>);
        <span class="keyword">if</span> (isNaN(ms)) ms = <span class="number">100</span>;
      }
      cmd.slowms = ms;
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="number">2</span>:
    <span class="keyword">case</span> <span class="string">'all'</span>:
      cmd.profile = <span class="number">2</span>;
      <span class="keyword">break</span>;
    <span class="keyword">default</span>:
      <span class="keyword">return</span> callback(<span class="keyword">new</span> Error(<span class="string">'Invalid profiling level: '</span>+ level));
  }

  <span class="keyword">this</span>.db.executeDbCommand(cmd, <span class="function"><span class="keyword">function</span> <span class="params">(err, resp)</span> {</span>
    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);

    <span class="keyword">var</span> doc = resp.documents[<span class="number">0</span>];

    err = <span class="number">1</span> === doc.ok
      ? <span class="literal">null</span>
      : <span class="keyword">new</span> Error(<span class="string">'Could not set profiling level to: '</span>+ level)

    callback(err, doc);
  });
};</code></pre><h3>STATES</h3><p>Module exports.</p><pre><code class="javascript">Connection.STATES = STATES;
module.exports = Connection;</code></pre></li><li><a href="/docs/index.html">lib/connectionstate.js</a></li><li><a href="/docs/index.html">lib/document.js</a><h3>__proto__</h3><p>Inherit from EventEmitter.</p><pre><code class="javascript">Document.prototype.__proto__ = EventEmitter.prototype;</code></pre><p>Document schema as a nested structure.</p><pre><code class="javascript">Document.prototype.schema;</code></pre><p>Whether the document is new.</p><pre><code class="javascript">Document.prototype.isNew;</code></pre><p>Validation errors.</p><pre><code class="javascript">Document.prototype.errors;</code></pre><h3>init</h3><p>Init helper.</p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">init</span> <span class="params">(self, obj, doc, prefix)</span> {</span>
  prefix = prefix || <span class="string">''</span>;

  <span class="keyword">var</span> keys = Object.keys(obj)
    , len = keys.length
    , schema
    , path
    , i;

  <span class="keyword">while</span> (len--) {
    i = keys[len];
    path = prefix + i;
    schema = self.schema.path(path);

    <span class="keyword">if</span> (!schema &amp;&amp; obj[i] &amp;&amp; <span class="string">'Object'</span> === obj[i].constructor.name) {
      <span class="comment">// assume nested object</span>
      <span class="keyword">if</span> (!doc[i]) {
        doc[i] = {};
      }
      init(self, obj[i], doc[i], path + <span class="string">'.'</span>);
    } <span class="keyword">else</span> {
      <span class="keyword">if</span> (obj[i] === <span class="literal">null</span>) {
        doc[i] = <span class="literal">null</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (obj[i] !== <span class="literal">undefined</span>) {
        <span class="keyword">if</span> (schema) {
          self.<span class="keyword">try</span>(<span class="keyword">function</span>(){
            doc[i] = schema.cast(obj[i], self, <span class="literal">true</span>);
          });
        } <span class="keyword">else</span> {
          doc[i] = obj[i];
        }
      }
      <span class="comment">// mark as hydrated</span>
      self._activePaths.init(path);
    }
  }
};</code></pre><h3>_storeShard</h3><p>_storeShard</p>

<p>Stores the current values of the shard keys<br />for use later in the doc.save() where clause.</p>

<p>Shard key values do not / are not allowed to change.</p><pre><code class="javascript">Document.prototype._storeShard = <span class="function"><span class="keyword">function</span> <span class="title">_storeShard</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> key = <span class="keyword">this</span>.schema.options.shardkey;
  <span class="keyword">if</span> (!(key &amp;&amp; <span class="string">'Object'</span> == key.constructor.name)) <span class="keyword">return</span>;

  <span class="keyword">var</span> orig = <span class="keyword">this</span>._shardval = {}
    , paths = Object.keys(key)
    , len = paths.length
    , val

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; ++i) {
    val = <span class="keyword">this</span>.getValue(paths[i]);
    <span class="keyword">if</span> (isMongooseObject(val)) {
      orig[paths[i]] = val.toObject({ depopulate: <span class="literal">true</span> })
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">null</span> != val &amp;&amp; val.valueOf) {
      orig[paths[i]] = val.valueOf();
    } <span class="keyword">else</span> {
      orig[paths[i]] = val;
    }
  }
}</code></pre><h3>update</h3><p>update</p>

<p>Sends an update command with this document _id as<br />the query selector.</p>

<h2>Example</h2>

<pre><code>weirdCar.update({$inc: {wheels:1}, fn);
</code></pre>

<h2>Valid options</h2>

<ul>
<li>safe (boolean) safe mode (defaults to value set in schema (true))</li>
<li>upsert (boolean) whether to create the doc if it doesn't match (false)</li>
</ul><pre><code class="javascript">Document.prototype.update = <span class="function"><span class="keyword">function</span> <span class="title">update</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> args = utils.args(arguments);
  args.unshift({_id: <span class="keyword">this</span>._id});
  <span class="keyword">this</span>.constructor.update.apply(<span class="keyword">this</span>.constructor, args);
}</code></pre><h3>set</h3><p>set</p>

<p>Sets the value of a path, or many paths.</p>

<h2>Examples</h2>

<pre><code>// path, value
doc.set(path, value)

// object
doc.set({
    path  : value
  , path2 : {
       path  : value
    }
})

// only-the-fly cast to number
doc.set(path, value, Number)

// only-the-fly cast to string
doc.set(path, value, String)
</code></pre><pre><code class="javascript">Document.prototype.set = <span class="function"><span class="keyword">function</span> <span class="params">(path, val, type)</span> {</span>
  <span class="keyword">var</span> constructing = <span class="literal">true</span> === type
    , adhoc = type &amp;&amp; <span class="literal">true</span> !== type
    , adhocs

  <span class="keyword">if</span> (adhoc) {
    adhocs = <span class="keyword">this</span>._adhocPaths || (<span class="keyword">this</span>._adhocPaths = {});
    adhocs[path] = Schema.interpretAsType(path, type);
  }

  <span class="keyword">if</span> (<span class="string">'string'</span> !== <span class="keyword">typeof</span> path) {
    <span class="comment">// new Document({ key: val })</span>

    <span class="keyword">if</span> (<span class="literal">null</span> === path || <span class="literal">undefined</span> === path) {
      <span class="keyword">var</span> _ = path;
      path = val;
      val = _;

    } <span class="keyword">else</span> {
      <span class="keyword">var</span> prefix = val
        ? val + <span class="string">'.'</span>
        : <span class="string">''</span>;

      <span class="keyword">if</span> (path <span class="keyword">instanceof</span> Document) path = path._doc;

      <span class="keyword">var</span> keys = Object.keys(path)
        , i = keys.length
        , pathtype
        , key

      <span class="keyword">while</span> (i--) {
        key = keys[i];
        <span class="keyword">if</span> (<span class="literal">null</span> != path[key] &amp;&amp; <span class="string">'Object'</span> === path[key].constructor.name
          &amp;&amp; !(<span class="keyword">this</span>._path(prefix + key) <span class="keyword">instanceof</span> MixedSchema)) {
          <span class="keyword">this</span>.set(path[key], prefix + key, constructing);
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._strictMode) {
          pathtype = <span class="keyword">this</span>.schema.pathType(prefix + key);
          <span class="keyword">if</span> (<span class="string">'real'</span> === pathtype || <span class="string">'virtual'</span> === pathtype) {
            <span class="keyword">this</span>.set(prefix + key, path[key], constructing);
          } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'throw'</span> == <span class="keyword">this</span>._strictMode) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Field `"</span> + key + <span class="string">"` is not in schema."</span>);
          }
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">undefined</span> !== path[key]) {
          <span class="keyword">this</span>.set(prefix + key, path[key], constructing);
        }
      }

      <span class="keyword">return</span> <span class="keyword">this</span>;
    }
  }

  <span class="comment">// ensure _strict is honored for obj props</span>
  <span class="comment">// docschema = new Schema({ path: { nest: 'string' }})</span>
  <span class="comment">// doc.set('path', obj);</span>
  <span class="keyword">var</span> pathType = <span class="keyword">this</span>.schema.pathType(path);
  <span class="keyword">if</span> (<span class="string">'nested'</span> == pathType &amp;&amp; val &amp;&amp; <span class="string">'Object'</span> == val.constructor.name) {
    <span class="keyword">this</span>.set(val, path, constructing);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="keyword">var</span> schema;
  <span class="keyword">if</span> (<span class="string">'adhocOrUndefined'</span> == pathType &amp;&amp; <span class="keyword">this</span>._strictMode) {
    <span class="keyword">return</span> <span class="keyword">this</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'virtual'</span> == pathType) {
    schema = <span class="keyword">this</span>.schema.virtualpath(path);
    schema.applySetters(val, <span class="keyword">this</span>);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  } <span class="keyword">else</span> {
    schema = <span class="keyword">this</span>._path(path);
  }

  <span class="keyword">var</span> parts = path.split(<span class="string">'.'</span>)
    , pathToMark

  <span class="comment">// When using the $set operator the path to the field must already exist.</span>
  <span class="comment">// Else mongodb throws: "LEFT_SUBFIELD only supports Object"</span>

  <span class="keyword">if</span> (parts.length &lt;= <span class="number">1</span>) {
    pathToMark = path;
  } <span class="keyword">else</span> {
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; parts.length; ++i) {
      <span class="keyword">var</span> part = parts[i];
      <span class="keyword">var</span> subpath = parts.slice(<span class="number">0</span>, i).concat(part).join(<span class="string">'.'</span>);
      <span class="keyword">if</span> (<span class="keyword">this</span>.isDirectModified(subpath) <span class="comment">// earlier prefixes that are already</span>
                                         <span class="comment">// marked as dirty have precedence</span>
          || <span class="keyword">this</span>.get(subpath) === <span class="literal">null</span>) {
        pathToMark = subpath;
        <span class="keyword">break</span>;
      }
    }

    <span class="keyword">if</span> (!pathToMark) pathToMark = path;
  }

  <span class="keyword">if</span> (!schema || <span class="literal">null</span> === val || <span class="literal">undefined</span> === val) {
    <span class="keyword">this</span>._set(pathToMark, path, constructing, parts, schema, val);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="keyword">var</span> self = <span class="keyword">this</span>;

  <span class="comment">// if this doc is being constructed we should not</span>
  <span class="comment">// trigger getters.</span>
  <span class="keyword">var</span> priorVal = constructing
    ? <span class="literal">undefined</span>
    : <span class="keyword">this</span>.get(path);

  <span class="keyword">var</span> shouldSet = <span class="keyword">this</span>.<span class="keyword">try</span>(<span class="keyword">function</span>(){
    <span class="keyword">var</span> casted = schema.cast(val, self, <span class="literal">false</span>, priorVal);
    val = schema.applySetters(casted, self);
  });

  <span class="keyword">if</span> (shouldSet) {
    <span class="keyword">this</span>._set(pathToMark, path, constructing, parts, schema, val, priorVal);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
}</code></pre><h3>_set</h3><p>_set</p>

<p>Handles the actual setting of the value and marking<br />the path modified if appropriate.</p><pre><code class="javascript">Document.prototype._set = <span class="function"><span class="keyword">function</span> <span class="params">(pathToMark, path, constructing, parts, schema, val, priorVal)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.isNew) {
    <span class="keyword">this</span>.markModified(pathToMark);
  } <span class="keyword">else</span> {

    priorVal || (priorVal = <span class="keyword">this</span>.get(path));

    <span class="keyword">if</span> (!<span class="keyword">this</span>.isDirectModified(pathToMark)) {
      <span class="keyword">if</span> (<span class="literal">undefined</span> === val &amp;&amp; !<span class="keyword">this</span>.isSelected(path)) {
        <span class="comment">// special case:</span>
        <span class="comment">// when a path is not selected in a query its initial</span>
        <span class="comment">// value will be undefined.</span>
        <span class="keyword">this</span>.markModified(pathToMark, priorVal);
      } <span class="keyword">else</span> <span class="keyword">if</span> (!deepEqual(val, priorVal)) {
        <span class="keyword">this</span>.markModified(pathToMark, priorVal);
      } <span class="keyword">else</span> <span class="keyword">if</span> (!constructing &amp;&amp;
                 <span class="literal">null</span> != val &amp;&amp;
                 path <span class="keyword">in</span> <span class="keyword">this</span>._activePaths.states.<span class="keyword">default</span> &amp;&amp;
                 deepEqual(val, schema.getDefault(<span class="keyword">this</span>, constructing))) {
        <span class="comment">// special case:</span>
        <span class="comment">// a path with a default was $unset on the server</span>
        <span class="comment">// and the user is setting it to the same value again</span>
        <span class="keyword">this</span>.markModified(pathToMark, priorVal);
      }
    }
  }

  <span class="keyword">var</span> obj = <span class="keyword">this</span>._doc
    , i = <span class="number">0</span>
    , l = parts.length

  <span class="keyword">for</span> (; i &lt; l; i++) {
    <span class="keyword">var</span> next = i + <span class="number">1</span>
      , last = next === l;

    <span class="keyword">if</span> (last) {
      obj[parts[i]] = val;
    } <span class="keyword">else</span> {
      <span class="keyword">if</span> (obj[parts[i]] &amp;&amp; <span class="string">'Object'</span> === obj[parts[i]].constructor.name) {
        obj = obj[parts[i]];
      } <span class="keyword">else</span> <span class="keyword">if</span> (obj[parts[i]] &amp;&amp; Array.isArray(obj[parts[i]])) {
        obj = obj[parts[i]];
      } <span class="keyword">else</span> {
        obj = obj[parts[i]] = {};
      }
    }
  }
};</code></pre><h3>get</h3><p>get</p>

<p>Returns the value of a path.</p>

<h2>Example</h2>

<pre><code>// path
doc.get('age') // 47

// dynamic casting to a string
doc.get('age', String) // "47"
</code></pre><pre><code class="javascript">Document.prototype.get = <span class="function"><span class="keyword">function</span> <span class="params">(path, type)</span> {</span>
  <span class="keyword">var</span> adhocs;
  <span class="keyword">if</span> (type) {
    adhocs = <span class="keyword">this</span>._adhocPaths || (<span class="keyword">this</span>._adhocPaths = {});
    adhocs[path] = Schema.interpretAsType(path, type);
  }

  <span class="keyword">var</span> schema = <span class="keyword">this</span>._path(path) || <span class="keyword">this</span>.schema.virtualpath(path)
    , pieces = path.split(<span class="string">'.'</span>)
    , obj = <span class="keyword">this</span>._doc;

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = pieces.length; i &lt; l; i++) {
    obj = <span class="literal">null</span> == obj ? <span class="literal">null</span> : obj[pieces[i]];
  }

  <span class="keyword">if</span> (schema) {
    obj = schema.applyGetters(obj, <span class="keyword">this</span>);
  }

  <span class="keyword">return</span> obj;
};</code></pre><h3>markModified</h3><p>markModified</p>

<p>Marks that the path has pending changes to be written<br />to the db. Very helpful when using Mixed types.</p>

<pre><code>doc.markModified('mixed.type');
</code></pre><pre><code class="javascript">Document.prototype.markModified = <span class="function"><span class="keyword">function</span> <span class="params">(path)</span> {</span>
  <span class="keyword">this</span>._activePaths.modify(path);
};</code></pre><h3>try</h3><p>try</p>

<p>Catches errors that occur during execution of fn and<br />stores them to later be passed when save() is executed.</p><pre><code class="javascript">Document.prototype.<span class="keyword">try</span> = <span class="function"><span class="keyword">function</span> <span class="params">(fn, scope)</span> {</span>
  <span class="keyword">var</span> res;
  <span class="keyword">try</span> {
    fn.call(scope);
    res = <span class="literal">true</span>;
  } <span class="keyword">catch</span> (e) {
    <span class="keyword">this</span>._error(e);
    res = <span class="literal">false</span>;
  }
  <span class="keyword">return</span> res;
};</code></pre><h3>modifiedPaths</h3><p>modifiedPaths</p>

<p>Returns the list of paths that have been modified.</p>

<p>If we set <code>documents.0.title</code> to 'newTitle'<br />then <code>documents</code>, <code>documents.0</code>, and <code>documents.0.title</code><br />are modified.</p><pre><code class="javascript">Document.prototype.modifiedPaths = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> directModifiedPaths = Object.keys(<span class="keyword">this</span>._activePaths.states.modify);

  <span class="keyword">return</span> directModifiedPaths.reduce(<span class="function"><span class="keyword">function</span> <span class="params">(list, path)</span> {</span>
    <span class="keyword">var</span> parts = path.split(<span class="string">'.'</span>);
    <span class="keyword">return</span> list.concat(parts.reduce(<span class="function"><span class="keyword">function</span> <span class="params">(chains, part, i)</span> {</span>
      <span class="keyword">return</span> chains.concat(parts.slice(<span class="number">0</span>, i).concat(part).join(<span class="string">'.'</span>));
    }, []));
  }, []);
};</code></pre><h3>isModified</h3><p>isModified</p>

<p>If no path is given, returns is this document was modified.</p>

<p>If a path is given, checks if a path or any full path<br />containing path as part of its path chain has been<br />directly modified.</p>

<p>e.g., if we set <code>documents.0.title</code> to 'newTitle'<br />      then we have directly modified <code>documents.0.title</code><br />      but not directly modified <code>documents</code> or <code>documents.0</code>.<br />      Nonetheless, we still say <code>documents</code> and <code>documents.0</code><br />      are modified. They just are not considered direct modified.<br />      The distinction is important because we need to distinguish<br />      between what has been directly modified and what hasn't so<br />      that we can determine the MINIMUM set of dirty data<br />      that we want to send to MongoDB on a Document save.</p><pre><code class="javascript">Document.prototype.isModified = <span class="function"><span class="keyword">function</span> <span class="params">(path)</span> {</span>
  <span class="keyword">return</span> path
    ? !!~<span class="keyword">this</span>.modifiedPaths().indexOf(path)
    : <span class="keyword">this</span>._activePaths.some(<span class="string">'modify'</span>);
  <span class="comment">// TODO remove use of some()</span>
};</code></pre><h3>isDirectModified</h3><p>isDirectModified</p>

<p>Checks if a path has been directly set and modified. False if<br />the path is only part of a larger path that was directly set.</p>

<p>e.g., if we set <code>documents.0.title</code> to 'newTitle'<br />      then we have directly modified <code>documents.0.title</code><br />      but not directly modified <code>documents</code> or <code>documents.0</code>.<br />      Nonetheless, we still say <code>documents</code> and <code>documents.0</code><br />      are modified. They just are not considered direct modified.<br />      The distinction is important because we need to distinguish<br />      between what has been directly modified and what hasn't so<br />      that we can determine the MINIMUM set of dirty data<br />      that we want to send to MongoDB on a Document save.</p><pre><code class="javascript">Document.prototype.isDirectModified = <span class="function"><span class="keyword">function</span> <span class="params">(path)</span> {</span>
  <span class="keyword">return</span> (path <span class="keyword">in</span> <span class="keyword">this</span>._activePaths.states.modify);
};</code></pre><h3>isInit</h3><p>isInit</p>

<p>Checks if a certain path was initialized</p><pre><code class="javascript">Document.prototype.isInit = <span class="function"><span class="keyword">function</span> <span class="params">(path)</span> {</span>
  <span class="keyword">return</span> (path <span class="keyword">in</span> <span class="keyword">this</span>._activePaths.states.init);
};</code></pre><h3>isSelected</h3><p>isSelected</p>

<p>Checks if a path was selected in the source query which<br />initialize this document.</p>

<pre><code>Thing.findOne().select('name').exec(function (err, doc) {
   doc.isSelected('age') // false
   doc.isSelected('name') //true
</code></pre><pre><code class="javascript">Document.prototype.isSelected = <span class="function"><span class="keyword">function</span> <span class="title">isSelected</span> <span class="params">(path)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>._selected) {

    <span class="keyword">if</span> (<span class="string">'_id'</span> === path) {
      <span class="keyword">return</span> <span class="number">0</span> !== <span class="keyword">this</span>._selected._id;
    }

    <span class="keyword">var</span> paths = Object.keys(<span class="keyword">this</span>._selected)
      , i = paths.length
      , inclusive = <span class="literal">false</span>
      , cur

    <span class="keyword">if</span> (<span class="number">1</span> === i &amp;&amp; <span class="string">'_id'</span> === paths[<span class="number">0</span>]) {
      <span class="comment">// only _id was selected.</span>
      <span class="keyword">return</span> <span class="number">0</span> === <span class="keyword">this</span>._selected._id;
    }

    <span class="keyword">while</span> (i--) {
      cur = paths[i];
      <span class="keyword">if</span> (<span class="string">'_id'</span> == cur) <span class="keyword">continue</span>;
      inclusive = !! <span class="keyword">this</span>._selected[cur];
      <span class="keyword">break</span>;
    }

    <span class="keyword">if</span> (path <span class="keyword">in</span> <span class="keyword">this</span>._selected) {
      <span class="keyword">return</span> inclusive;
    }

    i = paths.length;
    <span class="keyword">var</span> pathDot = path + <span class="string">'.'</span>;

    <span class="keyword">while</span> (i--) {
      cur = paths[i];
      <span class="keyword">if</span> (<span class="string">'_id'</span> == cur) <span class="keyword">continue</span>;

      <span class="keyword">if</span> (<span class="number">0</span> === cur.indexOf(pathDot)) {
        <span class="keyword">return</span> inclusive;
      }

      <span class="keyword">if</span> (<span class="number">0</span> === pathDot.indexOf(cur)) {
        <span class="keyword">return</span> inclusive;
      }
    }

    <span class="keyword">return</span> ! inclusive;
  }

  <span class="keyword">return</span> <span class="literal">true</span>;
}</code></pre><h3>validate</h3><p>validate</p>

<p>Executes appropriate validation rules for this document.</p><pre><code class="javascript">Document.prototype.validate = <span class="function"><span class="keyword">function</span> <span class="params">(next)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>

  <span class="comment">// only validate required fields when necessary</span>
  <span class="keyword">var</span> paths = Object.keys(<span class="keyword">this</span>._activePaths.states.require).filter(<span class="function"><span class="keyword">function</span> <span class="params">(path)</span> {</span>
    <span class="keyword">if</span> (!self.isSelected(path) &amp;&amp; !self.isModified(path)) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">return</span> <span class="literal">true</span>;
  });

  paths = paths.concat(Object.keys(<span class="keyword">this</span>._activePaths.states.init));
  paths = paths.concat(Object.keys(<span class="keyword">this</span>._activePaths.states.modify));

  <span class="keyword">if</span> (<span class="number">0</span> === paths.length) {
    complete();
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="keyword">var</span> validating = {}
    , total = <span class="number">0</span>;

  paths.forEach(validatePath);
  <span class="keyword">return</span> <span class="keyword">this</span>;

  <span class="function"><span class="keyword">function</span> <span class="title">validatePath</span> <span class="params">(path)</span> {</span>
    <span class="keyword">if</span> (validating[path]) <span class="keyword">return</span>;

    validating[path] = <span class="literal">true</span>;
    total++;

    process.nextTick(<span class="keyword">function</span>(){
      <span class="keyword">var</span> p = self.schema.path(path);
      <span class="keyword">if</span> (!p) <span class="keyword">return</span> --total || complete();

      p.doValidate(self.getValue(path), <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
        <span class="keyword">if</span> (err) self.invalidate(path, err);
        --total || complete();
      }, self);
    });
  }

  <span class="function"><span class="keyword">function</span> <span class="title">complete</span> <span class="params">()</span> {</span>
    next(self._validationError);
    self._validationError = <span class="literal">null</span>;
  }

};</code></pre><h3>invalidate</h3><p>invalidate</p>

<p>Marks a path as invalid, causing validation to fail.</p><pre><code class="javascript">Document.prototype.invalidate = <span class="function"><span class="keyword">function</span> <span class="params">(path, err)</span> {</span>
  <span class="keyword">if</span> (!<span class="keyword">this</span>._validationError) {
    <span class="keyword">this</span>._validationError = <span class="keyword">new</span> ValidationError(<span class="keyword">this</span>);
  }

  <span class="keyword">if</span> (!err || <span class="string">'string'</span> === <span class="keyword">typeof</span> err) {
    err = <span class="keyword">new</span> ValidatorError(path, err);
  }

  <span class="keyword">this</span>._validationError.errors[path] = err;
}</code></pre><h3>_reset</h3><p>_reset</p>

<p>Resets the internal atomics and modified state of this document.</p><pre><code class="javascript">Document.prototype._reset = <span class="function"><span class="keyword">function</span> <span class="title">reset</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  DocumentArray || (DocumentArray = require(<span class="string">'./types/documentarray'</span>));

  <span class="keyword">this</span>._activePaths
  .map(<span class="string">'init'</span>, <span class="string">'modify'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(i)</span> {</span>
    <span class="keyword">return</span> self.getValue(i);
  })
  .filter(<span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
    <span class="keyword">return</span> (val &amp;&amp; val <span class="keyword">instanceof</span> DocumentArray &amp;&amp; val.length);
  })
  .forEach(<span class="function"><span class="keyword">function</span> <span class="params">(array)</span> {</span>
    array.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(doc)</span> {</span>
      doc._reset();
    });
  });

  <span class="comment">// clear atomics</span>
  <span class="keyword">this</span>._dirty().forEach(<span class="function"><span class="keyword">function</span> <span class="params">(dirt)</span> {</span>
    <span class="keyword">var</span> type = dirt.value;
    <span class="keyword">if</span> (type &amp;&amp; type._atomics) {
      type._atomics = {};
    }
  });

  <span class="comment">// Clear 'modify'('dirty') cache</span>
  <span class="keyword">this</span>._activePaths.clear(<span class="string">'modify'</span>);
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  <span class="keyword">this</span>.schema.requiredPaths().forEach(<span class="function"><span class="keyword">function</span> <span class="params">(path)</span> {</span>
    self._activePaths.require(path);
  });

  <span class="keyword">return</span> <span class="keyword">this</span>;
}</code></pre><h3>toObject</h3><p>toObject</p>

<p>Converts this document into a plain javascript object<br />representation.</p>

<h2>Available options</h2>

<ul>
<li>getters: apply all getters (path and virtual getters)</li>
<li>virtuals: apply virtual getters (can override <code>getters</code> option)</li>
<li>minimize: remove empty objects (defaults to true)</li>
</ul>

<h2>Example of only applying path getters</h2>

<pre><code>doc.toObject({ getters: true, virtuals: false })
</code></pre>

<h2>Example of only applying virtual getters</h2>

<pre><code>doc.toObject({ virtuals: true })
</code></pre>

<h2>Example of applying both path and virtual getters</h2>

<pre><code>doc.toObject({ getters: true })
</code></pre><pre><code class="javascript">Document.prototype.toObject = <span class="function"><span class="keyword">function</span> <span class="params">(options)</span> {</span>
  <span class="comment">// When internally saving this document we always pass options,</span>
  <span class="comment">// bypassing the custom schema options.</span>
  <span class="keyword">if</span> (!(options &amp;&amp; <span class="string">'Object'</span> == options.constructor.name)) {
    options = <span class="keyword">this</span>.schema.options.toObject
      ? clone(<span class="keyword">this</span>.schema.options.toObject)
      : {};
  }

  ;(<span class="string">'minimize'</span> <span class="keyword">in</span> options) || (options.minimize = <span class="keyword">this</span>.schema.options.minimize);

  <span class="keyword">var</span> ret = clone(<span class="keyword">this</span>._doc, options);

  <span class="keyword">if</span> (options.virtuals || options.getters &amp;&amp; <span class="literal">false</span> !== options.virtuals) {
    applyGetters(<span class="keyword">this</span>, ret, <span class="string">'virtuals'</span>, options);
  }

  <span class="keyword">if</span> (options.getters) {
    applyGetters(<span class="keyword">this</span>, ret, <span class="string">'paths'</span>, options);
  }

  <span class="keyword">return</span> ret;
};</code></pre><h3>applyGetters</h3><p>Applies virtuals properties to <code>json</code>.</p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">applyGetters</span> <span class="params">(self, json, type, options)</span> {</span>
  <span class="keyword">var</span> schema = self.schema
    , paths = Object.keys(schema[type])
    , i = paths.length
    , path

  <span class="keyword">while</span> (i--) {
    path = paths[i];

    <span class="keyword">var</span> parts = path.split(<span class="string">'.'</span>)
      , plen = parts.length
      , last = plen - <span class="number">1</span>
      , branch = json
      , part

    <span class="keyword">for</span> (<span class="keyword">var</span> ii = <span class="number">0</span>; ii &lt; plen; ++ii) {
      part = parts[ii];
      <span class="keyword">if</span> (ii === last) {
        branch[part] = clone(self.get(path), options);
      } <span class="keyword">else</span> {
        branch = branch[part] || (branch[part] = {});
      }
    }
  }

  <span class="keyword">return</span> json;
}</code></pre><h3>toJSON</h3><p>toJSON</p>

<p>The return value of this method is used in calls<br />to JSON.stringify(doc).</p><pre><code class="javascript">Document.prototype.toJSON = <span class="function"><span class="keyword">function</span> <span class="params">(options)</span> {</span>
  <span class="comment">// check for object type since an array of documents</span>
  <span class="comment">// being stringified passes array indexes instead</span>
  <span class="comment">// of options objects. JSON.stringify([doc, doc])</span>
  <span class="keyword">if</span> (!(options &amp;&amp; <span class="string">'Object'</span> == options.constructor.name)) {
    options = <span class="keyword">this</span>.schema.options.toJSON
      ? clone(<span class="keyword">this</span>.schema.options.toJSON)
      : {};
  }
  options.json = <span class="literal">true</span>;
  <span class="keyword">return</span> <span class="keyword">this</span>.toObject(options);
};</code></pre><p>Helpers for console.log</p><pre><code class="javascript">Document.prototype.toString =
Document.prototype.inspect = <span class="function"><span class="keyword">function</span> <span class="params">(options)</span> {</span>
  <span class="keyword">var</span> opts = options &amp;&amp; <span class="string">'Object'</span> == options.constructor.name
    ? options
    : <span class="literal">undefined</span>
  <span class="keyword">return</span> inspect(<span class="keyword">this</span>.toObject(opts));
};</code></pre><h3>equals</h3><p>equals</p>

<p>Returns true if the Document stores the same data as doc.</p><pre><code class="javascript">Document.prototype.equals = <span class="function"><span class="keyword">function</span> <span class="params">(doc)</span> {</span>
  <span class="keyword">var</span> tid = <span class="keyword">this</span>.get(<span class="string">'_id'</span>);
  <span class="keyword">var</span> docid = doc.get(<span class="string">'_id'</span>);
  <span class="keyword">return</span> tid.equals
    ? tid.equals(docid)
    : tid === docid;
};</code></pre><h3>ValidationError</h3><p>Module exports.</p><pre><code class="javascript">Document.ValidationError = ValidationError;
module.exports = exports = Document;
exports.Error = DocumentError;</code></pre></li><li><a href="/docs/index.html">lib/drivers/node-mongodb-native/binary.js</a></li><li><a href="/docs/index.html">lib/drivers/node-mongodb-native/collection.js</a><p>getIndexes</p>

<p>Retreives information about this collections<br />indexes.</p><pre><code class="javascript">MongooseCollection.prototype.getIndexes =
MongooseCollection.prototype.indexInformation;</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = MongooseCollection;</code></pre></li><li><a href="/docs/index.html">lib/drivers/node-mongodb-native/connection.js</a></li><li><a href="/docs/index.html">lib/drivers/node-mongodb-native/objectid.js</a></li><li><a href="/docs/index.html">lib/error.js</a><h3>__proto__</h3><p>Inherits from Error.</p><pre><code class="javascript">MongooseError.prototype.__proto__ = Error.prototype;</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = MongooseError;</code></pre></li><li><a href="/docs/index.html">lib/errors/document.js</a><h3>__proto__</h3><p>Inherits from MongooseError.</p><pre><code class="javascript">DocumentError.prototype.__proto__ = MongooseError.prototype;</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = exports = DocumentError;</code></pre></li><li><a href="/docs/index.html">lib/errors/validation.js</a><h3>__proto__</h3><p>Inherits from MongooseError.</p><pre><code class="javascript">ValidationError.prototype.__proto__ = MongooseError.prototype;</code></pre><h3>exports</h3><p>Module exports</p><pre><code class="javascript">module.exports = exports = ValidationError;</code></pre></li><li><a href="/docs/index.html">lib/index.js</a><h3>Mongoose</h3><p>Mongoose constructor. Most apps will only use one instance.</p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Mongoose</span> <span class="params">()</span> {</span>
  <span class="keyword">this</span>.connections = [];
  <span class="keyword">this</span>.plugins = [];
  <span class="keyword">this</span>.models = {};
  <span class="keyword">this</span>.modelSchemas = {};
  <span class="keyword">this</span>.options = {};
  <span class="keyword">this</span>.createConnection(); <span class="comment">// default connection</span>
};</code></pre><p>Sets/gets mongoose options</p>

<h2>Examples</h2>

<p>mongoose.set('test') // returns the 'test' value<br />   mongoose.set('test', value) // sets the 'test' value</p><pre><code class="javascript">Mongoose.prototype.set =
Mongoose.prototype.get = <span class="function"><span class="keyword">function</span> <span class="params">(key, value)</span> {</span>
  <span class="keyword">if</span> (arguments.length == <span class="number">1</span>)
    <span class="keyword">return</span> <span class="keyword">this</span>.options[key];
  <span class="keyword">this</span>.options[key] = value;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>createConnection</h3><p>Creates a Connection instance.</p>

<h2>Examples</h2>

<p>// with mongodb:// URI<br />   db = mongoose.createConnection('mongodb://localhost:port/database');</p>

<p>// with [host, database_name[, port] signature <br />   db = mongoose.createConnection('localhost', 'database', port)</p>

<p>// initialize now, connect later<br />   db = mongoose.createConnection();<br />   db.open('localhost', 'database', port);</p><pre><code class="javascript">Mongoose.prototype.createConnection = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> conn = <span class="keyword">new</span> Connection(<span class="keyword">this</span>);
  <span class="keyword">this</span>.connections.push(conn);

  <span class="keyword">if</span> (arguments.length) {
    <span class="keyword">if</span> (rgxReplSet.test(arguments[<span class="number">0</span>])) {
      conn.openSet.apply(conn, arguments);
    } <span class="keyword">else</span> {
      conn.open.apply(conn, arguments);
    }
  }

  <span class="keyword">return</span> conn;
};</code></pre><h3>connect</h3><p>Connects the default mongoose connection</p><pre><code class="javascript">Mongoose.prototype.connect = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> conn = <span class="keyword">this</span>.connection;

  <span class="keyword">if</span> (rgxReplSet.test(arguments[<span class="number">0</span>])) {
    conn.openSet.apply(conn, arguments);
  } <span class="keyword">else</span> {
    conn.open.apply(conn, arguments);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>disconnect</h3><p>Disconnects from all connections.</p><pre><code class="javascript">Mongoose.prototype.disconnect = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
  <span class="keyword">var</span> count = <span class="keyword">this</span>.connections.length
    , error

  <span class="keyword">this</span>.connections.forEach(<span class="keyword">function</span>(conn){
    conn.close(<span class="keyword">function</span>(err){
      <span class="keyword">if</span> (error) <span class="keyword">return</span>;

      <span class="keyword">if</span> (err) {
        error = err;
        <span class="keyword">if</span> (fn) <span class="keyword">return</span> fn(err);
        <span class="keyword">throw</span> err;
      }

      <span class="keyword">if</span> (fn)
        --count || fn();
    });
  });
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>model</h3><p>Defines a model or retrieves it</p><pre><code class="javascript">Mongoose.prototype.model = function (name, schema, collection, skipInit) {
  // normalize collection
  if (!(schema instanceof Schema)) {
    collection = schema;
    schema = false;
  }

  if ('boolean' === typeof collection) {
    skipInit = collection;
    collection = null;
  }

  // look up models for the collection
  if (!this.modelSchemas[name]) {
    if (!schema &amp;&amp; name in SchemaDefaults) {
      schema = SchemaDefaults[name];
    }

    if (schema) {
      this.modelSchemas[name] = schema;
      for (var i = 0, l = this.plugins.length; i &lt; l; i++) {
        schema.plugin(this.plugins[i][0], this.plugins[i][1]);
      }
    } else {
      throw new Error('Schema hasn\'t been registered for model "' + name + '".
'
                    + 'Use mongoose.model(name, schema)');
    }
  }

  if (!this.models[name]) {
    schema || (schema = this.modelSchemas[name]);
    collection || (collection = schema.set('collection') || format(name));

    var model = Model.compile(name
                        , this.modelSchemas[name]
                        , collection
                        , this.connection
                        , this);

    if (!skipInit) model.init();

    this.models[name] = model;
  }

  return this.models[name];
};</code></pre><h3>plugin</h3><p>Declares a plugin executed on Schemas. Equivalent to calling <code>.plugin(fn)</code><br />on each Schema you create.</p><pre><code class="javascript">Mongoose.prototype.plugin = <span class="function"><span class="keyword">function</span> <span class="params">(fn, opts)</span> {</span>
  <span class="keyword">this</span>.plugins.push([fn, opts]);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><p>Default connection</p><pre><code class="javascript">Mongoose.prototype.__defineGetter__(<span class="string">'connection'</span>, <span class="keyword">function</span>(){
  <span class="keyword">return</span> <span class="keyword">this</span>.connections[<span class="number">0</span>];
});</code></pre><h3>driver</h3><p>Driver depentend APIs</p><pre><code class="javascript"><span class="keyword">var</span> driver = global.MONGOOSE_DRIVER_PATH || <span class="string">'./drivers/node-mongodb-native'</span>;</code></pre><h3>Connection</h3><p>Connection</p><pre><code class="javascript"><span class="keyword">var</span> Connection = require(driver + <span class="string">'/connection'</span>);</code></pre><h3>Collection</h3><p>Collection</p><pre><code class="javascript"><span class="keyword">var</span> Collection = require(driver + <span class="string">'/collection'</span>);</code></pre><h3>exports</h3><p>Export default singleton.</p><pre><code class="javascript">module.exports = exports = <span class="keyword">new</span> Mongoose();</code></pre><h3>Collection</h3><p>Collection</p><pre><code class="javascript">exports.Collection = Collection;</code></pre><h3>Connection</h3><p>Connection</p><pre><code class="javascript">exports.Connection = Connection;</code></pre><h3>version</h3><p>Exports Mongoose version</p><pre><code class="javascript">exports.version = JSON.parse(
  require(<span class="string">'fs'</span>).readFileSync(__dirname + <span class="string">'/../package.json'</span>, <span class="string">'utf8'</span>)
).version;</code></pre><h3>Mongoose</h3><p>Export Mongoose constructor</p><pre><code class="javascript">exports.Mongoose = Mongoose;</code></pre><h3>Schema</h3><p>Export Schema constructor</p><pre><code class="javascript">exports.Schema = Schema;</code></pre><h3>SchemaType</h3><p>Export SchemaType constructor.</p><pre><code class="javascript">exports.SchemaType = SchemaType;</code></pre><h3>VirtualType</h3><p>Export VirtualType constructor.</p><pre><code class="javascript">exports.VirtualType = VirtualType;</code></pre><h3>SchemaTypes</h3><p>Export Schema types</p><pre><code class="javascript">exports.SchemaTypes = SchemaTypes;</code></pre><h3>Types</h3><p>Export types</p><pre><code class="javascript">exports.Types = Types;</code></pre><h3>Query</h3><p>Export Query</p><pre><code class="javascript">exports.Query = Query;</code></pre><h3>Promise</h3><p>Export Promise</p><pre><code class="javascript">exports.Promise = Promise;</code></pre><h3>Model</h3><p>Export Model constructor</p><pre><code class="javascript">exports.Model = Model;</code></pre><h3>Document</h3><p>Export Document constructor</p><pre><code class="javascript">exports.Document = Document;</code></pre><h3>Error</h3><p>Export MongooseError</p><pre><code class="javascript">exports.Error = require(<span class="string">'./error'</span>);</code></pre><h3>mongo</h3><p>Export driver</p><pre><code class="javascript">exports.mongo = require(<span class="string">'mongodb'</span>);</code></pre></li><li><a href="/docs/index.html">lib/model.js</a><h3>Model</h3><p>Model constructor</p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Model</span> <span class="params">(doc, fields, skipId)</span> {</span>
  Document.call(<span class="keyword">this</span>, doc, fields, skipId);
};</code></pre><h3>__proto__</h3><p>Inherits from Document.</p><pre><code class="javascript">Model.prototype.__proto__ = Document.prototype;</code></pre><p>Connection the model uses. Set by the Connection or if absent set to the<br />default mongoose connection;</p><pre><code class="javascript">Model.prototype.db;</code></pre><p>Collection the model uses. Set by Mongoose instance</p><pre><code class="javascript">Model.prototype.collection;</code></pre><p>Model name.</p><pre><code class="javascript">Model.prototype.modelName;</code></pre><h3>save</h3><p>Saves this document.</p><pre><code class="javascript">Model.prototype.save = <span class="function"><span class="keyword">function</span> <span class="title">save</span> <span class="params">(fn)</span> {</span>
  <span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(fn)
    , complete = handleSave(promise, <span class="keyword">this</span>)
    , options = {}

  <span class="keyword">if</span> (<span class="keyword">this</span>.schema.options.safe) {
    options.safe = <span class="keyword">this</span>.schema.options.safe;
  }

  <span class="keyword">if</span> (<span class="keyword">this</span>.isNew) {
    <span class="comment">// send entire doc</span>
    <span class="keyword">var</span> obj = <span class="keyword">this</span>.toObject({ depopulate: <span class="number">1</span> });
    <span class="keyword">this</span>._version(<span class="literal">true</span>, obj);
    <span class="keyword">this</span>.collection.insert(obj, options, complete);
    <span class="keyword">this</span>._reset();
    <span class="keyword">this</span>.isNew = <span class="literal">false</span>;
    <span class="keyword">this</span>.emit(<span class="string">'isNew'</span>, <span class="literal">false</span>);
    <span class="comment">// Make it possible to retry the insert</span>
    <span class="keyword">this</span>._inserting = <span class="literal">true</span>;

  } <span class="keyword">else</span> {
    <span class="comment">// Make sure we don't treat it as a new object on error,</span>
    <span class="comment">// since it already exists</span>
    <span class="keyword">this</span>._inserting = <span class="literal">false</span>;

    <span class="keyword">var</span> delta = <span class="keyword">this</span>._delta();
    <span class="keyword">if</span> (delta) {
      <span class="keyword">var</span> where = <span class="keyword">this</span>._where(delta[<span class="number">0</span>]);
      <span class="keyword">this</span>.collection.update(where, delta[<span class="number">1</span>], options, complete);
    } <span class="keyword">else</span> {
      complete(<span class="literal">null</span>);
    }

    <span class="keyword">this</span>._reset();
    <span class="keyword">this</span>.emit(<span class="string">'isNew'</span>, <span class="literal">false</span>);
  }
};</code></pre><h3>increment</h3><p>increment</p>

<p>Signal that we desire an increment of<br />this documents version.</p><pre><code class="javascript">Model.prototype.increment = <span class="function"><span class="keyword">function</span> <span class="title">increment</span> <span class="params">()</span> {</span>
  <span class="keyword">this</span>.__version = VERSION_ALL;
  <span class="keyword">return</span> <span class="keyword">this</span>;
}</code></pre><h3>_where</h3><p>_where</p>

<p>Returns a query object which applies shardkeys if<br />they exist.</p><pre><code class="javascript">Model.prototype._where = <span class="function"><span class="keyword">function</span> <span class="title">_where</span> <span class="params">(where)</span> {</span>
  where || (where = {});

  <span class="keyword">var</span> paths
    , len

  <span class="keyword">if</span> (<span class="keyword">this</span>._shardval) {
    paths = Object.keys(<span class="keyword">this</span>._shardval)
    len = paths.length

    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; ++i) {
      where[paths[i]] = <span class="keyword">this</span>._shardval[paths[i]];
    }
  }

  where._id = <span class="keyword">this</span>._doc._id;
  <span class="keyword">return</span> where;
}</code></pre><h3>remove</h3><p>Remove the document</p><pre><code class="javascript">Model.prototype.remove = <span class="function"><span class="keyword">function</span> <span class="title">remove</span> <span class="params">(fn)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>._removing) <span class="keyword">return</span> <span class="keyword">this</span>;

  <span class="keyword">var</span> promise = <span class="keyword">this</span>._removing = <span class="keyword">new</span> Promise(fn)
    , where = <span class="keyword">this</span>._where()
    , self = <span class="keyword">this</span>
    , options = {}

  <span class="keyword">if</span> (<span class="keyword">this</span>.schema.options.safe) {
    options.safe = <span class="keyword">this</span>.schema.options.safe;
  }

  <span class="keyword">this</span>.collection.remove(where, options, tick(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    <span class="keyword">if</span> (err) {
      promise.error(err);
      promise = self = self._removing = where = options = <span class="literal">null</span>;
      <span class="keyword">return</span>;
    }
    promise.complete();
    self.emit(<span class="string">'remove'</span>, self);
    promise = self = where = options = <span class="literal">null</span>;
  }));

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>model</h3><p>Shortcut to access another model.</p><pre><code class="javascript">Model.prototype.model = <span class="function"><span class="keyword">function</span> <span class="title">model</span> <span class="params">(name)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.db.model(name);
};</code></pre><p>Give the constructor the ability to emit events.</p><pre><code class="javascript"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> EventEmitter.prototype)
  Model[i] = EventEmitter.prototype[i];</code></pre><h3>ensureIndexes</h3><p>ensureIndexes</p>

<p>Sends <code>ensureIndex</code> commands to mongo for<br />each index declared in the schema.</p><pre><code class="javascript">Model.ensureIndexes = <span class="function"><span class="keyword">function</span> <span class="title">ensureIndexes</span> <span class="params">(cb)</span> {</span>
  <span class="keyword">var</span> indexes = <span class="keyword">this</span>.schema.indexes();
  <span class="keyword">if</span> (!indexes.length) {
    <span class="keyword">return</span> cb &amp;&amp; cb();
  }

  <span class="keyword">var</span> self = <span class="keyword">this</span>
    , safe = self.schema.options.safe
    , count = indexes.length
    , error

  indexes.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(index)</span> {</span>
    <span class="keyword">var</span> options = index[<span class="number">1</span>];
    options.safe = safe;
    self.collection.ensureIndex(index[<span class="number">0</span>], options, tick(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
      <span class="keyword">if</span> (err) error = err;
      <span class="keyword">if</span> (--count) <span class="keyword">return</span>;

      self.emit(<span class="string">'index'</span>, error);
      cb &amp;&amp; cb(error);
    }));
  });
}</code></pre><p>Document schema</p><pre><code class="javascript">Model.schema;</code></pre><p>Database instance the model uses.</p><pre><code class="javascript">Model.db;</code></pre><p>Collection the model uses.</p><pre><code class="javascript">Model.collection;</code></pre><p>Base Mongoose instance for the model.</p><pre><code class="javascript">Model.base;</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = exports = Model;

Model.remove = <span class="function"><span class="keyword">function</span> <span class="title">remove</span> <span class="params">(conditions, callback)</span> {</span>
  <span class="keyword">if</span> (<span class="string">'function'</span> === <span class="keyword">typeof</span> conditions) {
    callback = conditions;
    conditions = {};
  }

  <span class="keyword">var</span> query = <span class="keyword">new</span> Query(conditions).bind(<span class="keyword">this</span>, <span class="string">'remove'</span>);

  <span class="keyword">if</span> (<span class="string">'undefined'</span> === <span class="keyword">typeof</span> callback)
    <span class="keyword">return</span> query;

  <span class="keyword">this</span>._applyNamedScope(query);
  <span class="keyword">return</span> query.remove(callback);
};</code></pre><h3>find</h3><p>Finds documents</p>

<h2>Examples</h2>

<p>// retrieve only certain keys<br />   MyModel.find({ name: /john/i }, 'name friends', function () { })</p>

<p>// pass options<br />   MyModel.find({ name: /john/i }, null, { skip: 10 } )</p><pre><code class="javascript">Model.find = <span class="function"><span class="keyword">function</span> <span class="title">find</span> <span class="params">(conditions, fields, options, callback)</span> {</span>
  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> conditions) {
    callback = conditions;
    conditions = {};
    fields = <span class="literal">null</span>;
    options = <span class="literal">null</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> fields) {
    callback = fields;
    fields = <span class="literal">null</span>;
    options = <span class="literal">null</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> options) {
    callback = options;
    options = <span class="literal">null</span>;
  }

  <span class="keyword">var</span> query = <span class="keyword">new</span> Query(conditions, options);
  query.bind(<span class="keyword">this</span>, <span class="string">'find'</span>);
  query.select(fields);

  <span class="keyword">if</span> (<span class="string">'undefined'</span> === <span class="keyword">typeof</span> callback)
    <span class="keyword">return</span> query;

  <span class="keyword">this</span>._applyNamedScope(query);
  <span class="keyword">return</span> query.find(callback);
};</code></pre><h3>findById</h3><p>Finds by id</p><pre><code class="javascript">Model.findById = <span class="function"><span class="keyword">function</span> <span class="title">findById</span> <span class="params">(id, fields, options, callback)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.findOne({ _id: id }, fields, options, callback);
};</code></pre><h3>findOne</h3><p>Finds one document</p><pre><code class="javascript">Model.findOne = <span class="function"><span class="keyword">function</span> <span class="title">findOne</span> <span class="params">(conditions, fields, options, callback)</span> {</span>
  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> options) {
    <span class="comment">// TODO Handle all 3 of the following scenarios</span>
    <span class="comment">// Hint: Only some of these scenarios are possible if cQuery is present</span>
    <span class="comment">// Scenario: findOne(conditions, fields, callback);</span>
    <span class="comment">// Scenario: findOne(fields, options, callback);</span>
    <span class="comment">// Scenario: findOne(conditions, options, callback);</span>
    callback = options;
    options = <span class="literal">null</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> fields) {
    <span class="comment">// TODO Handle all 2 of the following scenarios</span>
    <span class="comment">// Scenario: findOne(conditions, callback)</span>
    <span class="comment">// Scenario: findOne(fields, callback)</span>
    <span class="comment">// Scenario: findOne(options, callback);</span>
    callback = fields;
    fields = <span class="literal">null</span>;
    options = <span class="literal">null</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> conditions) {
    callback = conditions;
    conditions = {};
    fields = <span class="literal">null</span>;
    options = <span class="literal">null</span>;
  }

  <span class="keyword">var</span> query = <span class="keyword">new</span> Query(conditions, options).select(fields).bind(<span class="keyword">this</span>, <span class="string">'findOne'</span>);

  <span class="keyword">if</span> (<span class="string">'undefined'</span> == <span class="keyword">typeof</span> callback)
    <span class="keyword">return</span> query;

  <span class="keyword">this</span>._applyNamedScope(query);
  <span class="keyword">return</span> query.findOne(callback);
};</code></pre><h3>count</h3><p>Counts documents</p><pre><code class="javascript">Model.count = <span class="function"><span class="keyword">function</span> <span class="title">count</span> <span class="params">(conditions, callback)</span> {</span>
  <span class="keyword">if</span> (<span class="string">'function'</span> === <span class="keyword">typeof</span> conditions)
    callback = conditions, conditions = {};

  <span class="keyword">var</span> query = <span class="keyword">new</span> Query(conditions).bind(<span class="keyword">this</span>, <span class="string">'count'</span>);
  <span class="keyword">if</span> (<span class="string">'undefined'</span> == <span class="keyword">typeof</span> callback)
    <span class="keyword">return</span> query;

  <span class="keyword">this</span>._applyNamedScope(query);
  <span class="keyword">return</span> query.count(callback);
};

Model.distinct = <span class="function"><span class="keyword">function</span> <span class="title">distinct</span> <span class="params">(field, conditions, callback)</span> {</span>
  <span class="keyword">var</span> query = <span class="keyword">new</span> Query(conditions).bind(<span class="keyword">this</span>, <span class="string">'distinct'</span>);
  <span class="keyword">if</span> (<span class="string">'undefined'</span> == <span class="keyword">typeof</span> callback) {
    query._distinctArg = field;
    <span class="keyword">return</span> query;
  }

  <span class="keyword">this</span>._applyNamedScope(query);
  <span class="keyword">return</span> query.distinct(field, callback);
};</code></pre><h3>where</h3><p>where</p>

<p>Creates a Query, applies the passed conditions, and<br />returns the Query.</p>

<p>For example, instead of writing:</p>

<pre><code>User.find({age: {$gte: 21, $lte: 65}}, callback);
</code></pre>

<p>we can instead write:</p>

<pre><code>User.where('age').gte(21).lte(65).exec(callback);
</code></pre>

<p>Since the Query class also supports <code>where</code> you can<br />continue chaining:</p>

<pre><code>User
</code></pre>

<p>.where('age').gte(21).lte(65)<br />   .where('name', /^b/i)<br />   ... etc</p><pre><code class="javascript">Model.where = <span class="function"><span class="keyword">function</span> <span class="title">where</span> <span class="params">(path, val)</span> {</span>
  <span class="keyword">var</span> q = <span class="keyword">new</span> Query().bind(<span class="keyword">this</span>, <span class="string">'find'</span>);
  <span class="keyword">return</span> q.where.apply(q, arguments);
};</code></pre><p>Sometimes you need to query for things in mongodb using a JavaScript<br />expression. You can do so via find({$where: javascript}), or you can<br />use the mongoose shortcut method $where via a Query chain or from<br />your mongoose Model.</p><pre><code class="javascript">Model.$where = <span class="function"><span class="keyword">function</span> <span class="title">$where</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> q = <span class="keyword">new</span> Query().bind(<span class="keyword">this</span>, <span class="string">'find'</span>);
  <span class="keyword">return</span> q.$where.apply(q, arguments);
};</code></pre><h3>findOneAndUpdate</h3><p>findOneAndUpdate</p>

<p>Issues a mongodb findAndModify update command.</p>

<p>Finds a matching document, updates it according to the <code>update</code><br />arg, passing any <code>options</code>, and returns the found document<br />(if any) to the callback. The query executes immediately if<br /><code>callback</code> is passed else a Query object is returned.</p>

<h2>Available options</h2>

<p><code>new</code>: bool - true to return the modified document rather than the original. defaults to true<br />  <code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.<br />  <code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</p>

<h2>Examples</h2>

<pre><code>A.findOneAndUpdate(conditions, update, options, callback) // executes
A.findOneAndUpdate(conditions, update, options)  // returns Query
A.findOneAndUpdate(conditions, update, callback) // executes
A.findOneAndUpdate(conditions, update)           // returns Query
A.findOneAndUpdate()                             // returns Query
</code></pre><pre><code class="javascript">Model.findOneAndUpdate = function (conditions, update, options, callback) {
  if ('function' == typeof options) {
    callback = options;
    options = null;
  }
  else if (1 === arguments.length) {
    if ('function' == typeof conditions) {
      var msg = 'Model.findOneAndUpdate(): First argument must not be a function.

'
              + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options, callback)
'
              + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options)
'
              + '  ' + this.modelName + '.findOneAndUpdate(conditions, update)
'
              + '  ' + this.modelName + '.findOneAndUpdate(update)
'
              + '  ' + this.modelName + '.findOneAndUpdate()
';
      throw new TypeError(msg)
    }
    update = conditions;
    conditions = undefined;
  }

  var fields;
  if (options &amp;&amp; options.fields) {
    fields = options.fields;
    options.fields = undefined;
  }

  var query = new Query(conditions, options);
  query.select(fields);
  query.bind(this, 'findOneAndUpdate', update);

  if ('undefined' == typeof callback)
    return query;

  this._applyNamedScope(query);
  return query.findOneAndUpdate(callback);
}</code></pre><h3>findByIdAndUpdate</h3><p>findByIdAndUpdate</p>

<p>Issue a mongodb findAndModify update command by a documents id.</p><pre><code class="javascript">Model.findByIdAndUpdate = function (id, update, options, callback) {
  var args;

  if (1 === arguments.length) {
    if ('function' == typeof id) {
      var msg = 'Model.findByIdAndUpdate(): First argument must not be a function.

'
                + '  ' + this.modelName + '.findByIdAndUpdate(id, callback)
'
                + '  ' + this.modelName + '.findByIdAndUpdate(id)
'
                + '  ' + this.modelName + '.findByIdAndUpdate()
';
      throw new TypeError(msg)
    }
    return this.findOneAndUpdate({_id: id }, undefined);
  }

  args = utils.args(arguments, 1);
  args.unshift({ _id: id });
  return this.findOneAndUpdate.apply(this, args);
}</code></pre><h3>findOneAndRemove</h3><p>findOneAndRemove</p>

<p>Issue a mongodb findAndModify remove command.</p>

<p>Finds a matching document, removes it, passing the found<br />document (if any) to the callback. Executes immediately if <code>callback</code><br />is passed else a Query object is returned.</p>

<h2>Available options</h2>

<p><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</p>

<h2>Examples</h2>

<pre><code>A.findOneAndRemove(conditions, options, callback) // executes
A.findOneAndRemove(conditions, options)  // return Query
A.findOneAndRemove(conditions, callback) // executes
A.findOneAndRemove(conditions) // returns Query
A.findOneAndRemove()           // returns Query
</code></pre><pre><code class="javascript">Model.findOneAndRemove = function (conditions, options, callback) {
  if (1 === arguments.length &amp;&amp; 'function' == typeof conditions) {
    var msg = 'Model.findOneAndRemove(): First argument must not be a function.

'
              + '  ' + this.modelName + '.findOneAndRemove(conditions, callback)
'
              + '  ' + this.modelName + '.findOneAndRemove(conditions)
'
              + '  ' + this.modelName + '.findOneAndRemove()
';
    throw new TypeError(msg)
  }

  if ('function' == typeof options) {
    callback = options;
    options = undefined;
  }

  var fields;
  if (options) {
    fields = options.select;
    options.select = undefined;
  }

  var query = new Query(conditions, options);
  query.bind(this, 'findOneAndRemove');
  query.select(fields);

  if ('undefined' == typeof callback)
    return query;

  this._applyNamedScope(query);
  return query.findOneAndRemove(callback);
}</code></pre><h3>findByIdAndRemove</h3><p>findByIdAndRemove</p>

<p>Issue a mongodb findAndModify remove command by a documents id.</p><pre><code class="javascript">Model.findByIdAndRemove = function (id, options, callback) {
  if (1 === arguments.length &amp;&amp; 'function' == typeof id) {
    var msg = 'Model.findByIdAndRemove(): First argument must not be a function.

'
              + '  ' + this.modelName + '.findByIdAndRemove(id, callback)
'
              + '  ' + this.modelName + '.findByIdAndRemove(id)
'
              + '  ' + this.modelName + '.findByIdAndRemove()
';
    throw new TypeError(msg)
  }

  return this.findOneAndRemove({ _id: id }, options, callback);
}</code></pre><h3>create</h3><p>Shortcut for creating a new Document that is automatically saved<br />to the db if valid.</p><pre><code class="javascript">Model.create = <span class="function"><span class="keyword">function</span> <span class="title">create</span> <span class="params">(doc, fn)</span> {</span>
  <span class="keyword">if</span> (<span class="number">1</span> === arguments.length) {
    <span class="keyword">return</span> <span class="string">'function'</span> === <span class="keyword">typeof</span> doc &amp;&amp; doc(<span class="literal">null</span>);
  }

  <span class="keyword">var</span> self = <span class="keyword">this</span>
    , docs = [<span class="literal">null</span>]
    , promise
    , count
    , args

  <span class="keyword">if</span> (Array.isArray(doc)) {
    args = doc;
  } <span class="keyword">else</span> {
    args = utils.args(arguments, <span class="number">0</span>, arguments.length - <span class="number">1</span>);
    fn = arguments[arguments.length - <span class="number">1</span>];
  }

  <span class="keyword">if</span> (<span class="number">0</span> === args.length) <span class="keyword">return</span> fn(<span class="literal">null</span>);

  promise = <span class="keyword">new</span> Promise(fn);
  count = args.length;

  args.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(arg, i)</span> {</span>
    <span class="keyword">var</span> doc = <span class="keyword">new</span> self(arg);
    docs[i+<span class="number">1</span>] = doc;
    doc.save(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
      <span class="keyword">if</span> (err) <span class="keyword">return</span> promise.error(err);
      --count || fn.apply(<span class="literal">null</span>, docs);
    });
  });

  <span class="comment">// TODO</span>
  <span class="comment">// utilize collection.insertAll for batch processing?</span>
};</code></pre><h3>update</h3><p>Updates documents.</p>

<h2>Examples</h2>

<pre><code>MyModel.update({ age: { $gt: 18 } }, { oldEnough: true }, fn);
MyModel.update({ name: 'Tobi' }, { ferret: true }, { multi: true }, fn);
</code></pre>

<h2>Valid options</h2>

<ul>
<li>safe (boolean) safe mode (defaults to value set in schema (true))</li>
<li>upsert (boolean) whether to create the doc if it doesn't match (false)</li>
<li>multi (boolean) whether multiple documents should be updated (false)</li>
</ul><pre><code class="javascript">Model.update = <span class="function"><span class="keyword">function</span> <span class="title">update</span> <span class="params">(conditions, doc, options, callback)</span> {</span>
  <span class="keyword">if</span> (arguments.length &lt; <span class="number">4</span>) {
    <span class="keyword">if</span> (<span class="string">'function'</span> === <span class="keyword">typeof</span> options) {
      <span class="comment">// Scenario: update(conditions, doc, callback)</span>
      callback = options;
      options = <span class="literal">null</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'function'</span> === <span class="keyword">typeof</span> doc) {
      <span class="comment">// Scenario: update(doc, callback);</span>
      callback = doc;
      doc = conditions;
      conditions = {};
      options = <span class="literal">null</span>;
    }
  }

  <span class="keyword">var</span> query = <span class="keyword">new</span> Query(conditions, options).bind(<span class="keyword">this</span>, <span class="string">'update'</span>, doc);

  <span class="keyword">if</span> (<span class="string">'undefined'</span> == <span class="keyword">typeof</span> callback)
    <span class="keyword">return</span> query;

  <span class="keyword">this</span>._applyNamedScope(query);
  <span class="keyword">return</span> query.update(doc, callback);
};</code></pre><h3>mapReduce</h3><p>mapReduce</p>

<p>Executes a mapReduce command. <code>o</code> is an object specifying<br />all mapReduce options as well as the map and reduce functions.<br />All options are delegated to the driver implementation.</p>

<h2>Example</h2>

<pre><code>var o = {};
o.map = function () { emit(this.name, 1) }
o.reduce = function (k, vals) { return vals.length }
User.mapReduce(o, function (err, results) {
  console.log(results)
})
</code></pre>

<h2>Other options</h2>

<p>(@see <a href='http://www.mongodb.org/display/DOCS/MapReduce'>http://www.mongodb.org/display/DOCS/MapReduce</a> for more details)<br />  - query {Object} query filter object.<br />  - limit {Number} max number of documents<br />  - keeptemp {Boolean, default:false} keep temporary data<br />  - finalize {Function} finalize function<br />  - scope {Object} scope variables exposed to map/reduce/finalize during execution<br />  - jsMode {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X<br />  - verbose {Boolean, default:false} provide statistics on job execution time.<br />  - out {Object, default: {inline:1}} sets the output target for the map reduce job.<br />     {inline:1} the results are returned in an array<br />     {replace: 'collectionName'} add the results to collectionName: the results replace the collection<br />     {reduce: 'collectionName'} add the results to collectionName: if dups are detected, uses the reducer / finalize functions<br />     {merge: 'collectionName'} add the results to collectionName: if dups exist the new docs overwrite the old</p>

<p>If options.out is set to replace, merge, or reduce, a Model<br />instance is returned that can be used for further querying.<br />Queries run against this model are all executed with the <code>lean</code><br />option: meaning only the js object is returned and no<br />Mongoose magic is applied (getters, setters, etc).</p>

<h2>Example</h2>

<pre><code>var o = {};
o.map = function () { emit(this.name, 1) }
o.reduce = function (k, vals) { return vals.length }
o.out = { replace: 'createdCollectionNameForResults' }
o.verbose = true;
User.mapReduce(o, function (err, model, stats) {
  console.log('map reduce took %d ms', stats.processtime)
  model.find().where('value').gt(10).exec(function (err, docs) {
    console.log(docs);
  });
})
</code></pre><pre><code class="javascript">Model.mapReduce = <span class="function"><span class="keyword">function</span> <span class="title">mapReduce</span> <span class="params">(o, callback)</span> {</span>
  <span class="keyword">if</span> (<span class="string">'function'</span> != <span class="keyword">typeof</span> callback) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'missing callback'</span>);

  <span class="keyword">var</span> self = <span class="keyword">this</span>;

  <span class="keyword">if</span> (!Model.mapReduce.schema) {
    <span class="keyword">var</span> opts = { noId: <span class="literal">true</span>, noVirtualId: <span class="literal">true</span>, strict: <span class="literal">false</span> }
    Model.mapReduce.schema = <span class="keyword">new</span> Schema({}, opts);
  }

  <span class="keyword">if</span> (!o.out) o.out = { inline: <span class="number">1</span> };

  o.map = String(o.map);
  o.reduce = String(o.reduce);

  <span class="keyword">this</span>.collection.mapReduce(<span class="literal">null</span>, <span class="literal">null</span>, o, <span class="function"><span class="keyword">function</span> <span class="params">(err, ret, stats)</span> {</span>
    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);

    <span class="keyword">if</span> (ret.findOne &amp;&amp; ret.mapReduce) {
      <span class="comment">// returned a collection, convert to Model</span>
      <span class="keyword">var</span> model = Model.compile(
          <span class="string">'_mapreduce_'</span> + ret.collectionName
        , Model.mapReduce.schema
        , ret.collectionName
        , self.db
        , self.base);

      model._mapreduce = <span class="literal">true</span>;

      <span class="keyword">return</span> callback(err, model, stats);
    }

    callback(err, ret, stats);
  });
}</code></pre></li><li><a href="/docs/index.html">lib/namedscope.js</a></li><li><a href="/docs/index.html">lib/promise.js</a><h3>Promise</h3><p>Promise constructor.</p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> <span class="params">(back)</span> {</span>
  <span class="keyword">this</span>.emitted = {};
  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> back)
    <span class="keyword">this</span>.addBack(back);
};</code></pre><h3>__proto__</h3><p>Inherits from EventEmitter.</p><pre><code class="javascript">Promise.prototype.__proto__ = EventEmitter.prototype;</code></pre><h3>on</h3><p>Adds an event or fires the callback right away.</p><pre><code class="javascript">Promise.prototype.on = <span class="function"><span class="keyword">function</span> <span class="params">(event, callback)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.emitted[event])
    callback.apply(<span class="keyword">this</span>, <span class="keyword">this</span>.emitted[event]);
  <span class="keyword">else</span>
    EventEmitter.prototype.on.call(<span class="keyword">this</span>, event, callback);

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>complete</h3><p>Shortcut for emitting complete event</p><pre><code class="javascript">Promise.prototype.complete = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> args = util.args(arguments);
  <span class="keyword">return</span> <span class="keyword">this</span>.emit.apply(<span class="keyword">this</span>, [<span class="string">'complete'</span>].concat(args));
};</code></pre><h3>error</h3><p>Shortcut for emitting err event</p><pre><code class="javascript">Promise.prototype.error = <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
  <span class="keyword">if</span> (!(err <span class="keyword">instanceof</span> Error)) err = <span class="keyword">new</span> Error(err);
  <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'err'</span>, err);
};</code></pre><h3>addCallback</h3><p>Shortcut for <code>.on('complete', fn)</code></p><pre><code class="javascript">Promise.prototype.addCallback = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.on(<span class="string">'complete'</span>, fn);
};</code></pre><h3>addErrback</h3><p>Shortcut for <code>.on('err', fn)</code></p><pre><code class="javascript">Promise.prototype.addErrback = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.on(<span class="string">'err'</span>, fn);
};</code></pre><h3>resolve</h3><p>Sugar for handling cases where you may be<br />resolving to either an error condition or a <br />success condition.</p><pre><code class="javascript">Promise.prototype.resolve = <span class="function"><span class="keyword">function</span> <span class="params">(err, val)</span> {</span>
  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="keyword">this</span>.error(err);
  <span class="keyword">return</span> <span class="keyword">this</span>.complete(val);
};</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = Promise;</code></pre></li><li><a href="/docs/index.html">lib/query.js</a><h3>setOptions</h3><p>setOptions</p>

<p>Sets query options.</p><pre><code class="javascript">Query.prototype.setOptions = <span class="function"><span class="keyword">function</span> <span class="params">(options, overwrite</code></pre><p>nternal</p><pre><code class="javascript">{
  <span class="keyword">if</span> (overwrite) {
    options = <span class="keyword">this</span>.options = options || {};
    <span class="keyword">this</span>.safe = options.safe

    <span class="comment">// normalize population options</span>
    <span class="keyword">var</span> pop = <span class="keyword">this</span>.options.populate;
    <span class="keyword">this</span>.options.populate = {};

    <span class="keyword">if</span> (pop &amp;&amp; Array.isArray(pop)) {
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = pop.length; i &lt; l; i++) {
        <span class="keyword">this</span>.options.populate[pop[i]] = {};
      }
    }

    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="keyword">if</span> (!(options &amp;&amp; <span class="string">'Object'</span> == options.constructor.name))
    <span class="keyword">return</span> <span class="keyword">this</span>;

  <span class="keyword">if</span> (<span class="string">'safe'</span> <span class="keyword">in</span> options)
    <span class="keyword">this</span>.safe = options.safe;

  <span class="comment">// set arbitrary options</span>
  <span class="keyword">var</span> methods = Object.keys(options)
    , i = methods.length
    , method

  <span class="keyword">while</span> (i--) {
    method = methods[i];

    <span class="comment">// use methods if exist (safer option manipulation)</span>
    <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> <span class="keyword">this</span>[method]) {
      <span class="keyword">var</span> args = Array.isArray(options[method])
        ? options[method]
        : [options[method]];
      <span class="keyword">this</span>[method].apply(<span class="keyword">this</span>, args)
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.options[method] = options[method];
    }
  }
  <span class="keyword">return</span> <span class="keyword">this</span>;
}</code></pre><h3>bind</h3><p>Binds this query to a model.</p><pre><code class="javascript">Query.prototype.bind = <span class="function"><span class="keyword">function</span> <span class="title">bind</span> <span class="params">(model, op, updateArg)</span> {</span>
  <span class="keyword">this</span>.model = model;
  <span class="keyword">this</span>.op = op;

  <span class="keyword">if</span> (model._mapreduce) <span class="keyword">this</span>.options.lean = <span class="literal">true</span>;

  <span class="keyword">if</span> (op == <span class="string">'update'</span> || op == <span class="string">'findOneAndUpdate'</span>) {
    merge(<span class="keyword">this</span>._updateArg, updateArg || {});
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>exec</h3><p>exec</p>

<p>Executes the query returning a promise.</p>

<h2>Examples</h2>

<pre><code>query.exec();
query.exec(callback);
query.exec('update');
query.exec('find', callback);
</code></pre><pre><code class="javascript">Query.prototype.exec = <span class="function"><span class="keyword">function</span> <span class="title">exec</span> <span class="params">(op, callback)</span> {</span>
  <span class="keyword">var</span> promise = <span class="keyword">new</span> Promise();

  <span class="keyword">switch</span> (<span class="keyword">typeof</span> op) {
    <span class="keyword">case</span> <span class="string">'function'</span>:
      callback = op;
      op = <span class="literal">null</span>;
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">'string'</span>:
      <span class="keyword">this</span>.op = op;
      <span class="keyword">break</span>;
  }

  <span class="keyword">if</span> (callback) promise.addBack(callback);

  <span class="keyword">if</span> (!<span class="keyword">this</span>.op) {
    promise.complete();
    <span class="keyword">return</span> promise;
  }

  <span class="keyword">if</span> (<span class="string">'update'</span> == <span class="keyword">this</span>.op) {
    <span class="keyword">this</span>[<span class="keyword">this</span>.op](<span class="keyword">this</span>._updateArg, promise.resolve.bind(promise));
    <span class="keyword">return</span> promise;
  }

  <span class="keyword">if</span> (<span class="string">'distinct'</span> == <span class="keyword">this</span>.op) {
    <span class="keyword">this</span>.distinct(<span class="keyword">this</span>._distinctArg, promise.resolve.bind(promise));
    <span class="keyword">return</span> promise;
  }

  <span class="keyword">this</span>[<span class="keyword">this</span>.op](promise.resolve.bind(promise));
  <span class="keyword">return</span> promise;
};</code></pre><h3>find</h3><p>Finds documents.</p><pre><code class="javascript">Query.prototype.find = <span class="function"><span class="keyword">function</span> <span class="params">(criteria, callback)</span> {</span>
  <span class="keyword">this</span>.op = <span class="string">'find'</span>;
  <span class="keyword">if</span> (<span class="string">'function'</span> === <span class="keyword">typeof</span> criteria) {
    callback = criteria;
    criteria = {};
  } <span class="keyword">else</span> <span class="keyword">if</span> (criteria <span class="keyword">instanceof</span> Query) {
    <span class="comment">// TODO Merge options, too</span>
    merge(<span class="keyword">this</span>._conditions, criteria._conditions);
  } <span class="keyword">else</span> <span class="keyword">if</span> (criteria <span class="keyword">instanceof</span> Document) {
    merge(<span class="keyword">this</span>._conditions, criteria.toObject());
  } <span class="keyword">else</span> <span class="keyword">if</span> (criteria &amp;&amp; <span class="string">'Object'</span> === criteria.constructor.name) {
    merge(<span class="keyword">this</span>._conditions, criteria);
  }
  <span class="keyword">if</span> (!callback) <span class="keyword">return</span> <span class="keyword">this</span>;
  <span class="keyword">return</span> <span class="keyword">this</span>.execFind(callback);
};</code></pre><h3>cast</h3><p>Casts obj, or if obj is not present, then this._conditions,<br />based on the model's schema.</p><pre><code class="javascript">Query.prototype.cast = <span class="function"><span class="keyword">function</span> <span class="params">(model, obj)</span> {</span>
  obj || (obj= <span class="keyword">this</span>._conditions);

  <span class="keyword">var</span> schema = model.schema
    , paths = Object.keys(obj)
    , i = paths.length
    , any$conditionals
    , schematype
    , nested
    , path
    , type
    , val;

  <span class="keyword">while</span> (i--) {
    path = paths[i];
    val = obj[path];

    <span class="keyword">if</span> (<span class="string">'$or'</span> === path || <span class="string">'$nor'</span> === path) {
      <span class="keyword">var</span> k = val.length
        , orComponentQuery;

      <span class="keyword">while</span> (k--) {
        orComponentQuery = <span class="keyword">new</span> Query(val[k]);
        orComponentQuery.cast(model);
        val[k] = orComponentQuery._conditions;
      }

    } <span class="keyword">else</span> <span class="keyword">if</span> (path === <span class="string">'$where'</span>) {
      type = <span class="keyword">typeof</span> val;

      <span class="keyword">if</span> (<span class="string">'string'</span> !== type &amp;&amp; <span class="string">'function'</span> !== type) {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Must have a string or function for $where"</span>);
      }

      <span class="keyword">if</span> (<span class="string">'function'</span> === type) {
        obj[path] = val.toString();
      }

      <span class="keyword">continue</span>;

    } <span class="keyword">else</span> {

      <span class="keyword">if</span> (!schema) {
        <span class="comment">// no casting for Mixed types</span>
        <span class="keyword">continue</span>;
      }

      schematype = schema.path(path);

      <span class="keyword">if</span> (!schematype) {
        <span class="comment">// Handle potential embedded array queries</span>
        <span class="keyword">var</span> split = path.split(<span class="string">'.'</span>)
          , j = split.length
          , pathFirstHalf
          , pathLastHalf
          , remainingConds
          , castingQuery;

        <span class="comment">// Find the part of the var path that is a path of the Schema</span>
        <span class="keyword">while</span> (j--) {
          pathFirstHalf = split.slice(<span class="number">0</span>, j).join(<span class="string">'.'</span>);
          schematype = schema.path(pathFirstHalf);
          <span class="keyword">if</span> (schematype) <span class="keyword">break</span>;
        }

        <span class="comment">// If a substring of the input path resolves to an actual real path...</span>
        <span class="keyword">if</span> (schematype) {
          <span class="comment">// Apply the casting; similar code for $elemMatch in schema/array.js</span>
          <span class="keyword">if</span> (schematype.caster &amp;&amp; schematype.caster.schema) {
            remainingConds = {};
            pathLastHalf = split.slice(j).join(<span class="string">'.'</span>);
            remainingConds[pathLastHalf] = val;
            castingQuery = <span class="keyword">new</span> Query(remainingConds);
            castingQuery.cast(schematype.caster);
            obj[path] = castingQuery._conditions[pathLastHalf];
          } <span class="keyword">else</span> {
            obj[path] = val;
          }
        }

      } <span class="keyword">else</span> <span class="keyword">if</span> (val === <span class="literal">null</span> || val === <span class="literal">undefined</span>) {
        <span class="keyword">continue</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'Object'</span> === val.constructor.name) {

        any$conditionals = Object.keys(val).some(<span class="function"><span class="keyword">function</span> <span class="params">(k)</span> {</span>
          <span class="keyword">return</span> k.charAt(<span class="number">0</span>) === <span class="string">'$'</span> &amp;&amp; k !== <span class="string">'$id'</span> &amp;&amp; k !== <span class="string">'$ref'</span>;
        });

        <span class="keyword">if</span> (!any$conditionals) {
          obj[path] = schematype.castForQuery(val);
        } <span class="keyword">else</span> {

          <span class="keyword">var</span> ks = Object.keys(val)
            , k = ks.length
            , $cond;

          <span class="keyword">while</span> (k--) {
            $cond = ks[k];
            nested = val[$cond];

            <span class="keyword">if</span> (<span class="string">'$exists'</span> === $cond) {
              <span class="keyword">if</span> (<span class="string">'boolean'</span> !== <span class="keyword">typeof</span> nested) {
                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"$exists parameter must be Boolean"</span>);
              }
              <span class="keyword">continue</span>;
            }

            <span class="keyword">if</span> (<span class="string">'$type'</span> === $cond) {
              <span class="keyword">if</span> (<span class="string">'number'</span> !== <span class="keyword">typeof</span> nested) {
                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"$type parameter must be Number"</span>);
              }
              <span class="keyword">continue</span>;
            }

            <span class="keyword">if</span> (<span class="string">'$not'</span> === $cond) {
              <span class="keyword">this</span>.cast(model, nested);
            } <span class="keyword">else</span> {
              val[$cond] = schematype.castForQuery($cond, nested);
            }
          }
        }
      } <span class="keyword">else</span> {
        obj[path] = schematype.castForQuery(val);
      }
    }
  }

  <span class="keyword">return</span> obj;
};</code></pre><p>$where</p>

<p>Sometimes you need to query for things in mongodb using a JavaScript<br />expression. You can do so via find({$where: javascript}), or you can<br />use the mongoose shortcut method $where via a Query chain or from<br />your mongoose Model.</p><pre><code class="javascript">Query.prototype.$where = <span class="function"><span class="keyword">function</span> <span class="params">(js)</span> {</span>
  <span class="keyword">this</span>._conditions[<span class="string">'$where'</span>] = js;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>where</h3><p>where</p>

<p>Sugar for query.find().</p>

<p>For example, instead of writing:</p>

<pre><code>User.find({age: {$gte: 21, $lte: 65}}, callback);
</code></pre>

<p>we can instead write:</p>

<pre><code>User.where('age').gte(21).lte(65);
</code></pre>

<p>Moreover, you can also chain a bunch of these together:</p>

<pre><code>User
</code></pre>

<p>.where('age').gte(21).lte(65)<br />   .where('name', /^b/i)        // All names that begin where b or B<br />   .where('friends').slice(10);</p><pre><code class="javascript">Query.prototype.where = <span class="function"><span class="keyword">function</span> <span class="params">(path, val)</span> {</span>
  <span class="keyword">if</span> (!arguments.length) <span class="keyword">return</span> <span class="keyword">this</span>;

  <span class="keyword">if</span> (<span class="string">'string'</span> != <span class="keyword">typeof</span> path) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'path must be a string'</span>);
  }

  <span class="keyword">this</span>._currPath = path;

  <span class="keyword">if</span> (<span class="number">2</span> === arguments.length) {
    <span class="keyword">this</span>._conditions[path] = val;
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>equals</h3><p><code>equals</code> sugar.</p>

<pre><code>User.where('age').equals(49);
</code></pre>

<p>Same as</p>

<pre><code>User.where('age', 49);
</code></pre><pre><code class="javascript">Query.prototype.equals = <span class="function"><span class="keyword">function</span> <span class="title">equals</span> <span class="params">(val)</span> {</span>
  <span class="keyword">var</span> path = <span class="keyword">this</span>._currPath;
  <span class="keyword">if</span> (!path) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'equals() must be used after where()'</span>);
  <span class="keyword">this</span>._conditions[path] = val;
  <span class="keyword">return</span> <span class="keyword">this</span>;
}</code></pre><h3>or</h3><p>or</p><pre><code class="javascript">Query.prototype.or = <span class="function"><span class="keyword">function</span> <span class="title">or</span> <span class="params">(array)</span> {</span>
  <span class="keyword">var</span> or = <span class="keyword">this</span>._conditions.$or || (<span class="keyword">this</span>._conditions.$or = []);
  <span class="keyword">if</span> (!Array.isArray(array)) array = [array];
  or.push.apply(or, array);
  <span class="keyword">return</span> <span class="keyword">this</span>;
}</code></pre><h3>nor</h3><p>nor</p><pre><code class="javascript">Query.prototype.nor = <span class="function"><span class="keyword">function</span> <span class="title">nor</span> <span class="params">(array)</span> {</span>
  <span class="keyword">var</span> nor = <span class="keyword">this</span>._conditions.$nor || (<span class="keyword">this</span>._conditions.$nor = []);
  <span class="keyword">if</span> (!Array.isArray(array)) array = [array];
  nor.push.apply(nor, array);
  <span class="keyword">return</span> <span class="keyword">this</span>;
}</code></pre><p>gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance</p>

<p>Can be used on Numbers or Dates.</p>

<pre><code>Thing.where('type').nin(array)
</code></pre><pre><code class="javascript"><span class="string">'gt gte lt lte ne in nin all regex size maxDistance'</span>.split(<span class="string">' '</span>).forEach(<span class="function"><span class="keyword">function</span> <span class="params">($conditional)</span> {</span>
  Query.prototype[$conditional] = <span class="function"><span class="keyword">function</span> <span class="params">(path, val)</span> {</span>
    <span class="keyword">if</span> (arguments.length === <span class="number">1</span>) {
      val = path;
      path = <span class="keyword">this</span>._currPath
    }
    <span class="keyword">var</span> conds = <span class="keyword">this</span>._conditions[path] || (<span class="keyword">this</span>._conditions[path] = {});
    conds[<span class="string">'$'</span> + $conditional] = val;
    <span class="keyword">return</span> <span class="keyword">this</span>;
  };
});</code></pre><p>mod, near</p><pre><code class="javascript">;[<span class="string">'mod'</span>, <span class="string">'near'</span>].forEach(<span class="function"><span class="keyword">function</span> <span class="params">($conditional)</span> {</span>
  Query.prototype[$conditional] = <span class="function"><span class="keyword">function</span> <span class="params">(path, val)</span> {</span>
    <span class="keyword">if</span> (arguments.length === <span class="number">1</span>) {
      val = path;
      path = <span class="keyword">this</span>._currPath
    } <span class="keyword">else</span> <span class="keyword">if</span> (arguments.length === <span class="number">2</span> &amp;&amp; !Array.isArray(val)) {
      val = utils.args(arguments);
      path = <span class="keyword">this</span>._currPath;
    } <span class="keyword">else</span> <span class="keyword">if</span> (arguments.length === <span class="number">3</span>) {
      val = utils.args(arguments, <span class="number">1</span>);
    }
    <span class="keyword">var</span> conds = <span class="keyword">this</span>._conditions[path] || (<span class="keyword">this</span>._conditions[path] = {});
    conds[<span class="string">'$'</span> + $conditional] = val;
    <span class="keyword">return</span> <span class="keyword">this</span>;
  };
});</code></pre><h3>exists</h3><p>exists</p><pre><code class="javascript">Query.prototype.exists = <span class="function"><span class="keyword">function</span> <span class="params">(path, val)</span> {</span>
  <span class="keyword">if</span> (arguments.length === <span class="number">0</span>) {
    path = <span class="keyword">this</span>._currPath
    val = <span class="literal">true</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (arguments.length === <span class="number">1</span>) {
    <span class="keyword">if</span> (<span class="string">'boolean'</span> === <span class="keyword">typeof</span> path) {
      val = path;
      path = <span class="keyword">this</span>._currPath;
    } <span class="keyword">else</span> {
      val = <span class="literal">true</span>;
    }
  }
  <span class="keyword">var</span> conds = <span class="keyword">this</span>._conditions[path] || (<span class="keyword">this</span>._conditions[path] = {});
  conds[<span class="string">'$exists'</span>] = val;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>elemMatch</h3><p>elemMatch</p><pre><code class="javascript">Query.prototype.elemMatch = <span class="function"><span class="keyword">function</span> <span class="params">(path, criteria)</span> {</span>
  <span class="keyword">var</span> block;
  <span class="keyword">if</span> (<span class="string">'Object'</span> === path.constructor.name) {
    criteria = path;
    path = <span class="keyword">this</span>._currPath;
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'function'</span> === <span class="keyword">typeof</span> path) {
    block = path;
    path = <span class="keyword">this</span>._currPath;
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'Object'</span> === criteria.constructor.name) {
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'function'</span> === <span class="keyword">typeof</span> criteria) {
    block = criteria;
  } <span class="keyword">else</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Argument error"</span>);
  }
  <span class="keyword">var</span> conds = <span class="keyword">this</span>._conditions[path] || (<span class="keyword">this</span>._conditions[path] = {});
  <span class="keyword">if</span> (block) {
    criteria = <span class="keyword">new</span> Query();
    block(criteria);
    conds[<span class="string">'$elemMatch'</span>] = criteria._conditions;
  } <span class="keyword">else</span> {
    conds[<span class="string">'$elemMatch'</span>] = criteria;
  }
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">// Spatial queries</span></code></pre><p>within</p>

<h2>Example</h2>

<pre><code>query.within.box()
query.within.center()
</code></pre><pre><code class="javascript">Object.defineProperty(Query.prototype, <span class="string">'within'</span>, {
  get: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="keyword">return</span> <span class="keyword">this</span> }
});</code></pre><h3>box</h3><p>box</p>

<p>Specifies a $box query.</p>

<h2>Example</h2>

<pre><code>var lowerLeft = [40.73083, -73.99756]
var upperRight= [40.741404,  -73.988135]
query.where('loc').within.box({ ll: lowerLeft , ur: upperRight })
</code></pre><pre><code class="javascript">Query.prototype.box = <span class="function"><span class="keyword">function</span> <span class="params">(path, val)</span> {</span>
  <span class="keyword">if</span> (arguments.length === <span class="number">1</span>) {
    val = path;
    path = <span class="keyword">this</span>._currPath;
  }
  <span class="keyword">var</span> conds = <span class="keyword">this</span>._conditions[path] || (<span class="keyword">this</span>._conditions[path] = {});
  conds[<span class="string">'$within'</span>] = { <span class="string">'$box'</span>: [val.ll, val.ur]  };
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>center</h3><p>center</p>

<p>Specifies a $center query.</p>

<h2>Example</h2>

<pre><code>var area = { center: [50, 50], radius: 10 }
query.where('loc').within.center(area)
</code></pre><pre><code class="javascript">Query.prototype.center = <span class="function"><span class="keyword">function</span> <span class="params">(path, val)</span> {</span>
  <span class="keyword">if</span> (arguments.length === <span class="number">1</span>) {
    val = path;
    path = <span class="keyword">this</span>._currPath;
  }
  <span class="keyword">var</span> conds = <span class="keyword">this</span>._conditions[path] || (<span class="keyword">this</span>._conditions[path] = {});
  conds[<span class="string">'$within'</span>] = { <span class="string">'$center'</span>: [val.center, val.radius]  };
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>centerSphere</h3><p>centerSphere</p><pre><code class="javascript">Query.prototype.centerSphere = <span class="function"><span class="keyword">function</span> <span class="params">(path, val)</span> {</span>
  <span class="keyword">if</span> (arguments.length === <span class="number">1</span>) {
    val = path;
    path = <span class="keyword">this</span>._currPath;
  }
  <span class="keyword">var</span> conds = <span class="keyword">this</span>._conditions[path] || (<span class="keyword">this</span>._conditions[path] = {});
  conds[<span class="string">'$within'</span>] = { <span class="string">'$centerSphere'</span>: [val.center, val.radius]  };
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>select</h3><p>select</p>

<p>Specifies which fields to include or exclude from<br />the document that is returned from MongoDB.</p>

<h2>Example</h2>

<pre><code>query.select('a b -c');
query.select({a: 1, b: 1, c: 0}); // useful if you have keys that start with "-"
query.select('+path') // force inclusion of field excluded at schema level
</code></pre><pre><code class="javascript">Query.prototype.select = <span class="function"><span class="keyword">function</span> <span class="title">select</span> <span class="params">(arg)</span> {</span>
  <span class="keyword">if</span> (!arg) <span class="keyword">return</span> <span class="keyword">this</span>;

  <span class="keyword">var</span> fields = <span class="keyword">this</span>._fields || (<span class="keyword">this</span>._fields = {});

  <span class="keyword">if</span> (<span class="string">'Object'</span> === arg.constructor.name) {
    Object.keys(arg).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(field)</span> {</span>
      fields[field] = arg[field];
    });
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> === arguments.length &amp;&amp; <span class="string">'string'</span> == <span class="keyword">typeof</span> arg) {
    arg.split(<span class="regexp">/\s+/</span>).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(field)</span> {</span>
      <span class="keyword">if</span> (!field) <span class="keyword">return</span>;
      <span class="keyword">var</span> include = <span class="string">'-'</span> == field[<span class="number">0</span>] ? <span class="number">0</span> : <span class="number">1</span>;
      <span class="keyword">if</span> (include === <span class="number">0</span>) field = field.substring(<span class="number">1</span>);
      fields[field] = include;
    });
  } <span class="keyword">else</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Invalid select() argument. Must be a string or object.'</span>);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>slice</h3><p>slice()</p><pre><code class="javascript">Query.prototype.slice = <span class="function"><span class="keyword">function</span> <span class="params">(path, val)</span> {</span>
  <span class="keyword">if</span> (arguments.length === <span class="number">1</span>) {
      val = path;
      path = <span class="keyword">this</span>._currPath
  } <span class="keyword">else</span> <span class="keyword">if</span> (arguments.length === <span class="number">2</span>) {
    <span class="keyword">if</span> (<span class="string">'number'</span> === <span class="keyword">typeof</span> path) {
      val = [path, val];
      path = <span class="keyword">this</span>._currPath;
    }
  } <span class="keyword">else</span> <span class="keyword">if</span> (arguments.length === <span class="number">3</span>) {
    val = utils.args(arguments, <span class="number">1</span>);
  }
  <span class="keyword">var</span> myFields = <span class="keyword">this</span>._fields || (<span class="keyword">this</span>._fields = {});
  myFields[path] = { <span class="string">'$slice'</span>: val };
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>sort</h3><p>sort</p>

<p>Sets the sort order. Accepts a single parameter, either an object or string.<br />If an object is passed values allowed are 'asc', 'desc', 'ascending', 'descending', 1, -1.<br />If a string is passed it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with <code>-</code> which will be treated as descending.</p>

<h2>Examples</h2>

<pre><code>// these are equivalent
query.sort({ field: 'asc', test: -1 });
query.sort('field -test');
</code></pre><pre><code class="javascript">Query.prototype.sort = <span class="function"><span class="keyword">function</span> <span class="params">(arg)</span> {</span>
  <span class="keyword">if</span> (!arg) <span class="keyword">return</span> <span class="keyword">this</span>;

  <span class="keyword">var</span> sort = <span class="keyword">this</span>.options.sort || (<span class="keyword">this</span>.options.sort = []);

  <span class="keyword">if</span> (<span class="string">'Object'</span> === arg.constructor.name) {
    Object.keys(arg).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(field)</span> {</span>
      push(sort, field, arg[field]);
    });
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> === arguments.length &amp;&amp; <span class="string">'string'</span> == <span class="keyword">typeof</span> arg) {
    arg.split(<span class="regexp">/\s+/</span>).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(field)</span> {</span>
      <span class="keyword">if</span> (!field) <span class="keyword">return</span>;
      <span class="keyword">var</span> ascend = <span class="string">'-'</span> == field[<span class="number">0</span>] ? -<span class="number">1</span> : <span class="number">1</span>;
      <span class="keyword">if</span> (ascend === -<span class="number">1</span>) field = field.substring(<span class="number">1</span>);
      push(sort, field, ascend);
    });
  } <span class="keyword">else</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Invalid sort() argument. Must be a string or object.'</span>);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><p>limit, skip, maxscan, snapshot, batchSize, comment</p>

<p>Sets these associated options.</p>

<pre><code>query.comment('feed query');
</code></pre><pre><code class="javascript">;[<span class="string">'limit'</span>, <span class="string">'skip'</span>, <span class="string">'maxscan'</span>, <span class="string">'snapshot'</span>, <span class="string">'batchSize'</span>, <span class="string">'comment'</span>].forEach(<span class="function"><span class="keyword">function</span> <span class="params">(method)</span> {</span>
  Query.prototype[method] = <span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
    <span class="keyword">this</span>.options[method] = v;
    <span class="keyword">return</span> <span class="keyword">this</span>;
  };
});</code></pre><h3>hint</h3><p>hint</p>

<p>Sets query hints.</p>

<h2>Examples</h2>

<pre><code>new Query().hint({ indexA: 1, indexB: -1})
</code></pre><pre><code class="javascript">Query.prototype.hint = <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
  <span class="keyword">if</span> (!val) <span class="keyword">return</span> <span class="keyword">this</span>;

  <span class="keyword">var</span> hint = <span class="keyword">this</span>.options.hint || (<span class="keyword">this</span>.options.hint = {});

  <span class="keyword">if</span> (<span class="string">'Object'</span> === val.constructor.name) {
    <span class="comment">// must keep object keys in order so don't use Object.keys()</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> val) {
      hint[k] = val[k];
    }
  } <span class="keyword">else</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Invalid hint. '</span> + val);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>slaveOk</h3><p>slaveOk</p>

<p>Sets slaveOk option.</p>

<pre><code>new Query().slaveOk() &lt;== true
new Query().slaveOk(true)
new Query().slaveOk(false)
</code></pre><pre><code class="javascript">Query.prototype.slaveOk = <span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
  <span class="keyword">this</span>.options.slaveOk = arguments.length ? !!v : <span class="literal">true</span>;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>tailable</h3><p>tailable</p>

<p>Sets tailable option.</p>

<pre><code>new Query().tailable() &lt;== true
new Query().tailable(true)
new Query().tailable(false)
</code></pre><pre><code class="javascript">Query.prototype.tailable = <span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
  <span class="keyword">this</span>.options.tailable = arguments.length ? !!v : <span class="literal">true</span>;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>findOne</h3><p>findOne</p>

<p>Casts the query, sends the findOne command to mongodb.<br />Upon receiving the document, we initialize a mongoose<br />document based on the returned document from mongodb,<br />and then we invoke a callback on our mongoose document.</p><pre><code class="javascript">Query.prototype.findOne = <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> {</span>
  <span class="keyword">this</span>.op = <span class="string">'findOne'</span>;

  <span class="keyword">if</span> (!callback) <span class="keyword">return</span> <span class="keyword">this</span>;

  <span class="keyword">var</span> model = <span class="keyword">this</span>.model;
  <span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(callback);

  <span class="keyword">try</span> {
    <span class="keyword">this</span>.cast(model);
  } <span class="keyword">catch</span> (err) {
    promise.error(err);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="comment">// apply default schematype path selections</span>
  <span class="keyword">this</span>._applyPaths();

  <span class="keyword">var</span> self = <span class="keyword">this</span>
    , castQuery = <span class="keyword">this</span>._conditions
    , options = <span class="keyword">this</span>._optionsForExec(model)

  <span class="keyword">var</span> fields = utils.clone(options.fields = <span class="keyword">this</span>._fields);

  model.collection.findOne(castQuery, options, tick(<span class="function"><span class="keyword">function</span> <span class="params">(err, doc)</span> {</span>
    <span class="keyword">if</span> (err) <span class="keyword">return</span> promise.error(err);
    <span class="keyword">if</span> (!doc) <span class="keyword">return</span> promise.complete(<span class="literal">null</span>);

    <span class="keyword">if</span> (<span class="literal">true</span> === options.lean) <span class="keyword">return</span> promise.complete(doc);

    <span class="keyword">var</span> casted = <span class="keyword">new</span> model(<span class="literal">undefined</span>, fields, <span class="literal">true</span>);
    casted.init(doc, self, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
      <span class="keyword">if</span> (err) <span class="keyword">return</span> promise.error(err);
      promise.complete(casted);
    });
  }));

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>count</h3><p>count</p>

<p>Casts this._conditions and sends a count<br />command to mongodb. Invokes a callback upon<br />receiving results</p><pre><code class="javascript">Query.prototype.count = <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> {</span>
  <span class="keyword">this</span>.op = <span class="string">'count'</span>;
  <span class="keyword">var</span> model = <span class="keyword">this</span>.model;

  <span class="keyword">try</span> {
    <span class="keyword">this</span>.cast(model);
  } <span class="keyword">catch</span> (err) {
    <span class="keyword">return</span> callback(err);
  }

  <span class="keyword">var</span> castQuery = <span class="keyword">this</span>._conditions;
  model.collection.count(castQuery, tick(callback));

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>distinct</h3><p>distinct</p>

<p>Casts this._conditions and sends a distinct<br />command to mongodb. Invokes a callback upon<br />receiving results</p><pre><code class="javascript">Query.prototype.distinct = <span class="function"><span class="keyword">function</span> <span class="params">(field, callback)</span> {</span>
  <span class="keyword">this</span>.op = <span class="string">'distinct'</span>;
  <span class="keyword">var</span> model = <span class="keyword">this</span>.model;

  <span class="keyword">try</span> {
    <span class="keyword">this</span>.cast(model);
  } <span class="keyword">catch</span> (err) {
    <span class="keyword">return</span> callback(err);
  }

  <span class="keyword">var</span> castQuery = <span class="keyword">this</span>._conditions;
  model.collection.distinct(field, castQuery, tick(callback));

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>castOps</h3><p>These operators require casting docs<br />to real Documents for Update operations.</p><pre><code class="javascript"><span class="keyword">var</span> castOps = {
    $push: <span class="number">1</span>
  , $pushAll: <span class="number">1</span>
  , $addToSet: <span class="number">1</span>
  , $set: <span class="number">1</span>
};</code></pre><h3>numberOps</h3><p>These operators should be cast to numbers instead<br />of their path schema type.</p><pre><code class="javascript"><span class="keyword">var</span> numberOps = {
    $pop: <span class="number">1</span>
  , $unset: <span class="number">1</span>
  , $inc: <span class="number">1</span>
}</code></pre><h3>update</h3><p>update</p>

<p>Casts the <code>doc</code> according to the model Schema and<br />sends an update command to MongoDB.</p>

<p><em>All paths passed that are not $atomic operations<br />will become $set ops so we retain backwards compatibility.</em></p>

<h2>Example</h2>

<p><code>Model.update({..}, { title: 'remove words' }, ...)</code></p>

<p>becomes</p>

<p><code>Model.update({..}, { $set: { title: 'remove words' }}, ...)</code></p>

<p><em>Passing an empty object <code>{}</code> as the doc will result<br />in a no-op. The update operation will be ignored and the<br />callback executed without sending the command to MongoDB so as<br />to prevent accidently overwritting the collection.</em></p><pre><code class="javascript">Query.prototype.update = <span class="function"><span class="keyword">function</span> <span class="title">update</span> <span class="params">(doc, callback)</span> {</span>
  <span class="keyword">this</span>.op = <span class="string">'update'</span>;
  <span class="keyword">this</span>._updateArg = doc;

  <span class="keyword">var</span> model = <span class="keyword">this</span>.model
    , options = <span class="keyword">this</span>._optionsForExec(model)
    , fn = <span class="string">'function'</span> == <span class="keyword">typeof</span> callback
    , castedQuery
    , castedDoc

  castedQuery = castQuery(<span class="keyword">this</span>);
  <span class="keyword">if</span> (castedQuery <span class="keyword">instanceof</span> Error) {
    <span class="keyword">if</span> (fn) {
      process.nextTick(callback.bind(<span class="literal">null</span>, castedQuery));
      <span class="keyword">return</span> <span class="keyword">this</span>;
    }
    <span class="keyword">throw</span> castedQuery;
  }

  castedDoc = castDoc(<span class="keyword">this</span>);
  <span class="keyword">if</span> (!castedDoc) {
    fn &amp;&amp; process.nextTick(callback.bind(<span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>));
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="keyword">if</span> (castedDoc <span class="keyword">instanceof</span> Error) {
    <span class="keyword">if</span> (fn) {
      process.nextTick(callback.bind(<span class="literal">null</span>, castedDoc));
      <span class="keyword">return</span> <span class="keyword">this</span>;
    }
    <span class="keyword">throw</span> castedDoc;
  }

  <span class="keyword">if</span> (!fn) {
    <span class="keyword">delete</span> options.safe;
  }

  model.collection.update(castedQuery, castedDoc, options, tick(callback));
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>_walkUpdatePath</h3><p>Walk each path of obj and cast its values<br />according to its schema.</p><pre><code class="javascript">Query.prototype._walkUpdatePath = <span class="function"><span class="keyword">function</span> <span class="title">_walkUpdatePath</span> <span class="params">(obj, op, pref)</span> {</span>
  <span class="keyword">var</span> strict = <span class="keyword">this</span>.model.schema.options.strict
    , prefix = pref ? pref + <span class="string">'.'</span> : <span class="string">''</span>
    , keys = Object.keys(obj)
    , i = keys.length
    , hasKeys = <span class="literal">false</span>
    , schema
    , key
    , val

  <span class="keyword">while</span> (i--) {
    key = keys[i];
    val = obj[key];

    <span class="keyword">if</span> (val &amp;&amp; <span class="string">'Object'</span> === val.constructor.name) {
      <span class="comment">// watch for embedded doc schemas</span>
      schema = <span class="keyword">this</span>._getSchema(prefix + key);
      <span class="keyword">if</span> (schema &amp;&amp; schema.caster &amp;&amp; op <span class="keyword">in</span> castOps) {
        <span class="comment">// embedded doc schema</span>

        <span class="keyword">if</span> (strict &amp;&amp; !schema) {
          <span class="comment">// path is not in our strict schema</span>
          <span class="keyword">if</span> (<span class="string">'throw'</span> == strict) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Field `'</span> + key + <span class="string">'` is not in schema.'</span>);
          } <span class="keyword">else</span> {
            <span class="comment">// ignore paths not specified in schema</span>
            <span class="keyword">delete</span> obj[key];
          }
        } <span class="keyword">else</span> {
          hasKeys = <span class="literal">true</span>;
          <span class="keyword">if</span> (<span class="string">'$each'</span> <span class="keyword">in</span> val) {
            obj[key] = {
                $each: <span class="keyword">this</span>._castUpdateVal(schema, val.$each, op)
            }
          } <span class="keyword">else</span> {
            obj[key] = <span class="keyword">this</span>._castUpdateVal(schema, val, op);
          }
        }
      } <span class="keyword">else</span> {
        hasKeys |= <span class="keyword">this</span>._walkUpdatePath(val, op, prefix + key);
      }
    } <span class="keyword">else</span> {
      schema = <span class="string">'$each'</span> === key
        ? <span class="keyword">this</span>._getSchema(pref)
        : <span class="keyword">this</span>._getSchema(prefix + key);

      <span class="keyword">var</span> skip = strict &amp;&amp;
                 !schema &amp;&amp;
                 !<span class="regexp">/real|nested/</span>.test(<span class="keyword">this</span>.model.schema.pathType(prefix + key));

      <span class="keyword">if</span> (skip) {
        <span class="keyword">if</span> (<span class="string">'throw'</span> == strict) {
          <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Field `'</span> + prefix + key + <span class="string">'` is not in schema.'</span>);
        } <span class="keyword">else</span> {
          <span class="keyword">delete</span> obj[key];
        }
      } <span class="keyword">else</span> {
        hasKeys = <span class="literal">true</span>;
        obj[key] = <span class="keyword">this</span>._castUpdateVal(schema, val, op, key);
      }
    }
  }
  <span class="keyword">return</span> hasKeys;
}</code></pre><h3>_castUpdateVal</h3><p>Casts <code>val</code> according to <code>schema</code> and atomic <code>op</code>.</p><pre><code class="javascript">Query.prototype._castUpdateVal = <span class="function"><span class="keyword">function</span> <span class="title">_castUpdateVal</span> <span class="params">(schema, val, op, $conditional)</span> {</span>
  <span class="keyword">if</span> (!schema) {
    <span class="comment">// non-existing schema path</span>
    <span class="keyword">return</span> op <span class="keyword">in</span> numberOps
      ? Number(val)
      : val
  }

  <span class="keyword">if</span> (schema.caster &amp;&amp; op <span class="keyword">in</span> castOps &amp;&amp;
    (<span class="string">'Object'</span> === val.constructor.name || Array.isArray(val))) {
    <span class="comment">// Cast values for ops that add data to MongoDB.</span>
    <span class="comment">// Ensures embedded documents get ObjectIds etc.</span>
    <span class="keyword">var</span> tmp = schema.cast(val);

    <span class="keyword">if</span> (Array.isArray(val)) {
      val = tmp;
    } <span class="keyword">else</span> {
      val = tmp[<span class="number">0</span>];
    }
  }

  <span class="keyword">if</span> (op <span class="keyword">in</span> numberOps) <span class="keyword">return</span> Number(val);
  <span class="keyword">if</span> (<span class="regexp">/^\$/</span>.test($conditional)) <span class="keyword">return</span> schema.castForQuery($conditional, val);
  <span class="keyword">return</span> schema.castForQuery(val)
}</code></pre><h3>_getSchema</h3><p>Finds the schema for <code>path</code>. This is different than<br />calling <code>schema.path</code> as it also resolves paths with<br />positional selectors (something.$.another.$.path).</p><pre><code class="javascript">Query.prototype._getSchema = <span class="function"><span class="keyword">function</span> <span class="title">_getSchema</span> <span class="params">(path)</span> {</span>
  <span class="keyword">var</span> schema = <span class="keyword">this</span>.model.schema
    , pathschema = schema.path(path);

  <span class="keyword">if</span> (pathschema)
    <span class="keyword">return</span> pathschema;

  <span class="comment">// look for arrays</span>
  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">search</span> <span class="params">(parts, schema)</span> {</span>
    <span class="keyword">var</span> p = parts.length + <span class="number">1</span>
      , foundschema
      , trypath

    <span class="keyword">while</span> (p--) {
      trypath = parts.slice(<span class="number">0</span>, p).join(<span class="string">'.'</span>);
      foundschema = schema.path(trypath);
      <span class="keyword">if</span> (foundschema) {
        <span class="keyword">if</span> (foundschema.caster) {

          <span class="comment">// array of Mixed?</span>
          <span class="keyword">if</span> (foundschema.caster <span class="keyword">instanceof</span> Types.Mixed) {
            <span class="keyword">return</span> foundschema.caster;
          }

          <span class="comment">// Now that we found the array, we need to check if there</span>
          <span class="comment">// are remaining document paths to look up for casting.</span>
          <span class="comment">// Also we need to handle array.$.path since schema.path</span>
          <span class="comment">// doesn't work for that.</span>
          <span class="keyword">if</span> (p !== parts.length) {
            <span class="keyword">if</span> (<span class="string">'$'</span> === parts[p]) {
              <span class="comment">// comments.$.comments.$.title</span>
              <span class="keyword">return</span> search(parts.slice(p+<span class="number">1</span>), foundschema.schema);
            } <span class="keyword">else</span> {
              <span class="comment">// this is the last path of the selector</span>
              <span class="keyword">return</span> search(parts.slice(p), foundschema.schema);
            }
          }
        }
        <span class="keyword">return</span> foundschema;
      }
    }
  })(path.split(<span class="string">'.'</span>), schema)
}</code></pre><h3>remove</h3><p>remove</p>

<p>Casts the query, sends the remove command to<br />mongodb where the query contents, and then<br />invokes a callback upon receiving the command<br />result.</p><pre><code class="javascript">Query.prototype.remove = <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> {</span>
  <span class="keyword">this</span>.op = <span class="string">'remove'</span>;

  <span class="keyword">var</span> model = <span class="keyword">this</span>.model
    , options = <span class="keyword">this</span>._optionsForExec(model)
    , cb = <span class="string">'function'</span> == <span class="keyword">typeof</span> callback

  <span class="keyword">try</span> {
    <span class="keyword">this</span>.cast(model);
  } <span class="keyword">catch</span> (err) {
    <span class="keyword">if</span> (cb) <span class="keyword">return</span> callback(err);
    <span class="keyword">throw</span> err;
  }

  <span class="keyword">if</span> (!cb) {
    <span class="keyword">delete</span> options.safe;
  }

  <span class="keyword">var</span> castQuery = <span class="keyword">this</span>._conditions;
  model.collection.remove(castQuery, options, tick(callback));
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>findOneAndUpdate</h3><p>findOneAndUpdate</p>

<p>Issues a mongodb findAndModify update command.</p>

<p>Finds a matching document, updates it according to the <code>update</code><br />arg, passing any <code>options</code>, and returns the found document<br />(if any) to the callback. The query executes immediately if<br /><code>callback</code> is passed else a Query object is returned.</p>

<h2>Available options</h2>

<p><code>new</code>: bool - true to return the modified document rather than the original. defaults to true<br />  <code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.<br />  <code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</p>

<h2>Examples</h2>

<pre><code>query.findOneAndUpdate(conditions, update, options, callback) // executes
query.findOneAndUpdate(conditions, update, options)  // returns Query
query.findOneAndUpdate(conditions, update, callback) // executes
query.findOneAndUpdate(conditions, update)           // returns Query
query.findOneAndUpdate(callback)                     // executes
query.findOneAndUpdate()                             // returns Query
</code></pre><pre><code class="javascript">Query.prototype.findOneAndUpdate = <span class="function"><span class="keyword">function</span> <span class="params">(query, doc, options, callback)</span> {</span>
  <span class="keyword">this</span>.op = <span class="string">'findOneAndUpdate'</span>;

  <span class="keyword">switch</span> (arguments.length) {
    <span class="keyword">case</span> <span class="number">3</span>:
      <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> options)
        callback = options, options = {};
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="number">2</span>:
      <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> doc) {
        callback = doc;
        doc = query;
        query = <span class="literal">undefined</span>;
      }
      options = <span class="literal">undefined</span>;
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="number">1</span>:
      <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> query) {
        callback = query;
        query = options = doc = <span class="literal">undefined</span>;
      } <span class="keyword">else</span> {
        doc = query;
        query = options = <span class="literal">undefined</span>;
      }
  }

  <span class="comment">// apply query</span>
  <span class="keyword">if</span> (query) {
    <span class="keyword">if</span> (<span class="string">'Object'</span> === query.constructor.name) {
      merge(<span class="keyword">this</span>._conditions, query);
    } <span class="keyword">else</span> <span class="keyword">if</span> (query <span class="keyword">instanceof</span> Query) {
      merge(<span class="keyword">this</span>._conditions, query._conditions);
    } <span class="keyword">else</span> <span class="keyword">if</span> (query <span class="keyword">instanceof</span> Document) {
      merge(<span class="keyword">this</span>._conditions, query.toObject());
    }
  }

  <span class="comment">// apply doc</span>
  <span class="keyword">if</span> (doc) {
    merge(<span class="keyword">this</span>._updateArg, doc);
  }

  <span class="comment">// apply options</span>
  options &amp;&amp; <span class="keyword">this</span>.setOptions(options);

  <span class="keyword">if</span> (!callback) <span class="keyword">return</span> <span class="keyword">this</span>;

  <span class="keyword">return</span> <span class="keyword">this</span>._findAndModify(<span class="string">'update'</span>, callback);
}</code></pre><h3>findOneAndRemove</h3><p>findOneAndRemove</p>

<p>Issues a mongodb findAndModify remove command.</p>

<p>Finds a matching document, removes it, passing the found<br />document (if any) to the callback. Executes immediately if <code>callback</code><br />is passed else a Query object is returned.</p>

<h2>Available options</h2>

<p><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</p>

<h2>Examples</h2>

<pre><code>A.where().findOneAndRemove(conditions, options, callback) // executes
A.where().findOneAndRemove(conditions, options)  // return Query
A.where().findOneAndRemove(conditions, callback) // executes
A.where().findOneAndRemove(conditions) // returns Query
A.where().findOneAndRemove(callback)   // executes
A.where().findOneAndRemove()           // returns Query
</code></pre><pre><code class="javascript">Query.prototype.findOneAndRemove = <span class="function"><span class="keyword">function</span> <span class="params">(conditions, options, callback)</span> {</span>
  <span class="keyword">this</span>.op = <span class="string">'findOneAndRemove'</span>;

  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> options) {
    callback = options;
    options = <span class="literal">undefined</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> conditions) {
    callback = conditions;
    conditions = <span class="literal">undefined</span>;
  }

  <span class="comment">// apply conditions</span>
  <span class="keyword">if</span> (conditions) {
    <span class="keyword">if</span> (<span class="string">'Object'</span> === conditions.constructor.name) {
      merge(<span class="keyword">this</span>._conditions, conditions);
    } <span class="keyword">else</span> <span class="keyword">if</span> (conditions <span class="keyword">instanceof</span> Query) {
      merge(<span class="keyword">this</span>._conditions, conditions._conditions);
    } <span class="keyword">else</span> <span class="keyword">if</span> (conditions <span class="keyword">instanceof</span> Document) {
      merge(<span class="keyword">this</span>._conditions, conditions.toObject());
    }
  }

  <span class="comment">// apply options</span>
  options &amp;&amp; <span class="keyword">this</span>.setOptions(options);

  <span class="keyword">if</span> (!callback) <span class="keyword">return</span> <span class="keyword">this</span>;

  <span class="keyword">return</span> <span class="keyword">this</span>._findAndModify(<span class="string">'remove'</span>, callback);
}</code></pre><h3>populate</h3><p>populate</p>

<p>Sets population options.</p><pre><code class="javascript">Query.prototype.populate = <span class="function"><span class="keyword">function</span> <span class="params">(path, fields, model, conditions, options)</span> {</span>
  <span class="keyword">if</span> (<span class="string">'string'</span> !== <span class="keyword">typeof</span> model) {
    options = conditions;
    conditions = model;
    model = <span class="literal">undefined</span>;
  }
  <span class="comment">// The order of fields/conditions args is opposite Model.find but</span>
  <span class="comment">// necessary to keep backward compatibility (fields could be</span>
  <span class="comment">// an array, string, or object literal).</span>
  <span class="keyword">this</span>.options.populate[path] =
    <span class="keyword">new</span> PopulateOptions(fields, conditions, options, model);

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>PopulateOptions</h3><p>Populate options constructor</p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">PopulateOptions</span> <span class="params">(fields, conditions, options, model)</span> {</span>
  <span class="keyword">this</span>.conditions = conditions;
  <span class="keyword">this</span>.fields = fields;
  <span class="keyword">this</span>.options = options;
  <span class="keyword">this</span>.model = model;
}

<span class="comment">// make it compatible with utils.clone</span>
PopulateOptions.prototype.constructor = Object;</code></pre><h3>stream</h3><p>stream</p>

<p>Returns a stream interface</p>

<h2>Example</h2>

<pre><code>Thing.find({ name: /^hello/ }).stream().pipe(res)
</code></pre><pre><code class="javascript">Query.prototype.stream = <span class="function"><span class="keyword">function</span> <span class="title">stream</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="keyword">new</span> QueryStream(<span class="keyword">this</span>);
}

<span class="comment">// helpers</span></code></pre><h3>exports</h3><p>Exports.</p><pre><code class="javascript">module.exports = Query;
module.exports.QueryStream = QueryStream;</code></pre></li><li><a href="/docs/index.html">lib/querystream.js</a><h3>QueryStream</h3><p>QueryStream</p>

<p>Returns a stream interface for the <code>query</code>.</p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">QueryStream</span> <span class="params">(query)</span> {</span>
  Stream.call(<span class="keyword">this</span>);

  <span class="keyword">this</span>.query = query;
  <span class="keyword">this</span>.readable = <span class="literal">true</span>;
  <span class="keyword">this</span>.paused = <span class="literal">false</span>;
  <span class="keyword">this</span>._cursor = <span class="literal">null</span>;
  <span class="keyword">this</span>._destroyed = <span class="literal">null</span>;
  <span class="keyword">this</span>._fields = <span class="literal">null</span>;
  <span class="keyword">this</span>._ticks = <span class="number">0</span>;
  <span class="keyword">this</span>._inline = T_INIT;

  <span class="comment">// give time to hook up events</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  process.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    self._init();
  });
}</code></pre><h3>__proto__</h3><p>Inherit from Stream</p><pre><code class="javascript">QueryStream.prototype.__proto__ = Stream.prototype;</code></pre><p>Flag stating whether or not this stream is readable.</p><pre><code class="javascript">QueryStream.prototype.readable;</code></pre><p>Flag stating whether or not this stream is paused.</p><pre><code class="javascript">QueryStream.prototype.paused;

<span class="comment">// trampoline flags</span>
<span class="keyword">var</span> T_INIT = <span class="number">0</span>;
<span class="keyword">var</span> T_IDLE = <span class="number">1</span>;
<span class="keyword">var</span> T_CONT = <span class="number">2</span>;</code></pre><h3>_init</h3><p>Initialize the query.</p><pre><code class="javascript">QueryStream.prototype._init = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>._destroyed) <span class="keyword">return</span>;

  <span class="keyword">var</span> query = <span class="keyword">this</span>.query
    , model = query.model
    , options = query._optionsForExec(model)
    , self = <span class="keyword">this</span>

  <span class="keyword">try</span> {
    query.cast(model);
  } <span class="keyword">catch</span> (err) {
    <span class="keyword">return</span> self.destroy(err);
  }

  self._fields = utils.clone(options.fields = query._fields);
  
  model.collection.find(query._conditions, options, <span class="function"><span class="keyword">function</span> <span class="params">(err, cursor)</span> {</span>
    <span class="keyword">if</span> (err) <span class="keyword">return</span> self.destroy(err);
    self._cursor = cursor;
    self._next();
  });
}</code></pre><h3>_onNextObject</h3><p>Handle each document as its returned from the cursor<br />transforming the raw <code>doc</code> from -native into a model<br />instance.</p><pre><code class="javascript">QueryStream.prototype._onNextObject = <span class="function"><span class="keyword">function</span> <span class="params">(err, doc)</span> {</span>
  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="keyword">this</span>.destroy(err);

  <span class="comment">// when doc is null we hit the end of the cursor</span>
  <span class="keyword">if</span> (!doc) {
    <span class="keyword">return</span> <span class="keyword">this</span>.destroy();
  }

  <span class="keyword">if</span>(<span class="keyword">this</span>.query.options &amp;&amp; <span class="keyword">this</span>.query.options.lean === <span class="literal">true</span>)  {
    <span class="keyword">this</span>.emit(<span class="string">'data'</span>, doc);
    <span class="keyword">this</span>._next();
    <span class="keyword">return</span>;
  } 
  <span class="keyword">var</span> instance = <span class="keyword">new</span> <span class="keyword">this</span>.query.model(<span class="literal">undefined</span>, <span class="keyword">this</span>._fields);

  <span class="comment">// skip _id for pre-init hooks</span>
  <span class="keyword">delete</span> instance._doc._id;

  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  instance.init(doc, <span class="keyword">this</span>.query, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    <span class="keyword">if</span> (err) <span class="keyword">return</span> self.destroy(err);
    self.emit(<span class="string">'data'</span>, instance);

    <span class="comment">// trampoline management</span>
    <span class="keyword">if</span> (T_IDLE === self._inline) {
      <span class="comment">// no longer in trampoline. restart it.</span>
      self._next();
    } <span class="keyword">else</span>
      <span class="comment">// in a trampoline. tell __next that its</span>
      <span class="comment">// ok to continue jumping.</span>
      self._inline = T_CONT;
  });
}</code></pre><h3>pause</h3><p>Pauses this stream.</p><pre><code class="javascript">QueryStream.prototype.pause = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">this</span>.paused = <span class="literal">true</span>;
}</code></pre><h3>resume</h3><p>Resumes this stream.</p><pre><code class="javascript">QueryStream.prototype.resume = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">this</span>.paused = <span class="literal">false</span>;
  <span class="keyword">this</span>._next();
}</code></pre><h3>destroy</h3><p>Destroys the stream, closing the underlying<br />cursor. No more events will be emitted.</p><pre><code class="javascript">QueryStream.prototype.destroy = <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>._destroyed) <span class="keyword">return</span>;
  <span class="keyword">this</span>._destroyed = <span class="literal">true</span>;
  <span class="keyword">this</span>.readable = <span class="literal">false</span>;

  <span class="keyword">if</span> (<span class="keyword">this</span>._cursor) {
    <span class="keyword">this</span>._cursor.close();
  }

  <span class="keyword">if</span> (err) {
    <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err);
  }

  <span class="keyword">this</span>.emit(<span class="string">'close'</span>);
}

<span class="comment">// TODO - maybe implement the -native raw option to pass binary?</span>
<span class="comment">//QueryStream.prototype.setEncoding = function () {</span>
<span class="comment">//}</span>

module.exports = exports = QueryStream;</code></pre></li><li><a href="/docs/index.html">lib/schema/array.js</a><h3>__proto__</h3><p>Inherits from SchemaType.</p><pre><code class="javascript">SchemaArray.prototype.__proto__ = SchemaType.prototype;</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = SchemaArray;</code></pre></li><li><a href="/docs/index.html">lib/schema/boolean.js</a><h3>__proto__</h3><p>Inherits from SchemaType.</p><pre><code class="javascript">SchemaBoolean.prototype.__proto__ = SchemaType.prototype;</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = SchemaBoolean;</code></pre></li><li><a href="/docs/index.html">lib/schema/buffer.js</a><h3>__proto__</h3><p>Inherits from SchemaType.</p><pre><code class="javascript">SchemaBuffer.prototype.__proto__ = SchemaType.prototype;</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = SchemaBuffer;</code></pre></li><li><a href="/docs/index.html">lib/schema/date.js</a><h3>__proto__</h3><p>Inherits from SchemaType.</p><pre><code class="javascript">SchemaDate.prototype.__proto__ = SchemaType.prototype;</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = SchemaDate;</code></pre></li><li><a href="/docs/index.html">lib/schema/documentarray.js</a><h3>__proto__</h3><p>Inherits from ArrayType.</p><pre><code class="javascript">DocumentArray.prototype.__proto__ = ArrayType.prototype;</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = DocumentArray;</code></pre></li><li><a href="/docs/index.html">lib/schema/index.js</a></li><li><a href="/docs/index.html">lib/schema/mixed.js</a><h3>__proto__</h3><p>Inherits from SchemaType.</p><pre><code class="javascript">Mixed.prototype.__proto__ = SchemaType.prototype;</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = Mixed;</code></pre></li><li><a href="/docs/index.html">lib/schema/number.js</a><h3>__proto__</h3><p>Inherits from SchemaType.</p><pre><code class="javascript">SchemaNumber.prototype.__proto__ = SchemaType.prototype;</code></pre><h3>min</h3><p>Sets a maximum number validator</p><pre><code class="javascript">SchemaNumber.prototype.min = <span class="function"><span class="keyword">function</span> <span class="params">(value, message)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.minValidator)
    <span class="keyword">this</span>.validators = <span class="keyword">this</span>.validators.filter(<span class="keyword">function</span>(v){
      <span class="keyword">return</span> v[<span class="number">1</span>] != <span class="string">'min'</span>;
    });
  <span class="keyword">if</span> (value != <span class="literal">null</span>)
    <span class="keyword">this</span>.validators.push([<span class="keyword">function</span>(v){
      <span class="keyword">return</span> v === <span class="literal">null</span> || v >= value;
    }, <span class="string">'min'</span>]);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>max</h3><p>Sets a maximum number validator</p><pre><code class="javascript">SchemaNumber.prototype.max = <span class="function"><span class="keyword">function</span> <span class="params">(value, message)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.maxValidator)
    <span class="keyword">this</span>.validators = <span class="keyword">this</span>.validators.filter(<span class="keyword">function</span>(v){
      <span class="keyword">return</span> v[<span class="number">1</span>] != <span class="string">'max'</span>;
    });
  <span class="keyword">if</span> (value != <span class="literal">null</span>)
    <span class="keyword">this</span>.validators.push([<span class="keyword">this</span>.maxValidator = <span class="keyword">function</span>(v){
      <span class="keyword">return</span> v === <span class="literal">null</span> || v &lt;= value;
    }, <span class="string">'max'</span>]);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = SchemaNumber;</code></pre></li><li><a href="/docs/index.html">lib/schema/objectid.js</a><h3>__proto__</h3><p>Inherits from SchemaType.</p><pre><code class="javascript">ObjectId.prototype.__proto__ = SchemaType.prototype;</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = ObjectId;</code></pre></li><li><a href="/docs/index.html">lib/schema/string.js</a><h3>__proto__</h3><p>Inherits from SchemaType.</p><pre><code class="javascript">SchemaString.prototype.__proto__ = SchemaType.prototype;</code></pre><h3>enum</h3><p>Adds enumeration values</p><pre><code class="javascript">SchemaString.prototype.enum = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> len = arguments.length;
  <span class="keyword">if</span> (!len || <span class="literal">undefined</span> === arguments[<span class="number">0</span>] || <span class="literal">false</span> === arguments[<span class="number">0</span>]) {
    <span class="keyword">if</span> (<span class="keyword">this</span>.enumValidator){
      <span class="keyword">this</span>.enumValidator = <span class="literal">false</span>;
      <span class="keyword">this</span>.validators = <span class="keyword">this</span>.validators.filter(<span class="keyword">function</span>(v){
        <span class="keyword">return</span> v[<span class="number">1</span>] != <span class="string">'enum'</span>;
      });
    }
    <span class="keyword">return</span>;
  }

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {
    <span class="keyword">if</span> (<span class="literal">undefined</span> !== arguments[i]) {
      <span class="keyword">this</span>.enumValues.push(<span class="keyword">this</span>.cast(arguments[i]));
    }
  }

  <span class="keyword">if</span> (!<span class="keyword">this</span>.enumValidator) {
    <span class="keyword">var</span> values = <span class="keyword">this</span>.enumValues;
    <span class="keyword">this</span>.enumValidator = <span class="keyword">function</span>(v){
      <span class="keyword">return</span> <span class="literal">undefined</span> === v || ~values.indexOf(v);
    };
    <span class="keyword">this</span>.validators.push([<span class="keyword">this</span>.enumValidator, <span class="string">'enum'</span>]);
  }
};</code></pre><h3>lowercase</h3><p>Adds a lowercase setter</p><pre><code class="javascript">SchemaString.prototype.lowercase = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.set(<span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
    <span class="keyword">return</span> v.toLowerCase();
  });
};</code></pre><h3>uppercase</h3><p>Adds an uppercase setter</p><pre><code class="javascript">SchemaString.prototype.uppercase = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.set(<span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
    <span class="keyword">return</span> v.toUpperCase();
  });
};</code></pre><h3>trim</h3><p>Adds a trim setter</p><pre><code class="javascript">SchemaString.prototype.trim = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.set(<span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
    <span class="keyword">return</span> v.trim();
  });
};</code></pre><h3>match</h3><p>Sets a regexp test</p><pre><code class="javascript">SchemaString.prototype.match = <span class="function"><span class="keyword">function</span> <span class="title">match</span> <span class="params">(regExp)</span> {</span>
  <span class="keyword">this</span>.validators.push([<span class="keyword">function</span>(v){
    <span class="keyword">return</span> <span class="literal">null</span> != v &amp;&amp; <span class="string">''</span> !== v
      ? regExp.test(v)
      : <span class="literal">true</span>
  }, <span class="string">'regexp'</span>]);
};</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = SchemaString;</code></pre></li><li><a href="/docs/index.html">lib/schema.js</a><h3>Schema</h3><p>Schema constructor.</p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Schema</span> <span class="params">(obj, options)</span> {</span>
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Schema))
    <span class="keyword">return</span> <span class="keyword">new</span> Schema(obj, options);

  <span class="keyword">this</span>.paths = {};
  <span class="keyword">this</span>.subpaths = {};
  <span class="keyword">this</span>.virtuals = {};
  <span class="keyword">this</span>.nested = {};
  <span class="keyword">this</span>.inherits = {};
  <span class="keyword">this</span>.callQueue = [];
  <span class="keyword">this</span>._indexes = [];
  <span class="keyword">this</span>.methods = {};
  <span class="keyword">this</span>.statics = {};
  <span class="keyword">this</span>.tree = {};
  <span class="keyword">this</span>._requiredpaths = <span class="literal">undefined</span>;

  <span class="comment">// set options</span>
  <span class="keyword">this</span>.options = utils.options({
      safe: <span class="literal">true</span>
    , strict: <span class="literal">true</span>
    , capped: <span class="literal">false</span> <span class="comment">// { size, max, autoIndexId }</span>
    , versionKey: <span class="string">'__v'</span>
    , minimize: <span class="literal">true</span>
    , autoIndex: <span class="literal">true</span>
  }, options);

  <span class="comment">// build paths</span>
  <span class="keyword">if</span> (obj) {
    <span class="keyword">this</span>.add(obj);
  }

  <span class="keyword">if</span> (!<span class="keyword">this</span>.paths[<span class="string">'_id'</span>] &amp;&amp; !<span class="keyword">this</span>.options.noId) {
    <span class="keyword">this</span>.add({ _id: {type: ObjectId, auto: <span class="literal">true</span>} });
  }

  <span class="keyword">if</span> (!<span class="keyword">this</span>.paths[<span class="string">'id'</span>] &amp;&amp; !<span class="keyword">this</span>.options.noVirtualId) {
    <span class="keyword">this</span>.virtual(<span class="string">'id'</span>).get(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
      <span class="keyword">if</span> (<span class="keyword">this</span>.__id) {
        <span class="keyword">return</span> <span class="keyword">this</span>.__id;
      }

      <span class="keyword">return</span> <span class="keyword">this</span>.__id = <span class="literal">null</span> == <span class="keyword">this</span>._id
        ? <span class="literal">null</span>
        : <span class="keyword">this</span>._id.toString();
    });
  }

  <span class="keyword">delete</span> <span class="keyword">this</span>.options.noVirtualId;

  <span class="comment">// versioning not directly added to schema b/c we only want</span>
  <span class="comment">// it in the top level document, not embedded ones.</span>
};</code></pre><h3>__proto__</h3><p>Inherit from EventEmitter.</p><pre><code class="javascript">Schema.prototype.__proto__ = EventEmitter.prototype;</code></pre><h3>add</h3><p>Sets the keys</p><pre><code class="javascript">Schema.prototype.add = <span class="function"><span class="keyword">function</span> <span class="title">add</span> <span class="params">(obj, prefix)</span> {</span>
  prefix = prefix || <span class="string">''</span>;
  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) {
    <span class="keyword">if</span> (<span class="literal">null</span> == obj[i]) {
      <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Invalid value for schema path `'</span>+ prefix + i +<span class="string">'`'</span>);
    }

    <span class="keyword">if</span> (obj[i].constructor.name == <span class="string">'Object'</span> &amp;&amp; (!obj[i].type || obj[i].type.type)) {
      <span class="keyword">if</span> (Object.keys(obj[i]).length) {
        <span class="comment">// nested object { last: { name: String }}</span>
        <span class="keyword">this</span>.nested[prefix + i] = <span class="literal">true</span>;
        <span class="keyword">this</span>.add(obj[i], prefix + i + <span class="string">'.'</span>);
      }
      <span class="keyword">else</span>
        <span class="keyword">this</span>.path(prefix + i, obj[i]); <span class="comment">// mixed type</span>
    } <span class="keyword">else</span>
      <span class="keyword">this</span>.path(prefix + i, obj[i]);
  }
};</code></pre><h3>reserved</h3><p>Reserved document keys.</p>

<p>Keys in this object are names that are rejected<br />in schema declarations b/c they conflict with<br />mongoose functionality.</p><pre><code class="javascript"><span class="keyword">var</span> reserved = Object.create(<span class="literal">null</span>);
reserved.on =
reserved.db =
reserved.init =
reserved.model =
reserved.isNew =
reserved.errors =
reserved.schema =
reserved.modelName =
reserved.collection = <span class="number">1</span>;</code></pre><h3>path</h3><p>Sets a path (if arity 2)<br />Gets a path (if arity 1)</p><pre><code class="javascript">Schema.prototype.path = <span class="function"><span class="keyword">function</span> <span class="params">(path, obj)</span> {</span>
  <span class="keyword">if</span> (obj == <span class="literal">undefined</span>) {
    <span class="keyword">if</span> (<span class="keyword">this</span>.paths[path]) <span class="keyword">return</span> <span class="keyword">this</span>.paths[path];
    <span class="keyword">if</span> (<span class="keyword">this</span>.subpaths[path]) <span class="keyword">return</span> <span class="keyword">this</span>.subpaths[path];

    <span class="comment">// subpaths?</span>
    <span class="keyword">return</span> <span class="regexp">/\.\d+\.?/</span>.test(path)
      ? getPositionalPath(<span class="keyword">this</span>, path)
      : <span class="literal">undefined</span>;
  }

  <span class="comment">// some path names conflict with document methods</span>
  <span class="keyword">if</span> (reserved[path]) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"`"</span> + path + <span class="string">"` may not be used as a schema pathname"</span>);
  }

  <span class="comment">// update the tree</span>
  <span class="keyword">var</span> subpaths = path.split(<span class="regexp">/\./</span>)
    , last = subpaths.pop()
    , branch = <span class="keyword">this</span>.tree;

  subpaths.forEach(<span class="keyword">function</span>(path) {
    <span class="keyword">if</span> (!branch[path]) branch[path] = {};
    branch = branch[path];
  });

  branch[last] = utils.clone(obj);

  <span class="keyword">this</span>.paths[path] = Schema.interpretAsType(path, obj);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>interpretAsType</h3><p>Converts -- e.g., Number, [SomeSchema],<br />{ type: String, enum: ['m', 'f'] } -- into<br />the appropriate Mongoose Type, which we use<br />later for casting, validation, etc.</p><pre><code class="javascript">Schema.interpretAsType = function (path, obj) {
  if (obj.constructor.name != 'Object')
    obj = { type: obj };

  // Get the type making sure to allow keys named "type"
  // and default to mixed if not specified.
  // { type: { type: String, default: 'freshcut' } }
  var type = obj.type &amp;&amp; !obj.type.type
    ? obj.type
    : {};

  if ('Object' == type.constructor.name || 'mixed' == type) {
    return new Types.Mixed(path, obj);
  }

  if (Array.isArray(type) || Array == type || 'array' == type) {
    // if it was specified through { type } look for `cast`
    var cast = (Array == type || 'array' == type)
      ? obj.cast
      : type[0];

    if (cast instanceof Schema) {
      return new Types.DocumentArray(path, cast, obj);
    }

    if ('string' == typeof cast) {
      cast = Types[cast.charAt(0).toUpperCase() + cast.substring(1)];
    } else if (cast &amp;&amp; !cast.type
                    &amp;&amp; 'Object' == cast.constructor.name
                    &amp;&amp; Object.keys(cast).length) {
      return new Types.DocumentArray(path, new Schema(cast), obj);
    }

    return new Types.Array(path, cast || Types.Mixed, obj);
  }

  var name = 'string' == typeof type
    ? type
    : type.name;

  if (name) {
    name = name.charAt(0).toUpperCase() + name.substring(1);
  }

  if (undefined == Types[name]) {
    throw new TypeError('Undefined type at `' + path +
        '`
  Did you try nesting Schemas? ' +
        'You can only nest using refs or arrays.');
  }

  return new Types[name](path, obj);
};</code></pre><h3>eachPath</h3><p>Iterates through the schema's paths, passing the path string and type object<br />to the callback.</p><pre><code class="javascript">Schema.prototype.eachPath = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
  <span class="keyword">var</span> keys = Object.keys(<span class="keyword">this</span>.paths)
    , len = keys.length;

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; ++i) {
    fn(keys[i], <span class="keyword">this</span>.paths[keys[i]]);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>requiredPaths</h3><p>Returns an Array of path strings that are required.</p><pre><code class="javascript">Schema.prototype.requiredPaths = <span class="function"><span class="keyword">function</span> <span class="title">requiredPaths</span> <span class="params">()</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>._requiredpaths) <span class="keyword">return</span> <span class="keyword">this</span>._requiredpaths;

  <span class="keyword">var</span> paths = Object.keys(<span class="keyword">this</span>.paths)
    , i = paths.length
    , ret = [];

  <span class="keyword">while</span> (i--) {
    <span class="keyword">var</span> path = paths[i];
    <span class="keyword">if</span> (<span class="keyword">this</span>.paths[path].isRequired) ret.push(path);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>._requiredpaths = ret;
}</code></pre><h3>pathType</h3><p>Given a path, returns whether it is a real, virtual,<br />nested, or ad-hoc/undefined path.</p><pre><code class="javascript">Schema.prototype.pathType = <span class="function"><span class="keyword">function</span> <span class="params">(path)</span> {</span>
  <span class="keyword">if</span> (path <span class="keyword">in</span> <span class="keyword">this</span>.paths) <span class="keyword">return</span> <span class="string">'real'</span>;
  <span class="keyword">if</span> (path <span class="keyword">in</span> <span class="keyword">this</span>.virtuals) <span class="keyword">return</span> <span class="string">'virtual'</span>;
  <span class="keyword">if</span> (path <span class="keyword">in</span> <span class="keyword">this</span>.nested) <span class="keyword">return</span> <span class="string">'nested'</span>;
  <span class="keyword">if</span> (path <span class="keyword">in</span> <span class="keyword">this</span>.subpaths) <span class="keyword">return</span> <span class="string">'real'</span>;

  <span class="keyword">if</span> (<span class="regexp">/\.\d+\.?/</span>.test(path) &amp;&amp; getPositionalPath(<span class="keyword">this</span>, path)) {
    <span class="keyword">return</span> <span class="string">'real'</span>;
  } <span class="keyword">else</span> {
    <span class="keyword">return</span> <span class="string">'adhocOrUndefined'</span>
  }
};

<span class="function"><span class="keyword">function</span> <span class="title">getPositionalPath</span> <span class="params">(self, path)</span> {</span>
  <span class="keyword">var</span> subpaths = path.split(<span class="regexp">/\.(\d+)\.?/</span>).filter(Boolean);
  <span class="keyword">if</span> (subpaths.length &lt; <span class="number">2</span>) {
    <span class="keyword">return</span> self.paths[subpaths[<span class="number">0</span>]];
  }

  <span class="keyword">var</span> val = self.path(subpaths[<span class="number">0</span>])
    , last = subpaths.length - <span class="number">1</span>
    , subpath;

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; subpaths.length; ++i) {
    <span class="keyword">var</span> subpath = subpaths[i];

    <span class="keyword">if</span> (i === last &amp;&amp;
        val &amp;&amp;
        !val.schema &amp;&amp;
        !<span class="regexp">/\D/</span>.test(subpath) &amp;&amp;
        val <span class="keyword">instanceof</span> Types.Array) {
      <span class="comment">// StringSchema, NumberSchema, etc</span>
      val = val.caster;
      <span class="keyword">continue</span>;
    }

    <span class="comment">// 'path.0.subpath'</span>
    <span class="keyword">if</span> (!<span class="regexp">/\D/</span>.test(subpath)) <span class="keyword">continue</span>;
    val = val.schema.path(subpath);
  }

  <span class="keyword">return</span> self.subpaths[path] = val;
}</code></pre><h3>pre</h3><p>Defines a pre for the document</p><pre><code class="javascript">Schema.prototype.pre = <span class="keyword">function</span>(){
  <span class="keyword">return</span> <span class="keyword">this</span>.queue(<span class="string">'pre'</span>, arguments);
};</code></pre><h3>post</h3><p>Defines a post for the document</p><pre><code class="javascript">Schema.prototype.post = <span class="keyword">function</span>(method, fn){
  <span class="keyword">return</span> <span class="keyword">this</span>.queue(<span class="string">'on'</span>, arguments);
};</code></pre><h3>plugin</h3><p>Registers a plugin for this schema</p><pre><code class="javascript">Schema.prototype.plugin = <span class="function"><span class="keyword">function</span> <span class="params">(fn, opts)</span> {</span>
  fn(<span class="keyword">this</span>, opts);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>method</h3><p>Adds a method</p><pre><code class="javascript">Schema.prototype.method = <span class="function"><span class="keyword">function</span> <span class="params">(name, fn)</span> {</span>
  <span class="keyword">if</span> (<span class="string">'string'</span> != <span class="keyword">typeof</span> name)
    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> name)
      <span class="keyword">this</span>.methods[i] = name[i];
  <span class="keyword">else</span>
    <span class="keyword">this</span>.methods[name] = fn;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>static</h3><p>Defines a static method</p><pre><code class="javascript">Schema.prototype.static = <span class="keyword">function</span>(name, fn) {
  <span class="keyword">if</span> (<span class="string">'string'</span> != <span class="keyword">typeof</span> name)
    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> name)
      <span class="keyword">this</span>.statics[i] = name[i];
  <span class="keyword">else</span>
    <span class="keyword">this</span>.statics[name] = fn;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>index</h3><p>Defines an index (most likely compound)</p>

<h2>Example</h2>

<p>schema.index({ first: 1, last: -1 })</p><pre><code class="javascript">Schema.prototype.index = <span class="function"><span class="keyword">function</span> <span class="params">(fields, options)</span> {</span>
  <span class="keyword">this</span>._indexes.push([fields, options || {}]);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>set</h3><p>Sets/gets an option</p><pre><code class="javascript">Schema.prototype.set = <span class="function"><span class="keyword">function</span> <span class="params">(key, value)</span> {</span>
  <span class="keyword">if</span> (arguments.length == <span class="number">1</span>)
    <span class="keyword">return</span> <span class="keyword">this</span>.options[key];
  <span class="keyword">this</span>.options[key] = value;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>indexes</h3><p>Compiles indexes from fields and schema-level indexes</p><pre><code class="javascript">Schema.prototype.indexes = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> indexes = []
    , seenSchemas = [];

  collectIndexes(<span class="keyword">this</span>);

  <span class="keyword">return</span> indexes;

  <span class="function"><span class="keyword">function</span> <span class="title">collectIndexes</span> <span class="params">(schema, prefix)</span> {</span>
    <span class="keyword">if</span> (~seenSchemas.indexOf(schema)) <span class="keyword">return</span>;
    seenSchemas.push(schema);

    <span class="keyword">var</span> index;
    <span class="keyword">var</span> paths = schema.paths;
    prefix = prefix || <span class="string">''</span>;

    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> paths) {
      <span class="keyword">if</span> (paths[i]) {
        <span class="keyword">if</span> (paths[i] <span class="keyword">instanceof</span> Types.DocumentArray) {
          collectIndexes(paths[i].schema, i + <span class="string">'.'</span>);
        } <span class="keyword">else</span> {
          index = paths[i]._index;

          <span class="keyword">if</span> (index !== <span class="literal">false</span> &amp;&amp; index !== <span class="literal">null</span>){
            <span class="keyword">var</span> field = {};
            field[prefix + i] = <span class="string">'2d'</span> === index ? index : <span class="number">1</span>;
            <span class="keyword">var</span> options = <span class="string">'Object'</span> === index.constructor.name ? index : {};
            <span class="keyword">if</span> (!(<span class="string">'background'</span> <span class="keyword">in</span> options)) options.background = <span class="literal">true</span>;
            indexes.push([field, options]);
          }
        }
      }
    }

    <span class="keyword">if</span> (prefix) {
      fixSubIndexPaths(schema, prefix);
    } <span class="keyword">else</span> {
      schema._indexes.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(index)</span> {</span>
        <span class="keyword">if</span> (!(<span class="string">'background'</span> <span class="keyword">in</span> index[<span class="number">1</span>])) index[<span class="number">1</span>].background = <span class="literal">true</span>;
      });
      indexes = indexes.concat(schema._indexes);
    }
  }</code></pre><h3>fixSubIndexPaths</h3><p>Checks for indexes added to subdocs using Schema.index().<br />These indexes need their paths prefixed properly.</p>

<p>schema._indexes = [ [indexObj, options], [indexObj, options] ..]</p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">fixSubIndexPaths</span> <span class="params">(schema, prefix)</span> {</span>
    <span class="keyword">var</span> subindexes = schema._indexes
      , len = subindexes.length
      , indexObj
      , newindex
      , klen
      , keys
      , key
      , i = <span class="number">0</span>
      , j

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) {
      indexObj = subindexes[i][<span class="number">0</span>];
      keys = Object.keys(indexObj);
      klen = keys.length;
      newindex = {};

      <span class="comment">// use forward iteration, order matters</span>
      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; klen; ++j) {
        key = keys[j];
        newindex[prefix + key] = indexObj[key];
      }

      indexes.push([newindex, subindexes[i][<span class="number">1</span>]]);
    }
  }

}</code></pre><h3>virtual</h3><p>Retrieves or creates the virtual type with the given name.</p><pre><code class="javascript">Schema.prototype.virtual = <span class="function"><span class="keyword">function</span> <span class="params">(name, options)</span> {</span>
  <span class="keyword">var</span> virtuals = <span class="keyword">this</span>.virtuals;
  <span class="keyword">var</span> parts = name.split(<span class="string">'.'</span>);
  <span class="keyword">return</span> virtuals[name] = parts.reduce(<span class="function"><span class="keyword">function</span> <span class="params">(mem, part, i)</span> {</span>
    mem[part] || (mem[part] = (i === parts.length-<span class="number">1</span>)
                            ? <span class="keyword">new</span> VirtualType(options)
                            : {});
    <span class="keyword">return</span> mem[part];
  }, <span class="keyword">this</span>.tree);
};</code></pre><h3>virtualpath</h3><p>Fetches the virtual type with the given name.<br />Should be distinct from virtual because virtual auto-defines a new VirtualType<br />if the path doesn't exist.</p><pre><code class="javascript">Schema.prototype.virtualpath = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.virtuals[name];
};

Schema.prototype.namedScope = <span class="function"><span class="keyword">function</span> <span class="params">(name, fn)</span> {</span>
  <span class="keyword">var</span> namedScopes = <span class="keyword">this</span>.namedScopes || (<span class="keyword">this</span>.namedScopes = <span class="keyword">new</span> NamedScope)
    , newScope = Object.create(namedScopes)
    , allScopes = namedScopes.scopesByName || (namedScopes.scopesByName = {});
  allScopes[name] = newScope;
  newScope.name = name;
  newScope.block = fn;
  newScope.query = <span class="keyword">new</span> Query();
  newScope.decorate(namedScopes, {
    block0: <span class="function"><span class="keyword">function</span> <span class="params">(block)</span> {</span>
      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        block.call(<span class="keyword">this</span>.query);
        <span class="keyword">return</span> <span class="keyword">this</span>;
      };
    },
    blockN: <span class="function"><span class="keyword">function</span> <span class="params">(block)</span> {</span>
      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        block.apply(<span class="keyword">this</span>.query, arguments);
        <span class="keyword">return</span> <span class="keyword">this</span>;
      };
    },
    basic: <span class="function"><span class="keyword">function</span> <span class="params">(query)</span> {</span>
      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">this</span>.query.find(query);
        <span class="keyword">return</span> <span class="keyword">this</span>;
      };
    }
  });
  <span class="keyword">return</span> newScope;
};</code></pre><h3>ObjectId</h3><p>ObjectId schema identifier. Not an actual ObjectId, only used for Schemas.</p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">ObjectId</span> <span class="params">()</span> {</span>
  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'This is an abstract interface. Its only purpose is to mark '</span>
                + <span class="string">'fields as ObjectId in the schema creation.'</span>);
}</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = exports = Schema;

<span class="comment">// require down here because of reference issues</span>
exports.Types = Types = require(<span class="string">'./schema/index'</span>);
NamedScope = require(<span class="string">'./namedscope'</span>)
Query = require(<span class="string">'./query'</span>);

exports.ObjectId = ObjectId;</code></pre></li><li><a href="/docs/index.html">lib/schemadefault.js</a><p>Default model for querying the system.profiles<br />collection (it only exists when profiling is<br />enabled.</p><pre><code class="javascript">exports[<span class="string">'system.profile'</span>] = <span class="keyword">new</span> Schema({
    ts: Date
  , info: String <span class="comment">// deprecated</span>
  , millis: Number
  , op: String
  , ns: String
  , query: Schema.Types.Mixed
  , updateobj: Schema.Types.Mixed
  , ntoreturn: Number
  , nreturned: Number
  , nscanned: Number
  , responseLength: Number
  , client: String
  , user: String
  , idhack: Boolean
  , scanAndOrder: Boolean
  , keyUpdates: Number
  , cursorid: Number
}, { noVirtualId: <span class="literal">true</span>, noId: <span class="literal">true</span> });</code></pre></li><li><a href="/docs/index.html">lib/schematype.js</a><h3>SchemaType</h3><p>SchemaType constructor</p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">SchemaType</span> <span class="params">(path, options, instance)</span> {</span>
  <span class="keyword">this</span>.path = path;
  <span class="keyword">this</span>.instance = instance;
  <span class="keyword">this</span>.validators = [];
  <span class="keyword">this</span>.setters = [];
  <span class="keyword">this</span>.getters = [];
  <span class="keyword">this</span>.options = options;
  <span class="keyword">this</span>._index = <span class="literal">null</span>;
  <span class="keyword">this</span>.selected;

  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> options) <span class="keyword">if</span> (<span class="keyword">this</span>[i] &amp;&amp; <span class="string">'function'</span> == <span class="keyword">typeof</span> <span class="keyword">this</span>[i]) {
    <span class="comment">// { unique: true, index: true }</span>
    <span class="keyword">if</span> (<span class="string">'index'</span> == i &amp;&amp; <span class="keyword">this</span>._index) <span class="keyword">continue</span>;

    <span class="keyword">var</span> opts = Array.isArray(options[i])
      ? options[i]
      : [options[i]];

    <span class="keyword">this</span>[i].apply(<span class="keyword">this</span>, opts);
  }
};</code></pre><h3>default</h3><p>Sets a default</p><pre><code class="javascript">SchemaType.prototype.<span class="keyword">default</span> = <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
  <span class="keyword">if</span> (<span class="number">1</span> === arguments.length) {
    <span class="keyword">this</span>.defaultValue = <span class="keyword">typeof</span> val === <span class="string">'function'</span>
      ? val
      : <span class="keyword">this</span>.cast(val);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (arguments.length > <span class="number">1</span>) {
    <span class="keyword">this</span>.defaultValue = utils.args(arguments);
  }
  <span class="keyword">return</span> <span class="keyword">this</span>.defaultValue;
};</code></pre><h3>index</h3><p>Sets index. It can be a boolean or a hash of options</p>

<h2>Example</h2>

<p>Schema.path('my.path').index(true);<br />   Schema.path('my.path').index({ unique: true });</p>

<p>"Direction doesn't matter for single key indexes"<br /><a href='http://www.mongodb.org/display/DOCS/Indexes#Indexes-CompoundKeysIndexes'>http://www.mongodb.org/display/DOCS/Indexes#Indexes-CompoundKeysIndexes</a></p><pre><code class="javascript">SchemaType.prototype.index = <span class="function"><span class="keyword">function</span> <span class="params">(index)</span> {</span>
  <span class="keyword">this</span>._index = index;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>set</h3><p>Adds a setter</p><pre><code class="javascript">SchemaType.prototype.set = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
  <span class="keyword">if</span> (<span class="string">'function'</span> != <span class="keyword">typeof</span> fn)
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'A setter must be a function.'</span>);
  <span class="keyword">this</span>.setters.push(fn);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>get</h3><p>Adds a getter</p><pre><code class="javascript">SchemaType.prototype.get = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
  <span class="keyword">if</span> (<span class="string">'function'</span> != <span class="keyword">typeof</span> fn)
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'A getter must be a function.'</span>);
  <span class="keyword">this</span>.getters.push(fn);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>validate</h3><h2>validate</h2>

<p>Adds validators.</p>

<h2>Examples</h2>

<pre><code>function validator () { ... }

var single = [validator, 'failed']
new Schema({ name: { type: String, validate: single }});

var many = [
    { validator: validator, msg: 'uh oh' }
  , { validator: fn, msg: 'failed' }
]
new Schema({ name: { type: String, validate: many }});
</code></pre><pre><code class="javascript">SchemaType.prototype.validate = <span class="function"><span class="keyword">function</span> <span class="params">(obj, error)</span> {</span>
  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> obj || obj &amp;&amp; <span class="string">'RegExp'</span> === obj.constructor.name) {
    <span class="keyword">this</span>.validators.push([obj, error]);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="keyword">var</span> i = arguments.length
    , arg

  <span class="keyword">while</span> (i--) {
    arg = arguments[i];
    <span class="keyword">this</span>.validators.push([arg.validator, arg.msg]);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>required</h3><p>Adds a required validator</p><pre><code class="javascript">SchemaType.prototype.required = <span class="function"><span class="keyword">function</span> <span class="params">(required)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;

  <span class="function"><span class="keyword">function</span> <span class="title">__checkRequired</span> <span class="params">(v)</span> {</span>
    <span class="comment">// in here, `this` refers to the validating document.</span>
    <span class="comment">// no validation when this path wasn't selected in the query.</span>
    <span class="keyword">if</span> (<span class="string">'isSelected'</span> <span class="keyword">in</span> <span class="keyword">this</span> &amp;&amp;
        !<span class="keyword">this</span>.isSelected(self.path) &amp;&amp;
        !<span class="keyword">this</span>.isModified(self.path)) <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">return</span> self.checkRequired(v);
  }

  <span class="keyword">if</span> (<span class="literal">false</span> === required) {
    <span class="keyword">this</span>.isRequired = <span class="literal">false</span>;
    <span class="keyword">this</span>.validators = <span class="keyword">this</span>.validators.filter(<span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
      <span class="keyword">return</span> v[<span class="number">0</span>].name !== <span class="string">'__checkRequired'</span>;
    });
  } <span class="keyword">else</span> {
    <span class="keyword">this</span>.isRequired = <span class="literal">true</span>;
    <span class="keyword">this</span>.validators.push([__checkRequired, <span class="string">'required'</span>]);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>select</h3><h2>select</h2>

<p>Set default select() behavior for this path. True if<br />this path should always be included in the results,<br />false if it should be excluded by default. This setting<br />can be overridden at the query level.</p>

<pre><code>T = db.model('T', new Schema({ x: { type: String, select: true }}));
T.find(..); // x will always be selected ..
// .. unless overridden;
T.find().select({ x: 0 }).exec();
</code></pre><pre><code class="javascript">SchemaType.prototype.select = <span class="function"><span class="keyword">function</span> <span class="title">select</span> <span class="params">(val)</span> {</span>
  <span class="keyword">this</span>.selected = !! val;
}</code></pre><h3>_isRef</h3><p>Determines if value is a valid Reference.</p><pre><code class="javascript">SchemaType._isRef = <span class="function"><span class="keyword">function</span> <span class="params">(self, value, init)</span> {</span>
  <span class="keyword">if</span> (init &amp;&amp; self.options &amp;&amp; self.options.ref) {
    <span class="keyword">if</span> (<span class="literal">null</span> == value) <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span> (value._id &amp;&amp; value._id.constructor.name === self.instance) <span class="keyword">return</span> <span class="literal">true</span>;
  }

  <span class="keyword">return</span> <span class="literal">false</span>;
}</code></pre><h3>__proto__</h3><p>Inherits from MongooseError</p><pre><code class="javascript">ValidatorError.prototype.__proto__ = MongooseError.prototype;</code></pre><h3>__proto__</h3><p>Inherits from MongooseError.</p><pre><code class="javascript">CastError.prototype.__proto__ = MongooseError.prototype;</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = exports = SchemaType;

exports.CastError = CastError;

exports.ValidatorError = ValidatorError;</code></pre></li><li><a href="/docs/index.html">lib/statemachine.js</a><h3>ctor</h3><p>StateMachine.ctor('state1', 'state2', ...)<br />A factory method for subclassing StateMachine.<br />The arguments are a list of states. For each state,<br />the constructor's prototype gets state transition<br />methods named after each state. These transition methods<br />place their path argument into the given state.</p><pre><code class="javascript">StateMachine.ctor = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> states = utils.args(arguments);

  <span class="keyword">var</span> ctor = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    StateMachine.apply(<span class="keyword">this</span>, arguments);
    <span class="keyword">this</span>.stateNames = states;

    <span class="keyword">var</span> i = states.length
      , state;

    <span class="keyword">while</span> (i--) {
      state = states[i];
      <span class="keyword">this</span>.states[state] = {};
    }
  };

  ctor.prototype.__proto__ = StateMachine.prototype;

  states.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(state)</span> {</span>
    <span class="comment">// Changes the `path`'s state to `state`.</span>
    ctor.prototype[state] = <span class="function"><span class="keyword">function</span> <span class="params">(path)</span> {</span>
      <span class="keyword">this</span>._changeState(path, state);
    }
  });

  <span class="keyword">return</span> ctor;
};</code></pre><h3>some</h3><p>Checks to see if at least one path is in the states passed in via <code>arguments</code><br />e.g., this.some('required', 'inited')</p><pre><code class="javascript">StateMachine.prototype.some = <span class="function"><span class="keyword">function</span> <span class="title">some</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  <span class="keyword">var</span> what = arguments.length ? arguments : <span class="keyword">this</span>.stateNames;
  <span class="keyword">return</span> Array.prototype.some.call(what, <span class="function"><span class="keyword">function</span> <span class="params">(state)</span> {</span>
    <span class="keyword">return</span> Object.keys(self.states[state]).length;
  });
}</code></pre><h3>forEach</h3><p>Iterates over the paths that belong to one of the parameter states.</p>

<h2>The function profile can look like</h2>

<p>this.forEach(state1, fn);         // iterates over all paths in state1<br />this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2<br />this.forEach(fn);                 // iterates over all paths in all states</p><pre><code class="javascript">StateMachine.prototype.forEach = <span class="function"><span class="keyword">function</span> <span class="title">forEach</span> <span class="params">()</span> {</span>
  <span class="keyword">this</span>.forEach = <span class="keyword">this</span>._iter(<span class="string">'forEach'</span>);
  <span class="keyword">return</span> <span class="keyword">this</span>.forEach.apply(<span class="keyword">this</span>, arguments);
}</code></pre><h3>map</h3><p>Maps over the paths that belong to one of the parameter states.</p>

<h2>The function profile can look like</h2>

<p>this.forEach(state1, fn);         // iterates over all paths in state1<br />this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2<br />this.forEach(fn);                 // iterates over all paths in all states</p><pre><code class="javascript">StateMachine.prototype.map = <span class="function"><span class="keyword">function</span> <span class="title">map</span> <span class="params">()</span> {</span>
  <span class="keyword">this</span>.map = <span class="keyword">this</span>._iter(<span class="string">'map'</span>);
  <span class="keyword">return</span> <span class="keyword">this</span>.map.apply(<span class="keyword">this</span>, arguments);
}</code></pre></li><li><a href="/docs/index.html">lib/types/array.js</a><h3>prototype</h3><p>Inherit from Array</p><pre><code class="javascript">MongooseArray.prototype = <span class="keyword">new</span> Array;</code></pre><h3>_markModified</h3><p>Marks this array as modified.<br />It is called during a nonAtomicPush, an atomic opteration,<br />or by an existing embedded document that is modified.</p>

<p>If it bubbles up from an embedded document change,<br />then it takes the following arguments (otherwise, takes<br />0 arguments)</p><pre><code class="javascript">MongooseArray.prototype._markModified = <span class="function"><span class="keyword">function</span> <span class="params">(embeddedDoc, embeddedPath)</span> {</span>
  <span class="keyword">var</span> parent = <span class="keyword">this</span>._parent
    , dirtyPath;

  <span class="keyword">if</span> (parent) {
    <span class="keyword">if</span> (arguments.length) {
      <span class="comment">// If an embedded doc bubbled up the change</span>
      dirtyPath = [<span class="keyword">this</span>._path, <span class="keyword">this</span>.indexOf(embeddedDoc), embeddedPath].join(<span class="string">'.'</span>);
    } <span class="keyword">else</span> {
      dirtyPath = <span class="keyword">this</span>._path;
    }
    parent.markModified(dirtyPath);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>hasAtomics</h3><p>Returns true if we have to perform atomics for this, and no normal<br />operations</p><pre><code class="javascript">MongooseArray.prototype.hasAtomics = <span class="function"><span class="keyword">function</span> <span class="title">hasAtomics</span> <span class="params">()</span> {</span>
  <span class="keyword">if</span> (!(<span class="keyword">this</span>._atomics &amp;&amp; <span class="string">'Object'</span> === <span class="keyword">this</span>._atomics.constructor.name)) {
    <span class="keyword">return</span> <span class="number">0</span>;
  }

  <span class="keyword">return</span> Object.keys(<span class="keyword">this</span>._atomics).length;
}</code></pre><h3>push</h3><p>Pushes item/s to the array atomically. Overrides Array#push</p><pre><code class="javascript">MongooseArray.prototype.push = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> values = [].map.call(arguments, <span class="keyword">this</span>._cast, <span class="keyword">this</span>)
    , ret = [].push.apply(<span class="keyword">this</span>, values);

  <span class="comment">// $pushAll might be fibbed (could be $push). But it makes it easier to</span>
  <span class="comment">// handle what could have been $push, $pushAll combos</span>
  <span class="keyword">this</span>._registerAtomic(<span class="string">'$pushAll'</span>, values);
  <span class="keyword">return</span> ret;
};</code></pre><h3>nonAtomicPush</h3><p>Pushes item/s to the array non-atomically</p><pre><code class="javascript">MongooseArray.prototype.nonAtomicPush = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> values = [].map.call(arguments, <span class="keyword">this</span>._cast, <span class="keyword">this</span>)
    , ret = [].push.apply(<span class="keyword">this</span>, values);
  <span class="keyword">this</span>._registerAtomic(<span class="string">'$set'</span>, <span class="keyword">this</span>);
  <span class="keyword">return</span> ret;
};</code></pre><p>Pops the array atomically</p>

<p>Only works once per doc.save(). Calling this mulitple<br />times on an array before saving sends the same command<br />as calling it once. See MongoDB docs.</p><pre><code class="javascript">MongooseArray.prototype.$pop = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">this</span>._registerAtomic(<span class="string">'$pop'</span>, <span class="number">1</span>);

  <span class="comment">// only allow popping once</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>._popped) <span class="keyword">return</span>;
  <span class="keyword">this</span>._popped = <span class="literal">true</span>;

  <span class="keyword">return</span> [].pop.call(<span class="keyword">this</span>);
};</code></pre><h3>pop</h3><p>Non-atomically pops the array.</p>

<p>Note: marks the <em>entire</em> array as modified which<br />will pass the entire thing to $set potentially<br />overwritting any changes that happen between<br />when you retrieved the object and when you save<br />it.</p><pre><code class="javascript">MongooseArray.prototype.pop = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> ret = [].pop.call(<span class="keyword">this</span>);
  <span class="keyword">this</span>._registerAtomic(<span class="string">'$set'</span>, <span class="keyword">this</span>);
  <span class="keyword">return</span> ret;
};</code></pre><p>Atomically shifts the array.</p>

<p>Only works once per doc.save(). Calling this mulitple<br />times on an array before saving sends the same command<br />as calling it once. See MongoDB docs.</p><pre><code class="javascript">MongooseArray.prototype.$shift = <span class="function"><span class="keyword">function</span> <span class="title">$shift</span> <span class="params">()</span> {</span>
  <span class="keyword">this</span>._registerAtomic(<span class="string">'$pop'</span>, -<span class="number">1</span>);

  <span class="comment">// only allow shifting once</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>._shifted) <span class="keyword">return</span>;
  <span class="keyword">this</span>._shifted = <span class="literal">true</span>;

  <span class="keyword">return</span> [].shift.call(<span class="keyword">this</span>);
};</code></pre><h3>shift</h3><p>shift</p>

<p>Non-atomically shifts the array.</p>

<p>Note: marks the <em>entire</em> array as modified which<br />will pass the entire thing to $set potentially<br />overwritting any changes that happen between<br />when you retrieved the object and when you save<br />it.</p><pre><code class="javascript">MongooseArray.prototype.shift = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> ret = [].shift.call(<span class="keyword">this</span>);
  <span class="keyword">this</span>._registerAtomic(<span class="string">'$set'</span>, <span class="keyword">this</span>);
  <span class="keyword">return</span> ret;
};</code></pre><h3>remove</h3><p>remove</p>

<p>Removes items from an array atomically</p>

<h2>Examples</h2>

<pre><code>doc.array.remove(ObjectId)
doc.array.remove('tag 1', 'tag 2')
</code></pre><pre><code class="javascript">MongooseArray.prototype.remove = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> args = [].map.call(arguments, <span class="keyword">this</span>._cast, <span class="keyword">this</span>);
  <span class="keyword">if</span> (args.length == <span class="number">1</span>)
    <span class="keyword">this</span>.pull(args[<span class="number">0</span>]);
  <span class="keyword">else</span>
    <span class="keyword">this</span>.pull.apply(<span class="keyword">this</span>, args);
  <span class="keyword">return</span> args;
};</code></pre><h3>pull</h3><p>Pulls from the array</p><pre><code class="javascript">MongooseArray.prototype.pull = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> values = [].map.call(arguments, <span class="keyword">this</span>._cast, <span class="keyword">this</span>)
    , cur = <span class="keyword">this</span>._parent.get(<span class="keyword">this</span>._path)
    , i = cur.length
    , mem;

  <span class="keyword">while</span> (i--) {
    mem = cur[i];
    <span class="keyword">if</span> (mem <span class="keyword">instanceof</span> EmbeddedDocument) {
      <span class="keyword">if</span> (values.some(<span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span> <span class="keyword">return</span> v.equals(mem); } )) {
        [].splice.call(cur, i, <span class="number">1</span>);
      }
    } <span class="keyword">else</span> <span class="keyword">if</span> (~cur.indexOf.call(values, mem)) {
      [].splice.call(cur, i, <span class="number">1</span>);
    }
  }

  <span class="keyword">if</span> (values[<span class="number">0</span>] <span class="keyword">instanceof</span> EmbeddedDocument) {
    <span class="keyword">this</span>._registerAtomic(<span class="string">'$pullDocs'</span>, values.map( <span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span> <span class="keyword">return</span> v._id; } ));
  } <span class="keyword">else</span> {
    <span class="keyword">this</span>._registerAtomic(<span class="string">'$pullAll'</span>, values);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>splice</h3><p>Splices the array.</p>

<p>Note: marks the <em>entire</em> array as modified which<br />will pass the entire thing to $set potentially<br />overwritting any changes that happen on the db between<br />when you retrieved the object and when you save<br />it.</p><pre><code class="javascript">MongooseArray.prototype.splice = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">if</span> (arguments.length) {
    <span class="keyword">var</span> ret = [].splice.apply(<span class="keyword">this</span>, arguments);
    <span class="keyword">this</span>._registerAtomic(<span class="string">'$set'</span>, <span class="keyword">this</span>);
  }
  <span class="keyword">return</span> ret;
};</code></pre><h3>unshift</h3><p>Non-atomically unshifts onto the array.</p>

<p>Note: marks the <em>entire</em> array as modified which<br />will pass the entire thing to $set potentially<br />overwritting any changes that happen between<br />when you retrieved the object and when you save<br />it.</p><pre><code class="javascript">MongooseArray.prototype.unshift = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> values = [].map.call(arguments, <span class="keyword">this</span>._cast, <span class="keyword">this</span>);
  [].unshift.apply(<span class="keyword">this</span>, values);
  <span class="keyword">this</span>._registerAtomic(<span class="string">'$set'</span>, <span class="keyword">this</span>);
  <span class="keyword">return</span> <span class="keyword">this</span>.length;
};</code></pre><h3>sort</h3><p>sort</p><pre><code class="javascript">MongooseArray.prototype.sort = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> ret = [].sort.apply(<span class="keyword">this</span>, arguments);
  <span class="keyword">this</span>._registerAtomic(<span class="string">'$set'</span>, <span class="keyword">this</span>);
  <span class="keyword">return</span> ret;
}</code></pre><h3>addToSet</h3><p>Adds values to the array if not already present.</p><pre><code class="javascript">MongooseArray.prototype.addToSet = <span class="function"><span class="keyword">function</span> <span class="title">addToSet</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> values = [].map.call(arguments, <span class="keyword">this</span>._cast, <span class="keyword">this</span>)
    , added = []
    , type = values[<span class="number">0</span>] <span class="keyword">instanceof</span> EmbeddedDocument ? <span class="string">'doc'</span> :
             values[<span class="number">0</span>] <span class="keyword">instanceof</span> Date ? <span class="string">'date'</span> :
             <span class="string">''</span>;

  values.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
    <span class="keyword">var</span> found;
    <span class="keyword">switch</span> (type) {
      <span class="keyword">case</span> <span class="string">'doc'</span>:
        found = <span class="keyword">this</span>.some(<span class="keyword">function</span>(doc){ <span class="keyword">return</span> doc.equals(v) });
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'date'</span>:
        <span class="keyword">var</span> val = +v;
        found = <span class="keyword">this</span>.some(<span class="keyword">function</span>(d){ <span class="keyword">return</span> +d === val });
        <span class="keyword">break</span>;
      <span class="keyword">default</span>:
        found = ~<span class="keyword">this</span>.indexOf(v);
    }

    <span class="keyword">if</span> (!found) {
      [].push.call(<span class="keyword">this</span>, v);
      <span class="keyword">this</span>._registerAtomic(<span class="string">'$addToSet'</span>, v);
      [].push.call(added, v);
    }
  }, <span class="keyword">this</span>);

  <span class="keyword">return</span> added;
};</code></pre><h3>toObject</h3><p>Returns an native js Array</p><pre><code class="javascript">MongooseArray.prototype.toObject = <span class="function"><span class="keyword">function</span> <span class="params">(options)</span> {</span>
  <span class="keyword">if</span> (options &amp;&amp; options.depopulate &amp;&amp; <span class="keyword">this</span>[<span class="number">0</span>] <span class="keyword">instanceof</span> Document) {
    <span class="keyword">return</span> <span class="keyword">this</span>.map(<span class="function"><span class="keyword">function</span> <span class="params">(doc)</span> {</span>
      <span class="keyword">return</span> doc._id;
    });
  }

  <span class="comment">// return this.slice()?</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.map(<span class="function"><span class="keyword">function</span> <span class="params">(doc)</span> {</span>
    <span class="keyword">return</span> doc;
  });
};</code></pre><h3>inspect</h3><p>Helper for console.log</p><pre><code class="javascript">MongooseArray.prototype.inspect = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="string">'['</span> + <span class="keyword">this</span>.map(<span class="function"><span class="keyword">function</span> <span class="params">(doc)</span> {</span>
    <span class="keyword">return</span> <span class="string">' '</span> + doc;
  }) + <span class="string">' ]'</span>;
};</code></pre><h3>indexOf</h3><p>Return the index of <code>obj</code> or <code>-1.</code></p><pre><code class="javascript">MongooseArray.prototype.indexOf = <span class="function"><span class="keyword">function</span> <span class="title">indexOf</span> <span class="params">(obj)</span> {</span>
  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ObjectId) obj = obj.toString();
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.length; i &lt; len; ++i) {
    <span class="keyword">if</span> (obj == <span class="keyword">this</span>[i])
      <span class="keyword">return</span> i;
  }
  <span class="keyword">return</span> -<span class="number">1</span>;
};</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = exports = MongooseArray;</code></pre></li><li><a href="/docs/index.html">lib/types/buffer.js</a><h3>prototype</h3><p>Inherit from Buffer.</p><pre><code class="javascript">MongooseBuffer.prototype = <span class="keyword">new</span> Buffer(<span class="number">0</span>);</code></pre><h3>_markModified</h3><p>Marks this buffer as modified.</p><pre><code class="javascript">MongooseBuffer.prototype._markModified = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> parent = <span class="keyword">this</span>._parent;

  <span class="keyword">if</span> (parent) {
    parent.markModified(<span class="keyword">this</span>._path);
  }
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>write</h3><p>Writes the buffer.</p><pre><code class="javascript">MongooseBuffer.prototype.write = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> written = Buffer.prototype.write.apply(<span class="keyword">this</span>, arguments);

  <span class="keyword">if</span> (written > <span class="number">0</span>) {
    <span class="keyword">this</span>._markModified();
  }

  <span class="keyword">return</span> written;
};</code></pre><h3>copy</h3><p>Copy the buffer.</p>

<p>Note: Buffer#copy will not mark target as modified so<br />you must copy from a MongooseBuffer for it to work<br />as expected.</p>

<p>Work around since copy modifies the target, not this.</p><pre><code class="javascript">MongooseBuffer.prototype.copy = <span class="function"><span class="keyword">function</span> <span class="params">(target)</span> {</span>
  <span class="keyword">var</span> ret = Buffer.prototype.copy.apply(<span class="keyword">this</span>, arguments);

  <span class="keyword">if</span> (target <span class="keyword">instanceof</span> MongooseBuffer) {
    target._markModified();
  }

  <span class="keyword">return</span> ret;
};</code></pre><p>Compile other Buffer methods marking this buffer as modified.</p><pre><code class="javascript">;(
<span class="comment">// node &lt; 0.5</span>
<span class="string">'writeUInt8 writeUInt16 writeUInt32 writeInt8 writeInt16 writeInt32 '</span> +
<span class="string">'writeFloat writeDouble fill '</span> +
<span class="string">'utf8Write binaryWrite asciiWrite set '</span> +

<span class="comment">// node >= 0.5</span>
<span class="string">'writeUInt16LE writeUInt16BE writeUInt32LE writeUInt32BE '</span> +
<span class="string">'writeInt16LE writeInt16BE writeInt32LE writeInt32BE '</span> +
<span class="string">'writeFloatLE writeFloatBE writeDoubleLE writeDoubleBE'</span>
).split(<span class="string">' '</span>).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(method)</span> {</span>
  <span class="keyword">if</span> (!Buffer.prototype[method]) <span class="keyword">return</span>;
  MongooseBuffer.prototype[method] = <span class="keyword">new</span> Function(
    <span class="string">'var ret = Buffer.prototype.'</span>+method+<span class="string">'.apply(this, arguments);'</span> +
    <span class="string">'this._markModified();'</span> +
    <span class="string">'return ret;'</span>
  )
});</code></pre><h3>toObject</h3><p>Returns a Binary.</p><pre><code class="javascript">MongooseBuffer.prototype.toObject = <span class="function"><span class="keyword">function</span> <span class="params">(subtype)</span> {</span>
  subtype = <span class="keyword">typeof</span> subtype !== <span class="string">'undefined'</span> ? subtype : <span class="number">0x00</span>
  <span class="keyword">return</span> <span class="keyword">new</span> Binary(<span class="keyword">this</span>, subtype);
};</code></pre><h3>Binary</h3><p>Module exports.</p><pre><code class="javascript">MongooseBuffer.Binary = Binary;

module.exports = MongooseBuffer;</code></pre></li><li><a href="/docs/index.html">lib/types/documentarray.js</a><h3>__proto__</h3><p>Inherits from MongooseArray</p><pre><code class="javascript">MongooseDocumentArray.prototype.__proto__ = MongooseArray.prototype;</code></pre><h3>id</h3><p>Filters items by id</p><pre><code class="javascript">MongooseDocumentArray.prototype.id = <span class="function"><span class="keyword">function</span> <span class="params">(id)</span> {</span>
  <span class="keyword">var</span> casted
    , _id;

  <span class="keyword">try</span> {
    casted = ObjectId.toString(ObjectIdSchema.prototype.cast.call({}, id));
  } <span class="keyword">catch</span> (e) {
    casted = <span class="literal">null</span>;
  }

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="keyword">this</span>.length; i &lt; l; i++) {
    _id = <span class="keyword">this</span>[i].get(<span class="string">'_id'</span>);
    <span class="keyword">if</span> (!(_id <span class="keyword">instanceof</span> ObjectId)) {
      <span class="keyword">if</span> (String(id) == _id)
        <span class="keyword">return</span> <span class="keyword">this</span>[i];
    } <span class="keyword">else</span> {
      <span class="keyword">if</span> (casted == _id)
        <span class="keyword">return</span> <span class="keyword">this</span>[i];
    }
  }

  <span class="keyword">return</span> <span class="literal">null</span>;
};</code></pre><h3>toObject</h3><p>Returns an Array and converts any Document<br />members toObject.</p><pre><code class="javascript">MongooseDocumentArray.prototype.toObject = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.map(<span class="function"><span class="keyword">function</span> <span class="params">(doc)</span> {</span>
    <span class="keyword">return</span> doc &amp;&amp; doc.toObject() || <span class="literal">null</span>;
  });
};</code></pre><h3>inspect</h3><p>Helper for console.log</p><pre><code class="javascript">MongooseDocumentArray.prototype.inspect = function () {
  return '[' + this.map(function (doc) {
    if (doc) {
      return doc.inspect
        ? doc.inspect()
        : util.inspect(doc)
    }
    return 'null'
  }).join('
') + ']';
};</code></pre><h3>create</h3><p>create</p>

<p>Creates a subdocument casted to this schema.</p><pre><code class="javascript">MongooseDocumentArray.prototype.create = <span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>._schema.casterConstructor(v);
}</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = MongooseDocumentArray;</code></pre></li><li><a href="/docs/index.html">lib/types/embedded.js</a><h3>__proto__</h3><p>Inherit from Document</p><pre><code class="javascript">EmbeddedDocument.prototype.__proto__ = Document.prototype;</code></pre><h3>save</h3><p>Noop. Does not actually save the doc to the db.</p><pre><code class="javascript">EmbeddedDocument.prototype.save = <span class="keyword">function</span>(fn) {
  <span class="keyword">if</span> (fn)
    fn(<span class="literal">null</span>);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>remove</h3><p>Remove the subdocument</p><pre><code class="javascript">EmbeddedDocument.prototype.remove = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
  <span class="keyword">if</span> (!<span class="keyword">this</span>.__parentArray) <span class="keyword">return</span> <span class="keyword">this</span>;

  <span class="keyword">var</span> _id;
  <span class="keyword">if</span> (!<span class="keyword">this</span>.willRemove) {
    _id = <span class="keyword">this</span>._doc._id;
    <span class="keyword">if</span> (!_id) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'For your own good, Mongoose does not know '</span> + 
                      <span class="string">'how to remove an EmbeddedDocument that has no _id'</span>);
    }
    <span class="keyword">this</span>.__parentArray.pull({ _id: _id });
    <span class="keyword">this</span>.willRemove = <span class="literal">true</span>;
  }

  <span class="keyword">if</span> (fn)
    fn(<span class="literal">null</span>);

  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>inspect</h3><p>Helper for console.log</p><pre><code class="javascript">EmbeddedDocument.prototype.inspect = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> inspect(<span class="keyword">this</span>.toObject());
};</code></pre><h3>invalidate</h3><p>Invalidate</p>

<p>Report accurate embedded paths for invalidation.</p><pre><code class="javascript">EmbeddedDocument.prototype.invalidate = <span class="function"><span class="keyword">function</span> <span class="params">(path, err)</span> {</span>
  <span class="keyword">if</span> (!<span class="keyword">this</span>.__parent) <span class="keyword">return</span> <span class="literal">false</span>;
  <span class="keyword">var</span> index = <span class="keyword">this</span>.__parentArray.indexOf(<span class="keyword">this</span>);
  <span class="keyword">var</span> parentPath = <span class="keyword">this</span>.__parentArray._path;
  <span class="keyword">var</span> fullPath = [parentPath, index, path].join(<span class="string">'.'</span>);
  <span class="keyword">this</span>.__parent.invalidate(fullPath, err);
  <span class="keyword">return</span> <span class="literal">true</span>;
}</code></pre><h3>exports</h3><p>Module exports.</p><pre><code class="javascript">module.exports = EmbeddedDocument;</code></pre></li><li><a href="/docs/index.html">lib/types/index.js</a></li><li><a href="/docs/index.html">lib/types/objectid.js</a></li><li><a href="/docs/index.html">lib/utils.js</a><h3>rules</h3><p>Pluralization rules.</p><pre><code class="javascript"><span class="keyword">var</span> rules = [
  [<span class="regexp">/(m)an$/gi</span>, <span class="string">'$1en'</span>],
  [<span class="regexp">/(pe)rson$/gi</span>, <span class="string">'$1ople'</span>],
  [<span class="regexp">/(child)$/gi</span>, <span class="string">'$1ren'</span>],
  [<span class="regexp">/^(ox)$/gi</span>, <span class="string">'$1en'</span>],
  [<span class="regexp">/(ax|test)is$/gi</span>, <span class="string">'$1es'</span>],
  [<span class="regexp">/(octop|vir)us$/gi</span>, <span class="string">'$1i'</span>],
  [<span class="regexp">/(alias|status)$/gi</span>, <span class="string">'$1es'</span>],
  [<span class="regexp">/(bu)s$/gi</span>, <span class="string">'$1ses'</span>],
  [<span class="regexp">/(buffal|tomat|potat)o$/gi</span>, <span class="string">'$1oes'</span>],
  [<span class="regexp">/([ti])um$/gi</span>, <span class="string">'$1a'</span>],
  [<span class="regexp">/sis$/gi</span>, <span class="string">'ses'</span>],
  [<span class="regexp">/(?:([^f])fe|([lr])f)$/gi</span>, <span class="string">'$1$2ves'</span>],
  [<span class="regexp">/(hive)$/gi</span>, <span class="string">'$1s'</span>],
  [<span class="regexp">/([^aeiouy]|qu)y$/gi</span>, <span class="string">'$1ies'</span>],
  [<span class="regexp">/(x|ch|ss|sh)$/gi</span>, <span class="string">'$1es'</span>],
  [<span class="regexp">/(matr|vert|ind)ix|ex$/gi</span>, <span class="string">'$1ices'</span>],
  [<span class="regexp">/([m|l])ouse$/gi</span>, <span class="string">'$1ice'</span>],
  [<span class="regexp">/(quiz)$/gi</span>, <span class="string">'$1zes'</span>],
  [<span class="regexp">/s$/gi</span>, <span class="string">'s'</span>],
  [<span class="regexp">/$/gi</span>, <span class="string">'s'</span>]
];</code></pre><h3>uncountables</h3><p>Uncountable words.</p><pre><code class="javascript"><span class="keyword">var</span> uncountables = [
  <span class="string">'advice'</span>,
  <span class="string">'energy'</span>,
  <span class="string">'excretion'</span>,
  <span class="string">'digestion'</span>,
  <span class="string">'cooperation'</span>,
  <span class="string">'health'</span>,
  <span class="string">'justice'</span>,
  <span class="string">'labour'</span>,
  <span class="string">'machinery'</span>,
  <span class="string">'equipment'</span>,
  <span class="string">'information'</span>,
  <span class="string">'pollution'</span>,
  <span class="string">'sewage'</span>,
  <span class="string">'paper'</span>,
  <span class="string">'money'</span>,
  <span class="string">'species'</span>,
  <span class="string">'series'</span>,
  <span class="string">'rain'</span>,
  <span class="string">'rice'</span>,
  <span class="string">'fish'</span>,
  <span class="string">'sheep'</span>,
  <span class="string">'moose'</span>,
  <span class="string">'deer'</span>,
  <span class="string">'news'</span>
];</code></pre><h3>__proto__</h3><p>Inherit from EventEmitter.</p><pre><code class="javascript">Events.prototype.__proto__ = EventEmitter.prototype;</code></pre><h3>once</h3><p>Add <code>once</code>.</p><pre><code class="javascript">Events.prototype.once = <span class="function"><span class="keyword">function</span> <span class="params">(type, listener)</span> {</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    self.on(type, <span class="function"><span class="keyword">function</span> <span class="title">g</span><span class="params">()</span>{</span>
      self.removeListener(type, g);
      listener.apply(<span class="keyword">this</span>, arguments);
    });
  };

}

exports.EventEmitter = Events;

<span class="comment">// Modified from node/lib/assert.js</span>
exports.deepEqual = <span class="function"><span class="keyword">function</span> <span class="title">deepEqual</span> <span class="params">(a, b)</span> {</span>
  <span class="keyword">if</span> (a === b) <span class="keyword">return</span> <span class="literal">true</span>;

  <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Date &amp;&amp; b <span class="keyword">instanceof</span> Date)
    <span class="keyword">return</span> a.getTime() === b.getTime();

  <span class="keyword">if</span> (a <span class="keyword">instanceof</span> ObjectId &amp;&amp; b <span class="keyword">instanceof</span> ObjectId) {
    <span class="keyword">return</span> a.toString() === b.toString();
  }

  <span class="keyword">if</span> (<span class="keyword">typeof</span> a !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> b !== <span class="string">'object'</span>)
    <span class="keyword">return</span> a == b;

  <span class="keyword">if</span> (a === <span class="literal">null</span> || b === <span class="literal">null</span> || a === <span class="literal">undefined</span> || b === <span class="literal">undefined</span>)
    <span class="keyword">return</span> <span class="literal">false</span>

  <span class="keyword">if</span> (a.prototype !== b.prototype) <span class="keyword">return</span> <span class="literal">false</span>;

  <span class="comment">// Handle MongooseNumbers</span>
  <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Number &amp;&amp; b <span class="keyword">instanceof</span> Number) {
    <span class="keyword">return</span> a.valueOf() === b.valueOf();
  }

  <span class="keyword">if</span> (Buffer.isBuffer(a)) {
    <span class="keyword">if</span> (!Buffer.isBuffer(b)) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span> (a.length !== b.length) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = a.length; i &lt; len; ++i) {
      <span class="keyword">if</span> (a[i] !== b[i]) <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
  }

  <span class="keyword">if</span> (isMongooseObject(a)) a = a.toObject();
  <span class="keyword">if</span> (isMongooseObject(b)) b = b.toObject();

  <span class="keyword">try</span> {
    <span class="keyword">var</span> ka = Object.keys(a),
        kb = Object.keys(b),
        key, i;
  } <span class="keyword">catch</span> (e) {<span class="comment">//happens when one is a string literal and the other isn't</span>
    <span class="keyword">return</span> <span class="literal">false</span>;
  }

  <span class="comment">// having the same number of owned properties (keys incorporates</span>
  <span class="comment">// hasOwnProperty)</span>
  <span class="keyword">if</span> (ka.length != kb.length)
    <span class="keyword">return</span> <span class="literal">false</span>;

  <span class="comment">//the same set of keys (although not necessarily the same order),</span>
  ka.sort();
  kb.sort();

  <span class="comment">//~~~cheap key test</span>
  <span class="keyword">for</span> (i = ka.length - <span class="number">1</span>; i >= <span class="number">0</span>; i--) {
    <span class="keyword">if</span> (ka[i] != kb[i])
      <span class="keyword">return</span> <span class="literal">false</span>;
  }

  <span class="comment">//equivalent values for every corresponding key, and</span>
  <span class="comment">//~~~possibly expensive deep test</span>
  <span class="keyword">for</span> (i = ka.length - <span class="number">1</span>; i >= <span class="number">0</span>; i--) {
    key = ka[i];
    <span class="keyword">if</span> (!deepEqual(a[key], b[key])) <span class="keyword">return</span> <span class="literal">false</span>;
  }

  <span class="keyword">return</span> <span class="literal">true</span>;
};</code></pre><h3>merge</h3><p>Merges <code>from</code> into <code>to</code> without overwriting<br />existing properties of <code>to</code>.</p><pre><code class="javascript">exports.merge = <span class="function"><span class="keyword">function</span> <span class="title">merge</span> <span class="params">(to, from)</span> {</span>
  <span class="keyword">var</span> keys = Object.keys(from)
    , i = keys.length
    , key

  <span class="keyword">while</span> (i--) {
    key = keys[i];
    <span class="keyword">if</span> (<span class="string">'undefined'</span> === <span class="keyword">typeof</span> to[key]) {
      to[key] = from[key];
    } <span class="keyword">else</span> {
      merge(to[key], from[key]);
    }
  }
};</code></pre><h3>args</h3><p>A faster Array.prototype.slice.call(arguments) alternative</p><pre><code class="javascript">exports.args = <span class="function"><span class="keyword">function</span> <span class="params">(args, slice, sliceEnd)</span> {</span>
  <span class="keyword">var</span> ret = [];
  <span class="keyword">var</span> start = slice || <span class="number">0</span>;
  <span class="keyword">var</span> end = <span class="number">3</span> === arguments.length
    ? sliceEnd
    : args.length;

  <span class="keyword">for</span> (<span class="keyword">var</span> i = start; i &lt; end; ++i) {
    ret[i - start] = args[i];
  }

  <span class="keyword">return</span> ret;
}</code></pre><h3>isMongooseObject</h3><p>Returns if <code>v</code> is a mongoose object that has<br />a <code>toObject()</code> method we can use. This is for<br />compatibility with libs like Date.js which do<br />foolish things to Natives.</p><pre><code class="javascript"><span class="keyword">var</span> isMongooseObject = exports.isMongooseObject = <span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
  Document || (Document = require(<span class="string">'./document'</span>));
  MongooseArray || (MongooseArray = require(<span class="string">'./types'</span>).Array);
  MongooseBuffer || (MongooseBuffer = require(<span class="string">'./types'</span>).Buffer);

  <span class="keyword">return</span> v <span class="keyword">instanceof</span> Document ||
         v <span class="keyword">instanceof</span> MongooseArray ||
         v <span class="keyword">instanceof</span> MongooseBuffer
}</code></pre></li><li><a href="/docs/index.html">lib/virtualtype.js</a><h3>VirtualType</h3><p>VirtualType constructor</p>

<p>This is what mongoose uses to define virtual attributes via<br /><code>Schema.prototype.virtual</code></p><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">VirtualType</span> <span class="params">(options)</span> {</span>
  <span class="keyword">this</span>.getters = [];
  <span class="keyword">this</span>.setters = [];
  <span class="keyword">this</span>.options = options || {};
}</code></pre><h3>get</h3><p>Adds a getter</p><pre><code class="javascript">VirtualType.prototype.get = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
  <span class="keyword">this</span>.getters.push(fn);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>set</h3><p>Adds a setter</p><pre><code class="javascript">VirtualType.prototype.set = <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
  <span class="keyword">this</span>.setters.push(fn);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};</code></pre><h3>applyGetters</h3><p>Applies getters</p><pre><code class="javascript">VirtualType.prototype.applyGetters = <span class="function"><span class="keyword">function</span> <span class="params">(value, scope)</span> {</span>
  <span class="keyword">var</span> v = value;
  <span class="keyword">for</span> (<span class="keyword">var</span> l = <span class="keyword">this</span>.getters.length - <span class="number">1</span>; l >= <span class="number">0</span>; l--){
    v = <span class="keyword">this</span>.getters[l].call(scope, v);
  }
  <span class="keyword">return</span> v;
};</code></pre><h3>applySetters</h3><p>Applies setters</p><pre><code class="javascript">VirtualType.prototype.applySetters = <span class="function"><span class="keyword">function</span> <span class="params">(value, scope)</span> {</span>
  <span class="keyword">var</span> v = value;
  <span class="keyword">for</span> (<span class="keyword">var</span> l = <span class="keyword">this</span>.setters.length - <span class="number">1</span>; l >= <span class="number">0</span>; l--){
    <span class="keyword">this</span>.setters[l].call(scope, v);
  }
  <span class="keyword">return</span> v;
};

module.exports = VirtualType;</code></pre></li></ul></div></div><script>document.body.className = 'load';</script><script>/*
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-1122274-9']);
  _gaq.push(['_trackPageview']);
  
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
  
  // TODO
  // get number of groups members?
*/</script></body></html>